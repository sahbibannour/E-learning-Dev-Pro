(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.MindFusion = global.MindFusion || {}, global.MindFusion.Scheduling = {})));
}(this, (function (exports) { 'use strict';

function __$styleInject(css, returnValue) {
  if (typeof document === 'undefined') {
    return returnValue;
  }
  css = css || '';
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  head.appendChild(style);
  
  if (style.styleSheet){
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
  return returnValue;
}

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
 * Specifies the type of view to display in a calendar control.
 * @enum {Number}
 */
var CalendarView = {
	/**
  * The calendar displays several months in a grid. The days of each month are visible too.
  */
	MonthRange: 0,
	/**
  * The calendar displays a single month at a time. The days of the month are displayed in a grid.
  */
	SingleMonth: 1,
	/**
  * The calendar displays a grid of days, with the columns representing the week days from Monday to Sunday and the rows representing weeks.
  */
	WeekRange: 2,
	/**
  * The calendar displays several seconds, minutes, hours, days, weeks, months or years in a row.
  */
	List: 3,
	/**
  * The calendar displays a timetable where each row represents a fixed arbitrary time interval and each column represents a day.
  */
	Timetable: 4,
	/**
  * The calendar displays the distribution of resources over a period of time.
  */
	ResourceView: 5
};

/**
 * Specifies the type of a timeline in a Resource view.
 * @enum {Number}
 */
var ResourceViewTimeline = {
	/**
  * Indicates the top timeline.
  */
	Top: 0,
	/**
  * Indicates the middle timeline.
  */
	Middle: 1,
	/**
  * Indicates the bottom timeline.
  */
	Bottom: 2
};

/**
 * Specifies a time resolution.
 * @enum {Number}
 */
var TimeUnit = {
	/**
  * Specifies seconds.
  */
	Second: 0,
	/**
  * Specifies minutes.
  */
	Minute: 1,
	/**
  * Specifies hours.
  */
	Hour: 2,
	/**
  * Specifies days.
  */
	Day: 3,
	/**
  * Specifies weeks.
  */
	Week: 4,
	/**
  * Specifies months.
  */
	Month: 5,
	/**
  * Specifies years.
  */
	Year: 6
};

/**
 * Specifies the display format of a day of the week.
 * @enum {Number}
 */
var DayOfWeekFormat = {
	/**
  * Only the first letter of the name of the day is displayed.
  */
	SingleLetter: 0,
	/**
  * The first three letters of the day of the week are displayed.
  */
	Abbreviated: 1,
	/**
  * The complete name of the day of the week is displayed.
  */
	Full: 2
};

/**
 * Specifies the appearance of the calendar's main header.
 * @enum {Number}
 */
var MainHeaderStyle = {
	/**
  * The header is not displayed.
  */
	None: 0,
	/**
  * The header displays a title.
  */
	Title: 1,
	/**
  * The header displays navigation buttons.
  */
	Buttons: 2
};

/**
 * Specifies the appearance of a vertical header in the calendar.
 * @enum {Number}
 */
var VerticalHeaderStyle = {
	/**
  * The header is not displayed.
  */
	None: 0,
	/**
  * The header is displayed to the left side of the calendar.
  */
	Left: 1,
	/**
  * The header is displayed to the right side of the calendar.
  */
	Right: 2
};

/**
 * Specifies the appearance of a horizontal header in the calendar.
 * @enum {Number}
 */
var HorizontalHeaderStyle = {
	/**
  * The header is not displayed.
  */
	None: 0,
	/**
  * The header is displayed to the top side of the calendar.
  */
	Top: 1,
	/**
  * The header is displayed to the bottom side of the calendar.
  */
	Bottom: 2
};

/* export const Position = {
	None: 0,
	Left: 1,
	Top: 2,
	Right: 3,
	Bottom: 4
}; */

/**
 * Specifies orientation for calendar elements.
 * @enum {Number}
 */
var Orientation = {
	/**
  * Indicates a horizontal orientation.
  */
	Horizontal: 0,
	/**
  * Indicates a vertical orientation.
  */
	Vertical: 1
};

/**
 * Specifies the priority of a task.
 * @enum {Number}
 */
var TaskPriority = {
	/**
  * Indicates low task priority.
  */
	Low: 0,

	/**
  * Indicates normal task priority.
  */
	Normal: 1,

	/**
  * Indicates high task priority.
  */
	High: 2
};

/**
 * Specifies status values for a task.
 * @enum {Number}
 */
var TaskStatus = {
	/**
  * Indicates that the task has not started yet.
  */
	NotStarted: 0,

	/**
  * Indicates a task in progress.
  */
	InProgress: 1,

	/**
  * Indicates a completed task.
  */
	Completed: 2,

	/**
  * Indicates a task that depends on another task.
  */
	WaitingOther: 3,

	/**
  * Indicates a deferred task.
  */
	Deferred: 4
};

/**
 * Specifies the type of a reminder.
 * @enum {Number}
 */
var ReminderType = {
	/**
  * Trigger the reminder at the exact time specified in its Date property.
  * Note: Recurring items cannot have exact reminders.
  */
	Exact: 0,

	/**
  * Trigger the reminder at the specified TimeInterval before the item's scheduled start time.
  * Note: Tasks cannot have leading reminders.
  */
	Leading: 1
};

/**
 * Specifies the recurrence state of items.
 * @enum {Number}
 */
var RecurrenceState = {
	/**
  * Specifies an one-time non-recurring event.
  */
	None: 0,

	/**
  * Specifies a single occurrence of a recurring event.
  */
	Occurrence: 1,

	/**
  * Specifies an exception of a recurring event.
  */
	Exception: 2,

	/**
  * Specifies a recurring event.
  */
	Master: 3
};

/**
 * Specifies the interval at which recurring events occur.
 * @remarks These values are assigned to the Pattern property of the Recurrence class.
 * @enum {Number}
 */
var RecurrencePattern = {
	/**
  * Repeats an event every day.
  */
	Daily: 0,

	/**
  * Repeats an event every week.
  */
	Weekly: 1,

	/**
  * Repeats an event every month.
  */
	Monthly: 2,

	/**
  * Repeats an event every year.
  */
	Yearly: 3,

	/**
  * Repeats an event over a specified time interval.
  */
	ByTimeInterval: 4
};

/**
 * Specifies daily recurrence patterns.
 * @enum {Number}
 */
var DailyRecurrence = {
	/**
  * Repeats the item at regular intervals specified in the Recurrence.Days property.
  */
	ByDayInterval: 0,

	/**
  * Repeats the item each workday, Monday through Friday.
  */
	EveryWorkday: 1,

	/**
  * Repeats the item each Saturday and Sunday.
  */
	EveryWeekend: 2
};

/**
 * Specifies monthly recurrence patterns.
 * @enum {Number}
 */
var MonthlyRecurrence = {
	/**
  * The event occurs on the given day of the month.
  */
	ByDayNumber: 0,

	/**
  * The event occurs on a given type of day in the specified week of the month.
  */
	ByDayType: 1
};

/**
 * Specifies types of yearly recurrence patterns.
 * @enum {Number}
 */
var YearlyRecurrence = {
	/**
  * The event occurs on a specific date of the year.
  */
	SpecificDate: 0,

	/**
  * The event occurs on a specific type of day of the specified  week and month of the year.
  */
	ByDayType: 1
};

/**
 * Specifies the index of occurrence.
 * @enum {Number}
 */
var Occurrence = {
	/**
  * Indicates the first occurrence.
  */
	First: 0,

	/**
  * Indicates the second occurrence.
  */
	Second: 1,

	/**
  * Indicates the third occurrence.
  */
	Third: 2,

	/**
  * Indicates the fourth occurrence.
  */
	Fourth: 3,

	/**
  * Indicates the last occurrence.
  */
	Last: 4
};

/**
 * Specifies the type of week day to use with ByDayType monthly and yearly recurrence patterns.
 * @enum {Number}
 */
var DayOfWeekType = {
	/**
  * Indicates any day.
  */
	AnyDay: 0,

	/**
  * Indicates a workday.
  */
	Workday: 1,

	/**
  * Indicates a weekend day.
  */
	Weekend: 2,

	/**
  * Indicates Sunday.
  */
	Sunday: 3,

	/**
  * Indicates Monday.
  */
	Monday: 4,

	/**
  * Indicates Tuesday.
  */
	Tuesday: 5,

	/**
  * Indicates Wednesday.
  */
	Wednesday: 6,

	/**
  * Indicates Thursday.
  */
	Thursday: 7,

	/**
  * Indicates Friday.
  */
	Friday: 8,

	/**
  * Indicates Saturday.
  */
	Saturday: 9
};

/**
 * Specifies when to stop repeating recurring events.
 * @enum {Number}
 */
var RecurrenceEnd = {
	/**
  * Never stop repeating events.
  */
	Never: 0,

	/**
  * Stop repeating events after a specified number of occurrences.
  */
	NumOccurrences: 1,

	/**
  * The recurrence ends at a specified date.
  */
	EndDate: 2
};

/**
 * Specifies the day of the week.
 * @enum {Number}
 */
var DayOfWeek = {
	/**
  * Indicates Sunday.
  */
	Sunday: 0,
	/**
  * Indicates Monday.
  */
	Monday: 1,
	/**
  * Indicates Tuesday.
  */
	Tuesday: 2,
	/**
  * Indicates Wednesday.
  */
	Wednesday: 3,
	/**
  * Indicates Thursday.
  */
	Thursday: 4,
	/**
  * Indicates Friday.
  */
	Friday: 5,
	/**
  * Indicates Saturday.
  */
	Saturday: 6
};

/**
 * Specifies the day of the week. This enum allows bitwise combination of its members.
 * @enum {Number}
 */
var DaysOfWeek = {
	/**
  * Indicates an undefined day value.
  */
	None: 0,

	/**
  * Indicates Sunday.
  */
	Sunday: 0x1,

	/**
  * Indicates Monday.
  */
	Monday: 0x2,

	/**
  * Indicates Tuesday.
  */
	Tuesday: 0x4,

	/**
  * Indicates Wednesday.
  */
	Wednesday: 0x8,

	/**
  * Indicates Thursday.
  */
	Thursday: 0x10,

	/**
  * Indicates Friday.
  */
	Friday: 0x20,

	/**
  * Indicates Saturday.
  */
	Saturday: 0x40,

	/**
  * Indicates all days of the week.
  */
	All: 0x7F
};

/**
 * Specifies the type of modification action used, when an item is modified.
 * @enum {Number}
 */
var ItemModifyAction = {
	/**
  * Specifies that the item was modified through a modification of one or more of its properties, excluding drag and resize interactive operations.
  */
	Edit: 0,
	/**
  * Specifies that the item is modified through an interactive drag operation.
  */
	Drag: 1,
	/**
  * Specifies that the item is modified through an interactive resize operation.
  */
	Resize: 2,
	/**
  * Specifies that the item is modified through an interactive inplace-edit operation.
  */
	InplaceEdit: 3
};

/**
 * Specifies grouping or filtering criteria for views that support grouping.
 * @enum {Number}
 */
var GroupType = {
	/**
  * No grouping or filtering.
  */
	None: 0,
	/**
  * Group by contacts.
  */
	GroupByContacts: 1,
	/**
  * Group by resources.
  */
	GroupByResources: 2,
	/**
  * Group by locations.
  */
	GroupByLocations: 3,
	/**
  * Group by tasks.
  */
	GroupByTasks: 4,
	/**
  * Filter by contacts.
  */
	FilterByContacts: 5,
	/**
  * Filter by locations.
  */
	FilterByLocations: 6,
	/**
  * Filter by tasks.
  */
	FilterByTasks: 7,
	/**
  * Filter by resources.
  */
	FilterByResources: 8
};

/**
 * Specifies whether there are multiple weeks displayed in WeekRange view.
 * @enum {Number}
 */
var WeekRangeViewStyle = {
	/**
  * The calendar view displays several weeks at a time.
  */
	WeekPerRow: 0,
	/**
  * The calendar view displays a single week at a time.
  */
	SingleWeek: 1
};

/**
 * Identifies special Keys.
 * @enum {Number}
 */
var Keys = {
	/**
  * No key pressed.
  */
	None: 0,
	/**
  * Indicates the SHIFT modifier key.
  */
	Shift: 1,
	/**
  * Indicates the CTRL modifier key.
  */
	Control: 2,
	/**
  * Indicates the ALT modifier key.
  */
	Alt: 3
};

/**
 * Specifies the type of a calendar header.
 * @enum {Number}
 */
var HeaderType = {
	/**
  * Indicates a date cell header.
  */
	Cell: 0,
	/**
  * Indicates the main view header.
  */
	Main: 1,
	/**
  * Indicates the group header.
  */
	Group: 2,
	/**
  * Indicates the timeline header.
  */
	Timeline: 3,
	/**
  * Indicates the day names header.
  */
	DayNames: 4,
	/**
  * Indicates the week numbers header.
  */
	WeekNumbers: 5
};

/** 
* Specifies the type of calendar repaint.
*/
var RepaintType = {
	/**
  * Recreate all calendar elements, same as calling the calendar's render method.
  */
	Full: 0,
	/**
  * Recreates item visuals and repaints the view contents, same as calling the view's clearAppointments and init methods.
  */
	ViewItems: 1,
	/**
  * Repaints the view contents, same as calling the view's init method.
  */
	ViewContent: 2
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/** 
* @class Represents a time interval.
* @property {Number} ticks Gets the number of ticks that represent the value of the time span.
* @property {Number} milliseconds Gets the number of milliseconds that represent the value of the time span.
* @property {Number} seconds Gets the number of seconds that represent the value of the time span.
* @property {Number} minutes Gets the number of minutes that represent the value of the time span.
* @property {Number} hours Gets the number of hours that represent the value of the time span.
* @property {Number} days Gets the number of days that represent the value of the time span.
*/
var TimeSpan = function () {
    /** 
    * Initializes a new instance of the TimeSpan class.
    * @constructor
    * @param {Number} ticks The number of ticks that represent the value of the time span.
    */
    function TimeSpan(ticks) {
        classCallCheck(this, TimeSpan);

        this._ticks = ticks;
    }
    /** 
    * Returns a new TimeSpan object whose value is the sum of the specified TimeSpan object and this instance.
    * @param {TimeSpan} timespan The TimeSpan object to add.
    * @returns {TimeSpan} The resulting time span.
    */


    createClass(TimeSpan, [{
        key: 'add',
        value: function add(timespan) {
            return new TimeSpan(this.ticks + timespan.ticks);
        }
        /** 
        * Returns a new TimeSpan object whose value is the difference between the specified TimeSpan object and this instance.
        * @param {TimeSpan} timespan The TimeSpan object to subtract.
        * @returns {TimeSpan} The resulting time span.
        */

    }, {
        key: 'subtract',
        value: function subtract(timespan) {
            return new TimeSpan(this.ticks - timespan.ticks);
        }
        /** 
        * Gets the number of ticks that represent the value of the time span.
        * @returns {Number} The number of ticks.
        */

    }, {
        key: 'clone',


        /** 
        * Creates a copy of the time span.
        * @returns {TimeSpan} The resulting time span.
        */
        value: function clone() {
            return new TimeSpan(this.ticks);
        }
        /** 
        * Checks if the time span object represents the same time value as the current instance.
        * @returns {Boolean} True if the time spans represent the same time value, otherwise false.
        */

    }, {
        key: 'equals',
        value: function equals(timespan) {
            return this.ticks === timespan.ticks;
        }
        /** 
        * Returns a TimeSpan that represents a specified number of milliseconds.
        * @param {Number} milliseconds The number of milliseconds.
        * @returns {TimeSpan} The resulting time span.
        */

    }, {
        key: 'ticks',
        get: function get$$1() {
            return this._ticks;
        }
        /** 
        * Gets the number of milliseconds that represent the value of the time span.
        * @returns {Number} The number of milliseconds.
        */

    }, {
        key: 'milliseconds',
        get: function get$$1() {
            return this._ticks / DateTime.TicksPerMillisecond;
        }
        /** 
        * Gets the number of seconds that represent the value of the time span.
        * @returns {Number} The number of seconds.
        */

    }, {
        key: 'seconds',
        get: function get$$1() {
            return this._ticks / DateTime.TicksPerSecond;
        }
        /** 
        * Gets the number of minutes that represent the value of the time span.
        * @returns {Number} The number of minutes.
        */

    }, {
        key: 'minutes',
        get: function get$$1() {
            return this._ticks / DateTime.TicksPerMinute;
        }
        /** 
        * Gets the number of hours that represent the value of the time span.
        * @returns {Number} The number of hours.
        */

    }, {
        key: 'hours',
        get: function get$$1() {
            return this._ticks / DateTime.TicksPerHour;
        }
        /** 
        * Gets the number of days that represent the value of the time span.
        * @returns {Number} The number of days.
        */

    }, {
        key: 'days',
        get: function get$$1() {
            return this._ticks / DateTime.TicksPerDay;
        }
    }], [{
        key: 'fromMilliseconds',
        value: function fromMilliseconds(milliseconds) {
            return new TimeSpan(milliseconds * DateTime.TicksPerMillisecond);
        }
        /** 
        * Returns a TimeSpan that represents a specified number of seconds.
        * @param {Number} seconds The number of seconds.
        * @returns {TimeSpan} The resulting time span.
        */

    }, {
        key: 'fromSeconds',
        value: function fromSeconds(seconds) {
            return new TimeSpan(seconds * DateTime.TicksPerSecond);
        }
        /** 
        * Returns a TimeSpan that represents a specified number of minutes.
        * @param {Number} minutes The number of minutes.
        * @returns {TimeSpan} The resulting time span.
        */

    }, {
        key: 'fromMinutes',
        value: function fromMinutes(minutes) {
            return new TimeSpan(minutes * DateTime.TicksPerMinute);
        }
        /** 
        * Returns a TimeSpan that represents a specified number of hours.
        * @param {Number} hours The number of hours.
        * @returns {TimeSpan} The resulting time span.
        */

    }, {
        key: 'fromHours',
        value: function fromHours(hours) {
            return new TimeSpan(hours * DateTime.TicksPerHour);
        }
        /** 
        * Returns a TimeSpan that represents a specified number of days.
        * @param {Number} days The number of days.
        * @returns {TimeSpan} The resulting time span.
        */

    }, {
        key: 'fromDays',
        value: function fromDays(days) {
            return new TimeSpan(days * DateTime.TicksPerDay);
        }
    }]);
    return TimeSpan;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* @class A Javascript Date object wrapper that extends the functionality of the JavaScript Date object. 
* @remarks It has all the capabilities of the Date class, plus it adds several helper methods to manipulate its date and time components.
* All date and time objects in the calendar are represented by this class.
* @property {DateTime} date Gets the date component of this DateTime object.
* @property {Number} timeOfDay Gets the time component of this DateTime object, expressed in milliseconds.
* @property {Number} dayOfWeek Gets the day of the week represented by this date.
* @property {Number} daysInMonth Gets the number of days in the month represented by this date.
* @property {Number} day Gets the day component of the date represented by this instance.
* @property {Number} month Gets the month component of the date represented by this instance.
* @property {Number} year Gets the year component of the date represented by this instance.
* @property {Number} hour Gets the hour component of the date represented by this instance.
* @property {Number} minute Gets the minute component of the date represented by this instance.
* @property {Number} second Gets the second component of the date represented by this instance.
* @property {Number} millisecond Gets the millisecond component of the date represented by this instance.
*/
var DateTime = function () {
  /**
  * Initializes a new instance of the DateTime class.
  * @constructor
  * @param {Date} date A JavaScript Date object.
  */
  function DateTime(date) {
    classCallCheck(this, DateTime);

    if (date == null) {
      this._date = new Date();
      this._ticks = this._date.getTime();
      return;
    }
    if (date.getTime != null) {
      this._date = new Date(date.getTime());
      this._ticks = date.getTime();
    } else {

      this._ticks = date;
      this._date = new Date(date + new Date(date).getTimezoneOffset() * DateTime.MillisPerMinute);

      // adjust for possible dst differences.
      var dstDiff = this._date.getTimezoneOffset() - new Date(date).getTimezoneOffset();

      this._date = new Date(this._date.valueOf() + dstDiff * DateTime.MillisPerMinute);
    }
  }

  /**
   * Creates a new DateTime object, by specifying its different date and time components.
   * @param {Number} year The year component.
   * @param {Number} month The month component (0-11).
   * @param {Number} [day] The day component (1-31). If not provided, a default value of 1 will be used.
   * @param {Number} [hours] The hours component (0-23). If not provided, a default value of 0 will be used.
   * @param {Number} [minutes] The minutes component (0-59). If not provided, a default value of 0 will be used.
   * @param {Number} [seconds] The seconds component (0-59). If not provided, a default value of 0 will be used.
   * @param {Number} [milliseconds] The milliseconds component (0-999). If not provided, a default value of 0 will be used.
   * @returns {DateTime} The new DateTime object, or null if a Date instance cannot be created from the provided values.
   */


  createClass(DateTime, [{
    key: 'toString',


    // End of static members

    /**
     * Returns a string representation of the current DateTime object.
     * @param {String} [format] The DateTime format used for the string representation.
     * @param {Object} [formatInfo] The formatInfo object used for the string representation.
     * @returns {String} The string representation of the current DateTime object.
     */
    value: function toString(format, formatInfo) {
      if (format != null && formatInfo != null) return DateTime.formatDate(this._date, format, formatInfo);
      return this._date.toString();
    }

    /**
     * Represents the primitive value of this DateTime object.
     * @returns {Number} The primitive value of this DateTime object in milliseconds. 
     */

  }, {
    key: 'valueOf',
    value: function valueOf() {
      return this._date.valueOf();
    }

    /**
     * Returns a copy of the current DateTime object.
     * @returns {DateTime} The cloned DateTime object.
     */

  }, {
    key: 'clone',
    value: function clone() {
      var date = new DateTime(this._date, this._offset);
      date._ticks = this._ticks;
      return date;
    }

    /**
     * Returns a value indicating whether two DateTime objects are equal.
     * @param {DateTime} date The DateTime object to compare with.
     * @returns {Boolean} True if the values are equal, otherwise false.
     */

  }, {
    key: 'equals',
    value: function equals(date) {
      return this._date.getTime() == date._date.getTime();
    }

    /**
    * Subtracts the specified date from the current date and returns the number of milliseconds between them.
    * @param {DateTime} date The date to subtract.
    * @returns {Number} The number of milliseconds between the specified date and this date.
    */

  }, {
    key: 'subtract',
    value: function subtract(date) {
      var date2 = new DateTime(date)._date;
      var h = this._date.getTime() - date2.getTime();
      var zoneDiff = this._date.getTimezoneOffset() - date2.getTimezoneOffset();
      return h - zoneDiff * DateTime.MillisPerMinute;
    }

    /**
     * Checks if this DateTime object is greater than the specified DateTime object.
     * @param {DateTime} date The DateTime object to compare with.
     * @returns {Boolean} true if this value is greater than the specified value, otherwise false.
     */

  }, {
    key: 'greaterThan',
    value: function greaterThan(date) {
      return this._date.getTime() > date._date.getTime();
    }

    /**
     * Checks if this DateTime object is greater than or equal to the specified DateTime object.
     * @param {DateTime} date The DateTime object to compare with.
     * @returns {Boolean} true if this value is greater than or equal to the specified value, otherwise false.
     */

  }, {
    key: 'greaterThanOrEqual',
    value: function greaterThanOrEqual(date) {
      return this._date.getTime() >= date._date.getTime();
    }

    /**
     * Checks if this DateTime object is less than the specified DateTime object.
     * @param {DateTime} date The DateTime object to compare with.
     * @returns {Boolean} true if this value is less than the specified value, otherwise false.
     */

  }, {
    key: 'lessThan',
    value: function lessThan(date) {
      return this._date.getTime() < date._date.getTime();
    }

    /**
     * Checks if this DateTime object is less than or equal to the specified DateTime object.
     * @param {DateTime} date The DateTime object to compare with.
     * @returns {Boolean} true if this value is less than or equal to the specified value, otherwise false.
     */

  }, {
    key: 'lessThanOrEqual',
    value: function lessThanOrEqual(date) {
      return this._date.getTime() <= date._date.getTime();
    }

    /**
     * Compares the current DateTime instance with another DateTime object 
     * and returns an integer that indicates whether the current instance precedes, 
     * follows, or occurs in the same position in the sort order as the other object.
     * @param {DateTime} date A DateTime object to compare with this instance.
     * @returns {Number} A value that indicates the relative order of the DateTime objects being compared.
     * @remarks The return value has these meanings:
     * -1 - This instance precedes dateTime in the sort order.
     * 0 - This instance occurs in the same position in the sort order as dateTime.
     * 1 - This instance follows dateTime in the sort order.
     */

  }, {
    key: 'compareTo',
    value: function compareTo(date) {
      if (date._date.getTime() > this._date.getTime()) return -1;
      if (date._date.getTime() < this._date.getTime()) return 1;
      return 0;
    }

    /**
     * Adds the specified number of milliseconds to the current DateTime object.
     * @param {Number} milliseconds The number of milliseconds to add.
     */

  }, {
    key: 'addMilliseconds',
    value: function addMilliseconds(milliseconds) {
      if (milliseconds != null) {
        this._date = new Date(this._date.getTime() + milliseconds);
        this._ticks += milliseconds;
      }
      return this;
    }

    /**
     * Adds the specified number of seconds to the current DateTime object.
     * @param {Number} seconds The number of seconds to add.
     */

  }, {
    key: 'addSeconds',
    value: function addSeconds(seconds) {
      if (seconds != null) {
        //var newDate = new Date(this._date.getTime());
        //this._date = new Date(newDate.setSeconds(newDate.getSeconds() + seconds));
        this._date = new Date(this._date.getTime() + seconds * DateTime.MillisPerSecond);
        this._ticks += seconds * DateTime.MillisPerSecond;
      }
      return this;
    }

    /**
     * Adds the specified number of minutes to the current DateTime object.
     * @param {Number} minutes The number of minutes to add.
     */

  }, {
    key: 'addMinutes',
    value: function addMinutes(minutes) {
      if (minutes != null) {
        //var newDate = new Date(this._date.getTime());
        //this._date = new Date(newDate.setMinutes(newDate.getMinutes() + minutes));
        this._date = new Date(this._date.getTime() + minutes * DateTime.MillisPerMinute);
        this._ticks += minutes * DateTime.MillisPerMinute;
      }
      return this;
    }

    /**
     * Adds the specified number of hours to the current DateTime object.
     * @param {Number} hours The number of hours to add.
     */

  }, {
    key: 'addHours',
    value: function addHours(hours) {
      if (hours != null) {
        //var newDate = new Date(this._date.getTime());
        //this._date = new Date(newDate.setHours(newDate.getHours() + hours));
        this._date = new Date(this._date.getTime() + hours * DateTime.MillisPerHour);
        this._ticks += hours * DateTime.MillisPerHour;
      }
      return this;
    }

    /**
     * Adds the specified number of days to the current DateTime object.
     * @param {Number} days The number of days to add.
     */

  }, {
    key: 'addDays',
    value: function addDays(days) {
      if (days != null) {
        var newDate = new Date(this._date.getTime());
        this._date = new Date(newDate.setDate(newDate.getDate() + days));
        this._ticks = new DateTime(this._date, this._offset)._ticks;
      }
      return this;
    }

    /**
     * Adds the specified number of months to the current DateTime object.
     * @param {Number} months The number of months to add.
     */

  }, {
    key: 'addMonths',
    value: function addMonths(months) {
      if (months != null) {
        var newDate = new Date(this._date.getTime());
        this._date = new Date(newDate.setMonth(newDate.getMonth() + months));
        this._ticks = new DateTime(this._date, this._offset)._ticks;
      }
      return this;
    }

    /**
    * Adds the specified number of years to the current DateTime object.
    * @param {Number} years The number of years to add.
    */

  }, {
    key: 'addYears',
    value: function addYears(years) {
      if (years != null) {
        var newDate = new Date(this._date.getTime());
        this._date = new Date(newDate.setFullYear(newDate.getFullYear() + years));
        this._ticks = new DateTime(this._date, this._offset)._ticks;
      }
      return this;
    }

    /**
     * Returns the Javascript Date object, corresponding to the current DateTime object.
     * @returns {Object} The Javascript Date object, corresponding to the current DateTime object.
     */

  }, {
    key: 'getDate',
    value: function getDate() {
      return DateTime.getDate(this.toUTCDate());
    }

    /**
     * Returns the month component of the current DateTime object.
     * @returns {Number} The month.
     */

  }, {
    key: 'getMonth',
    value: function getMonth() {
      return this._date.getMonth();
    }

    /** 
     * Returns the number of days in the month of the current DateTime instance.
     * @returns {Number} The number of days.
     */

  }, {
    key: 'getDaysInMonth',
    value: function getDaysInMonth(isLeapYear) {
      if (isLeapYear == undefined) isLeapYear = this.isLeapYear();

      var month = this._date.getMonth();
      if (month <= 6 && month % 2 === 0 || month > 6 && month % 2 !== 0) {
        return 31;
      }
      if (month === 1) {
        if (isLeapYear) {
          return 29;
        }
        return 28;
      }
      return 30;
    }

    /** 
     * Returns a value indicating whether the year of the current DateTime instance is a leap year.
     * @returns {Boolean} True if it is a leap year, otherwise false.
     */

  }, {
    key: 'isLeapYear',
    value: function isLeapYear() {
      var year = this._date.getFullYear();
      if (year % 4 === 0) {
        if (year % 100 === 0) {
          if (year % 400 !== 0) {
            return false;
          }
          return true;
        }
        return true;
      }
      return false;
    }

    /**
    * Gets the millisecond component of the date represented by this instance.
    */

  }, {
    key: 'subtract2',


    /** 
     * For internal use only.
     * @private
     */
    value: function subtract2(date) {
      return this._date.valueOf() - date._date.valueOf();
    }

    /** 
     * For internal use only.
     * @private
     */

  }, {
    key: 'isInDst',


    /** 
     * For internal use only.
     * @private
     */
    value: function isInDst() {
      var janDate = new Date(this._date.getFullYear(), 0, 1).getTimezoneOffset();
      var julDate = new Date(this._date.getFullYear(), 6, 1).getTimezoneOffset();
      if (janDate !== julDate) {
        if (this._date.getTimezoneOffset() === janDate) {
          return -1;
        }
        return 1;
      }
      return 0;
    }

    // /** 
    //  * For internal use only.
    //  * @private
    //  */
    // toDate(/*offset*/) {
    //   return this._date;
    // }

    /** 
     * For internal use only.
     * @private
     */

  }, {
    key: 'toUTCDate',
    value: function toUTCDate() {
      return this._date;
    }

    /**
    * For internal use only.
    * @private
    */

  }, {
    key: 'addTicksToDate',
    value: function addTicksToDate(ticks) {
      if (ticks != null) {
        var e = this._date.getTimezoneOffset();
        var i = new Date(this._date.getTime() + ticks);
        var h = i.getTimezoneOffset() - e;
        this._date = new Date(i.getTime() + h * DateTime.MillisPerMinute);
      }
      return this;
    }

    /** 
    * For internal use only.
    * @private
    * used in recurrence
    */

  }, {
    key: 'getTimeOfTheDay',
    value: function getTimeOfTheDay() {
      return DateTime.getTimeOfDay(this.toUTCDate());
    }

    // /**
    //  * For internal use only.
    //  * @private
    //  */
    // findPart(what, parts) {
    //   for (let i = 0; i < parts.length; i += 1) {
    //     const p = parts[i];
    //     if (p.type === what)
    //       return p.value;
    //   }
    // }

    /** 
     * For internal use only.
     * @private
     * used in recurrence
     */

  }, {
    key: 'getDay',
    value: function getDay() {
      return Math.pow(2, this._date.getDay());
    }

    /** 
     * For internal use only.
     * @private
     * used in popup
     */

  }, {
    key: 'getMonthlyOccurrenceIndex',
    value: function getMonthlyOccurrenceIndex() {
      var dayOfWeek = this._date.getDay();
      var firstIs = new Date(this._date.getFullYear(), this._date.getMonth(), 1, 0, 0, 0).getDay();
      var day = this._date.getDate();
      var offset = Math.abs(dayOfWeek - firstIs);
      var d = day - offset - 1;
      return d / 7;
    }

    // JavaScript Date object API implementation
    /**
    * Gets the year component of this DateTime instance.
    * @returns {Number} The year (four digits).
    */

  }, {
    key: '__getFullYear',
    value: function __getFullYear() {
      return this._date.getFullYear();
    }

    /**
    * Gets the month component of this DateTime instance.
    * @returns {Number} The month (0-11). 0 is January, 1 is February, etc.
    */

  }, {
    key: '__getMonth',
    value: function __getMonth() {
      return this._date.getMonth();
    }

    /**
     * Gets the day component of this DateTime instance.
     * @returns {Number} The day of month (1-31).
     */

  }, {
    key: '__getDate',
    value: function __getDate() {
      return this._date.getDate();
    }

    /**
     * Gets the day of the week component of this DateTime instance.
     * @returns {Number} The day of the week (0-6). 0 is Sunday, 1 is Monday, etc.
     */

  }, {
    key: '__getDay',
    value: function __getDay() {
      return this._date.getDay();
    }

    /**
     * Gets the hours component of this DateTime instance.
     * @returns {Number} The hours (0-23).
     */

  }, {
    key: '__getHours',
    value: function __getHours() {
      return this._date.getHours();
    }

    /**
     * Gets the minutes component of this DateTime instance.
     * @returns {Number} The minutes (0-59).
     */

  }, {
    key: '__getMinutes',
    value: function __getMinutes() {
      return this._date.getMinutes();
    }

    /**
     * Gets the seconds component of this DateTime instance.
     * @returns {Number} The seconds (0-59).
     */

  }, {
    key: '__getSeconds',
    value: function __getSeconds() {
      return this._date.getSeconds();
    }

    /**
    * Gets the milliseconds component of this DateTime instance.
    * @returns {Number} The milliseconds (0-999).
    */

  }, {
    key: '__getMilliseconds',
    value: function __getMilliseconds() {
      return this._date.getMilliseconds();
    }

    /**
     * Gets the number of milliseconds between Jan 1 1970 00:00:00 and this DateTime instance.
     * @returns {Number} The number of milliseconds since Jan 1 1970 00:00:00.
     */

  }, {
    key: '__getTime',
    value: function __getTime() {
      return this._date.getTime();
    }

    /**
     * Gets the difference between GMT and local time in minutes.
     * @returns {Number} The difference between GMT and local time in minutes.
     */

  }, {
    key: '__getTimezoneOffset',
    value: function __getTimezoneOffset() {
      return this._date.getTimezoneOffset();
    }

    /**
    * Gets the year component of this DateTime instance, according to universal time.
    * @returns {Number} The year (four digits).
    */

  }, {
    key: '__getUTCFullYear',
    value: function __getUTCFullYear() {
      return this._date.getUTCFullYear();
    }

    /**
    * Gets the month component of this DateTime instance, according to universal time.
    * @returns {Number} The month (0-11). 0 is January, 1 is February, etc.
    */

  }, {
    key: '__getUTCMonth',
    value: function __getUTCMonth() {
      return this._date.getUTCMonth();
    }

    /**
     * Gets the day component of this DateTime instance, according to universal time.
     * @returns {Number} The day of month (1-31).
     */

  }, {
    key: '__getUTCDate',
    value: function __getUTCDate() {
      return this._date.getUTCDate();
    }

    /**
     * Gets the day of the week component of this DateTime instance, according to universal time.
     * @returns {Number} The day of the week (0-6). 0 is Sunday, 1 is Monday, etc.
     */

  }, {
    key: '__getUTCDay',
    value: function __getUTCDay() {
      return this._date.getUTCDay();
    }

    /**
     * Gets the hours component of this DateTime instance, according to universal time.
     * @returns {Number} The hours (0-23).
     */

  }, {
    key: '__getUTCHours',
    value: function __getUTCHours() {
      return this._date.getUTCHours();
    }

    /**
    * Gets the minutes component of this DateTime instance, according to universal time.
    * @returns {Number} The minutes (0-59).
    */

  }, {
    key: '__getUTCMinutes',
    value: function __getUTCMinutes() {
      return this._date.getUTCMinutes();
    }

    /**
    * Gets the seconds component of this DateTime instance, according to universal time.
    * @returns {Number} The seconds (0-59).
    */

  }, {
    key: '__getUTCSeconds',
    value: function __getUTCSeconds() {
      return this._date.getUTCSeconds();
    }

    /**
     * Gets the milliseconds component of this DateTime instance, according to universal time.
     * @returns {Number} The milliseconds (0-999).
     */

  }, {
    key: '__getUTCMilliseconds',
    value: function __getUTCMilliseconds() {
      return this._date.getUTCMilliseconds();
    }

    /**
     * Sets the year component of this DateTime instance.
     * @param {Number} year A four-digit value representing the year.
     * @param {Number} [month] An integer between 0 and 11 representing the month.
     * @param {Number} [day] An integer between 1 and 31 representing the date.
     */

  }, {
    key: '__setFullYear',
    value: function __setFullYear(year, month, day) {
      if (day === null || typeof day === 'undefined') {
        if (month === null || typeof month === 'undefined') {
          this._date.setFullYear(year);
          return;
        }
        this._date.setFullYear(year, month);
        return;
      }
      this._date.setFullYear(year, month, day);
    }

    /**
     * Sets the day component of this DateTime instance.
     * @param {Number} day The day of month (1-31).
     */

  }, {
    key: '__setDate',
    value: function __setDate(day) {
      this._date.setDate(day);
    }

    /**
     * Sets the hours component of this DateTime instance.
     * @param {Number} hour An integer between 0 and 23 representing the hour.
     * @param {Number} [min] An integer between 0 and 59 representing the minutes.
     * @param {Number} [sec] An integer between 0 and 59 representing the seconds.
     * @param {Number} [millisec] An integer between 0 and 999 representing the milliseconds.
     */

  }, {
    key: '__setHours',
    value: function __setHours(hour, min, sec, millisec) {
      if (millisec === null || typeof millisec === 'undefined') {
        if (sec === null || typeof sec === 'undefined') {
          if (min === null || typeof min === 'undefined') {
            this._date.setHours(hour);
            return;
          }
          this._date.setHours(hour, min);
          return;
        }
        this._date.setHours(hour, min, sec);
        return;
      }
      this._date.setHours(hour, min, sec, millisec);
    }

    /**
    * Sets the minutes component of this DateTime instance.
    * @param {Number} min An integer between 0 and 59 representing the minutes.
    * @param {Number} [sec] An integer between 0 and 59 representing the seconds.
    * @param {Number} [millisec] An integer between 0 and 999 representing the milliseconds.
    */

  }, {
    key: '__setMinutes',
    value: function __setMinutes(min, sec, millisec) {
      if (millisec === null || typeof millisec === 'undefined') {
        if (sec === null || typeof sec === 'undefined') {
          this._date.setMinutes(min);
          return;
        }
        this._date.setMinutes(min, sec);
        return;
      }
      this._date.setMinutes(min, sec, millisec);
    }

    /**
    * Sets the seconds component of this DateTime instance.
    * @param {Number} sec An integer between 0 and 59 representing the seconds.
    * @param {Number} [millisec] An integer between 0 and 999 representing the milliseconds.
    */

  }, {
    key: '__setSeconds',
    value: function __setSeconds(sec, millisec) {
      if (millisec === null || typeof millisec === 'undefined') {
        this._date.setSeconds(sec);
        return;
      }
      this._date.setSeconds(sec, millisec);
    }

    /**
     * Sets the milliseconds component of this DateTime instance.
     * @param {Number} millisec An integer between 0 and 999 representing the milliseconds.
     */

  }, {
    key: '__setMilliseconds',
    value: function __setMilliseconds(millisec) {
      this._date.setMilliseconds(millisec);
    }

    /**
     * Sets a date and time by adding or subtracting a specified number of milliseconds to/from midnight 1 Jan 1970.
     * @param {Number} millisec The number of milliseconds to be added to, or subtracted from, midnight 1 Jan 1970.
     */

  }, {
    key: '__setTime',
    value: function __setTime(millisec) {
      this._date.setTime(millisec);
    }

    /**
     * Sets the year component of this DateTime instance, according to universal time.
     * @param {Number} year A four-digit value representing the year.
     * @param {Number} [month] An integer between 0 and 11 representing the month.
     * @param {Number} [day] An integer between 1 and 31 representing the date.
     */

  }, {
    key: '__setUTCFullYear',
    value: function __setUTCFullYear(year, month, day) {
      if (day === null || typeof day === 'undefined') {
        if (month === null || typeof month === 'undefined') {
          this._date.setUTCFullYear(year);
          return;
        }
        this._date.setUTCFullYear(year, month);
        return;
      }
      this._date.setUTCFullYear(year, month, day);
    }

    /**
    * Sets the day component of this DateTime instance, according to universal time.
    * @param {Number} day The day of month (1-31).
    */

  }, {
    key: '__setUTCDate',
    value: function __setUTCDate(day) {
      this._date.setUTCDate(day);
    }

    /**
     * Sets the hours component of this DateTime instance, according to universal time.
     * @param {Number} hour An integer between 0 and 23 representing the hour.
     * @param {Number} [min] An integer between 0 and 59 representing the minutes.
     * @param {Number} [sec] An integer between 0 and 59 representing the seconds.
     * @param {Number} [millisec] An integer between 0 and 999 representing the milliseconds.
     */

  }, {
    key: '__setUTCHours',
    value: function __setUTCHours(hour, min, sec, millisec) {
      if (millisec === null || typeof millisec === 'undefined') {
        if (sec === null || typeof sec === 'undefined') {
          if (min === null || typeof min === 'undefined') {
            this._date.setUTCHours(hour);
            return;
          }
          this._date.setUTCHours(hour, min);
          return;
        }
        this._date.setUTCHours(hour, min, sec);
        return;
      }
      this._date.setUTCHours(hour, min, sec, millisec);
    }

    /**
     * Sets the minutes component of this DateTime instance, according to universal time.
     * @param {Number} min An integer between 0 and 59 representing the minutes.
     * @param {Number} [sec] An integer between 0 and 59 representing the seconds.
     * @param {Number} [millisec] An integer between 0 and 999 representing the milliseconds.
     */

  }, {
    key: '__setUTCMinutes',
    value: function __setUTCMinutes(min, sec, millisec) {
      if (millisec === null || typeof millisec === 'undefined') {
        if (sec === null || typeof sec === 'undefined') {
          this._date.setUTCMinutes(min);
          return;
        }
        this._date.setUTCMinutes(min, sec);
        return;
      }
      this._date.setUTCMinutes(min, sec, millisec);
    }

    /**
     * Sets the seconds component of this DateTime instance, according to universal time.
     * @param {Number} sec An integer between 0 and 59 representing the seconds.
     * @param {Number} [millisec] An integer between 0 and 999 representing the milliseconds.
     */

  }, {
    key: '__setUTCSeconds',
    value: function __setUTCSeconds(sec, millisec) {
      if (millisec === null || typeof millisec === 'undefined') {
        this._date.setUTCSeconds(sec);
        return;
      }
      this._date.setUTCSeconds(sec, millisec);
    }

    /**
    * Sets the milliseconds component of this DateTime instance, according to universal time.
    * @param {Number} millisec An integer between 0 and 999 representing the milliseconds.
    */

  }, {
    key: '__setUTCMilliseconds',
    value: function __setUTCMilliseconds(millisec) {
      this._date.setUTCMilliseconds(millisec);
    }

    /**
     * Converts the date component of this DateTime instance to a readable string.
     * @returns {String} A readable string representation of the date component of this DateTime instance.
     */

  }, {
    key: '__toDateString',
    value: function __toDateString() {
      return this._date.toDateString();
    }

    /**
     * Converts the date component of this DateTime instance to a readable string, using locale conventions.
     * @returns {String} A readable locale string representation of the date component of this DateTime instance.
     */

  }, {
    key: '__toLocaleDateString',
    value: function __toLocaleDateString() {
      return this._date.toLocaleDateString();
    }

    /**
     * Converts the time component of this DateTime instance to a readable string, using locale conventions.
     * @returns {String} A readable locale string representation of the time component of this DateTime instance.
     */

  }, {
    key: '__toLocaleTimeString',
    value: function __toLocaleTimeString() {
      return this._date.toLocaleTimeString();
    }

    /**
     * Converts this DateTime instance to a readable string, using locale conventions.
     * @returns {String} A readable locale string representation of this DateTime instance.
     */

  }, {
    key: '__toLocaleString',
    value: function __toLocaleString() {
      return this._date.toLocaleString();
    }

    /**
     * Converts this DateTime instance to a readable string.
     * @returns {String} A readable string representation of this DateTime instance.
     */

  }, {
    key: '__toString',
    value: function __toString() {
      return this._date.toString();
    }

    /**
     * Converts the time component of this DateTime instance to a readable string.
     * @returns {String} A readable string representation of the time component of this DateTime instance.
     */

  }, {
    key: '__toTimeString',
    value: function __toTimeString() {
      return this._date.toTimeString();
    }

    /**
     * Converts this DateTime instance to a readable string, according to universal time.
     * @returns {String} A readable string representation of this DateTime instance.
     */

  }, {
    key: '__toUTCString',
    value: function __toUTCString() {
      return this._date.toUTCString();
    }

    /**
     * Represents the primitive value of this DateTime object.
     * @returns {Number} The primitive value of this DateTime object. 
     * @remarks The primitive value is returned as the number of millisecond since midnight January 1, 1970 (same as getTime())!
     */

  }, {
    key: '__valueOf',
    value: function __valueOf() {
      return this._date.valueOf();
    }

    // End of JavaScript Date object API implementation

  }, {
    key: 'millisecond',
    get: function get$$1() {
      return this._date.getMilliseconds();
    }
    /**
    * Gets the second component of the date represented by this instance.
    */

  }, {
    key: 'second',
    get: function get$$1() {
      return this._date.getSeconds();
    }
    /**
     * Gets the minute component of the date represented by this instance.
     */

  }, {
    key: 'minute',
    get: function get$$1() {
      return this._date.getMinutes();
    }
    /**
     * Gets the hour component of the date represented by this instance.
     */

  }, {
    key: 'hour',
    get: function get$$1() {
      return this._date.getHours();
    }
    /**
     * Gets the day component of the date represented by this instance.
     */

  }, {
    key: 'day',
    get: function get$$1() {
      return this._date.getDate();
    }
    /**
     * Gets the month component of the date represented by this instance.
     */

  }, {
    key: 'month',
    get: function get$$1() {
      return this._date.getMonth();
    }
    /**
     * Gets the year component of the date represented by this instance.
     */

  }, {
    key: 'year',
    get: function get$$1() {
      return this._date.getFullYear();
    }

    /**
    * Gets the date component of this DateTime object.
    */

  }, {
    key: 'date',
    get: function get$$1() {
      return new DateTime(DateTime.getDate(this._date));
    }

    /**
     * Gets the time component of this DateTime object, expressed in milliseconds.
     */

  }, {
    key: 'timeOfDay',
    get: function get$$1() {
      return this.subtract(this._date);
    }

    /**
    * Returns the day of the month represented by this date.
    */

  }, {
    key: 'dayOfMonth',
    get: function get$$1() {
      return this._date.getDate();
    }

    /**
     * Returns the day of the week represented by this date.
     */

  }, {
    key: 'dayOfWeek',
    get: function get$$1() {
      return this._date.getDay();
    }

    /**
     * Returns the number of days in the month represented by this date.
     */

  }, {
    key: 'daysInMonth',
    get: function get$$1() {
      return new Date(this._date.getFullYear(), this._date.getMonth() + 1, 0).getDate();
    }

    // Private members
    /**
     * Formats a Date instance by the specified format string.
     * @private
     */

  }], [{
    key: 'fromDateParts',
    value: function fromDateParts(year, month, day, hours, minutes, seconds, milliseconds) {
      if (year === null || typeof year !== 'number' || year < 1 || year > 9999 || month === null || typeof month !== 'number' || month < 0 || month > 11) {
        return null;
      }
      if (day === null || typeof day !== 'number' || day < 1 || day > 31) {
        day = 1;
      }
      if (hours === null || typeof hours !== 'number' || hours < 0 || hours > 23) {
        hours = 0;
      }
      if (minutes === null || typeof minutes !== 'number' || minutes < 0 || minutes > 59) {
        minutes = 0;
      }
      if (seconds === null || typeof seconds !== 'number' || seconds < 0 || seconds > 59) {
        seconds = 0;
      }
      if (milliseconds === null || typeof milliseconds !== 'number' || milliseconds < 0 || milliseconds > 999) {
        milliseconds = 0;
      }
      var date = new Date(year, month, day, hours, minutes, seconds, milliseconds);
      if (isNaN(date.valueOf())) {
        return null;
      }
      return new DateTime(date);
    }

    /**
     * Creates a new DateTime object from a provided date string.
     * @param {String} dateString The date string to create the DateTime from.
     * @returns {DateTime} The new DateTime object, or null if a Date instance cannot be created from the provided string.
     */

  }, {
    key: 'fromDateString',
    value: function fromDateString(dateString) {
      var date = new Date(dateString);
      if (isNaN(date.valueOf())) {
        return null;
      }
      return new DateTime(date);
    }

    /**
     * Creates a new DateTime object from the number of milliseconds since Jan 1st 1970.
     * @param {Number} milliseconds The number of milliseconds since Jan 1st 1970;
     * @returns {DateTime} The new DateTime object, or null if a Date instance cannot be created from the provided value.
     */

  }, {
    key: 'fromMilliseconds',
    value: function fromMilliseconds(milliseconds) {
      if (milliseconds === null || typeof milliseconds !== 'number') {
        return null;
      }
      var date = new Date(milliseconds);
      if (isNaN(date.valueOf())) {
        return null;
      }
      return new DateTime(date);
    }

    /** 
     * Combines the date component of a DateTime object and the time 
     * component of another DateTime object into a new DateTime object.
     * @param {DateTime} date A DateTime object to get the date part from.
     * @param {DateTime} time A DateTime object to get the time part from.
     * @returns {DateTime} The new combined DateTime object.
     */

  }, {
    key: 'combine',
    value: function combine(date, time) {
      var d = new Date(date._date.getFullYear(), date._date.getMonth(), date._date.getDate(), time._date.getHours(), time._date.getMinutes(), time._date.getSeconds());
      return new DateTime(d);
    }

    /**
     * Returns the latter of two DateTime objects.
     * @param {DateTime} date1 A DateTime object.
     * @param {DateTime} date2 A DateTime object.
     * @returns {DateTime} The latter of two DateTime objects.
     */

  }, {
    key: 'maxDate',
    value: function maxDate(date1, date2) {
      return date1._date.getTime() > date2._date.getTime() ? date1 : date2;
    }

    /**
     * Returns the former of two DateTime objects.
     * @param {DateTime} date1 A DateTime object.
     * @param {DateTime} date2 A DateTime object.
     * @returns {DateTime} The former of two DateTime objects.
     */

  }, {
    key: 'minDate',
    value: function minDate(date1, date2) {
      return date1._date.getTime() > date2._date.getTime() ? date2 : date1;
    }

    /**
    * Returns the number of milliseconds between the specified dates.
    * @param {DateTime} date1 The date to subtract from.
    * @param {DateTime} date2 The date to subtract.
    * @returns {Number} The number of milliseconds between the specified dates.
    */

  }, {
    key: 'subtract',
    value: function subtract(date1, date2) {
      date2 = new DateTime(date2).toUTCDate();
      var h = date1.getTime() - date2;
      var f = date1.getTimezoneOffset() - date2.getTimezoneOffset();
      return h - f * DateTime.MillisPerMinute;
    }

    /**
     * Returns the lowest possible DateTime value.
     * @returns {DateTime} The lowest possible DateTime value.
     * @remarks Represents 1 Jan 0001 00:00:00.
     */

  }, {
    key: 'minValue',
    value: function minValue() {
      //0001.01.01 00:00:00
      return new DateTime(-62135596800000);
    }
    /**
     * Returns the highest possible DateTime value.
     * @returns {DateTime} The highest possible DateTime value.
     * @remarks Represents 31 Dec 9999 23:59:59.
     */

  }, {
    key: 'maxValue',
    value: function maxValue() {
      //9999.12.31 23:59:59
      return new DateTime(253402300799999);
    }

    /**
     * Returns a DateTime object representing the current DateTime.
     * @returns {DateTime} The DateTime object representing the current DateTime.
     */

  }, {
    key: 'now',
    value: function now() {
      var d = new Date();
      var i = d.getTimezoneOffset() * DateTime.MillisPerMinute;
      return new DateTime(d.getTime() - i);
    }

    /**
     * Returns a DateTime object representing the current Date.
     * @returns {DateTime} The DateTime object representing the current Date.
     */

  }, {
    key: 'today',
    value: function today() {
      var now = new Date();
      var today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      var i = today.getTimezoneOffset() * DateTime.MillisPerMinute;
      return new DateTime(today.getTime() - i);
    }

    /**
     * Returns the year component of the specified DateTime.
     * @param {DateTime} date A DateTime instance.
     * @returns {Number} The year.
     */

  }, {
    key: 'getYear',
    value: function getYear(date) {
      return date._date.getFullYear();
    }

    /**
     * Returns the month component of the specified DateTime.
     * @param {DateTime} date A DateTime instance.
     * @returns {Number} The month.
     */

  }, {
    key: 'getMonth',
    value: function getMonth(date) {
      return date._date.getMonth();
    }

    /**
     * Returns the number of days in the month of the specified DateTime.
     * @param {DateTime} date A DateTime instance.
     * @returns {Number} The number of days.
     */

  }, {
    key: 'getDaysInMonth',
    value: function getDaysInMonth(date) {
      return new Date(date._date.getFullYear(), date._date.getMonth() + 1, 0).getDate();
    }

    /**
     * Returns the day of the month of the specified DateTime.
     * @param {DateTime} date A DateTime instance.
     * @returns {Number} The day of the month.
     */

  }, {
    key: 'getDayOfMonth',
    value: function getDayOfMonth(date) {
      return date._date.getDate();
    }

    /**
     * Returns the day of the week of the specified DateTime.
     * @param {DateTime} date A DateTime instance.
     * @returns {Number} The day of the week.
     */

  }, {
    key: 'getDayOfWeek',
    value: function getDayOfWeek(date) {
      return date._date.getDay();
    }

    /**
     * Returns the beginning of the week of the specified DateTime.
     * @param {DateTime} date A DateTime instance.
     * @param {Object} [formatInfo] The formatInfo object.
     * @returns {DateTime} A DateTime instance specifying the beginning of the week.
     */

  }, {
    key: 'getWeekFirstDate',
    value: function getWeekFirstDate(date, formatInfo) {
      var t = date.clone();
      var firstDay = 1;
      if (formatInfo) firstDay = +formatInfo.firstDayOfWeek;
      while (t.dayOfWeek !== firstDay) {
        t = t.addDays(-1);
      }return t;
    }

    /**
     * Returns the number of milliseconds between two DateTime instances.
     * @param {DateTime} date1 A DateTime instance.
     * @param {DateTime} date2 A DateTime instance.
     * @returns {Number} The number of milliseconds.
     */

  }, {
    key: 'millisecondsBetween',
    value: function millisecondsBetween(date1, date2) {
      var diff = date1.valueOf() - date2.valueOf();
      var f = date1._date.getTimezoneOffset() - date2._date.getTimezoneOffset();
      return diff - f * DateTime.MillisPerMinute;
    }

    /**
     * Returns the number of seconds between two DateTime instances.
     * @param {DateTime} date1 A DateTime instance.
     * @param {DateTime} date2 A DateTime instance.
     * @returns {Number} The number of seconds.
     */

  }, {
    key: 'secondsBetween',
    value: function secondsBetween(date1, date2) {
      var diff = date2.valueOf() - date1.valueOf();
      var result = DateTime.intDivision(diff, DateTime.MillisPerSecond);
      var dstDiff = date1._date.getTimezoneOffset() - date2._date.getTimezoneOffset();
      result += dstDiff * 60;
      return result;
    }

    /**
     * Returns the number of minutes between two DateTime instances.
     * @param {DateTime} date1 A DateTime instance.
     * @param {DateTime} date2 A DateTime instance.
     * @returns {Number} The number of minutes.
     */

  }, {
    key: 'minutesBetween',
    value: function minutesBetween(date1, date2) {
      var diff = date2.valueOf() - date1.valueOf();
      var result = DateTime.intDivision(diff, DateTime.MillisPerMinute);
      var dstDiff = date1._date.getTimezoneOffset() - date2._date.getTimezoneOffset();
      result += dstDiff;
      return result;
    }

    /**
     * Returns the number of hours between two DateTime instances.
     * @param {DateTime} date1 A DateTime instance.
     * @param {DateTime} date2 A DateTime instance.
     * @returns {Number} The number of hours.
     */

  }, {
    key: 'hoursBetween',
    value: function hoursBetween(date1, date2) {
      var st = new Date(date1._date.getTime());
      var et = new Date(date2._date.getTime());
      var d = DateTime.intDivision(et - st, 3600000);

      var dstDiff = date1._date.getTimezoneOffset() - date2._date.getTimezoneOffset();
      d += dstDiff / 60;

      return d;
    }

    /**
     * Returns the number of days between two DateTime instances.
     * @param {DateTime} date1 A DateTime instance.
     * @param {DateTime} date2 A DateTime instance.
     * @returns {Number} The number of days.
     */

  }, {
    key: 'daysBetween',
    value: function daysBetween(date1, date2) {
      var st = new Date(date1._date.getTime());
      var d = 0;
      while (st < date2._date) {
        st.setDate(st.getDate() + 1);
        d += 1;
      }
      return d;
    }

    /**
     * Returns the number of weeks between two DateTime instances.
     * @param {DateTime} date1 A DateTime instance.
     * @param {DateTime} date2 A DateTime instance.
     * @returns {Number} The number of weeks.
     */

  }, {
    key: 'weeksBetween',
    value: function weeksBetween(date1, date2) {
      var st = new Date(date1._date.getTime());
      var d = 0;
      while (st < date2._date) {
        if (st.getDay() == date2.__getDay()) d += 1;
        st.setDate(st.getDate() + 1);
      }
      return d;
    }

    /**
     * Returns the number of months between two DateTime instances.
     * @param {DateTime} date1 A DateTime instance.
     * @param {DateTime} date2 A DateTime instance.
     * @returns {Number} The number of months.
     */

  }, {
    key: 'monthsBetween',
    value: function monthsBetween(date1, date2) {
      var st = new Date(date1._date.getTime());
      var d = 0;
      while (st < date2._date) {
        st.setMonth(st.getMonth() + 1);
        d += 1;
      }
      return d;
    }

    /**
     * Returns the number of years between two DateTime instances.
     * @param {DateTime} date1 A DateTime instance.
     * @param {DateTime} date2 A DateTime instance.
     * @returns {Number} The number of years.
     */

  }, {
    key: 'yearsBetween',
    value: function yearsBetween(date1, date2) {
      var st = new Date(date1._date.getTime());
      var d = 0;
      while (st < date2._date) {
        st.setFullYear(st.getFullYear() + 1);
        d += 1;
      }
      return d;
    }

    /**
     * Adds the specified number of milliseconds to the specified DateTime object.
     * @param {DateTime} date The DateTime instance to modify.
     * @param {Number} milliseconds The number of milliseconds to add.
     * @returns {DateTime} The modified DateTime instance.
     */

  }, {
    key: 'addMilliseconds',
    value: function addMilliseconds(date, milliseconds) {
      var result = new DateTime(new Date(date.valueOf())).addMilliseconds(milliseconds);
      return result;
    }

    /**
     * Adds the specified number of seconds to the specified DateTime object.
     * @param {DateTime} date The DateTime instance to modify.
     * @param {Number} seconds The number of seconds to add.
     * @returns {DateTime} The modified DateTime instance.
     */

  }, {
    key: 'addSeconds',
    value: function addSeconds(date, seconds) {
      var result = new DateTime(new Date(date.valueOf())).addSeconds(seconds);
      return result;
    }

    /**
     * Adds the specified number of minutes to the specified DateTime object.
     * @param {DateTime} date The DateTime instance to modify.
     * @param {Number} minutes The number of minutes to add.
     * @returns {DateTime} The modified DateTime instance.
     */

  }, {
    key: 'addMinutes',
    value: function addMinutes(date, minutes) {
      var result = new DateTime(new Date(date.valueOf())).addMinutes(minutes);
      return result;
    }

    /**
     * Adds the specified number of hours to the specified DateTime object.
     * @param {DateTime} date The DateTime instance to modify.
     * @param {Number} hours The number of hours to add.
     * @returns {DateTime} The modified DateTime instance.
     */

  }, {
    key: 'addHours',
    value: function addHours(date, hours) {
      var result = new DateTime(new Date(date.valueOf())).addHours(hours);
      return result;
    }

    /**
     * Adds the specified number of days to the specified DateTime object.
     * @param {DateTime} date The DateTime instance to modify.
     * @param {Number} days The number of days to add.
     * @returns {DateTime} The modified DateTime instance.
     */

  }, {
    key: 'addDays',
    value: function addDays(date, days) {
      var result = new DateTime(new Date(date.valueOf())).addDays(days);
      return result;
    }

    /**
     * Adds the specified number of months to the specified DateTime object.
     * @param {DateTime} date The DateTime instance to modify.
     * @param {Number} months The number of months to add.
     * @returns {DateTime} The modified DateTime instance.
     */

  }, {
    key: 'addMonths',
    value: function addMonths(date, months) {
      var result = new DateTime(new Date(date.valueOf())).addMonths(months);
      return result;
    }

    /**
     * Adds the specified number of years to the specified DateTime object.
     * @param {DateTime} date The DateTime instance to modify.
     * @param {Number} years The number of years to add.
     * @returns {DateTime} The modified DateTime instance.
     */

  }, {
    key: 'addYears',
    value: function addYears(date, years) {
      var result = new DateTime(new Date(date.valueOf())).addYears(years);
      return result;
    }

    // static properties
    /**
     * The milliseconds in one second.
     */

  }, {
    key: 'formatDate',
    value: function formatDate(date, format, formatInfo) {

      function LZ(x) {
        return (x < 0 || x > 9 ? "" : "0") + x;
      }

      var dtFormat = formatInfo;
      var monthN = dtFormat.months.long.slice(0);
      var monthAbrev = dtFormat.months.short.slice(0);
      var MONTH_NAMES = (monthN + ',' + monthAbrev).split(',');
      var DAY_NAMES = (dtFormat.days.long + ',' + dtFormat.days.short).split(',');
      var amDesignator = dtFormat.dayPeriods.am;
      var pmDesignator = dtFormat.dayPeriods.pm;

      format = format + "";
      var result = "";
      var i_format = 0;
      var c = "";
      var token = "";
      var y = date.getYear() + "";
      var M = date.getMonth() + 1;
      var d = date.getDate();
      var E = date.getDay();
      var H = date.getHours();
      var m = date.getMinutes();
      var s = date.getSeconds();
      var yyyy, yy, MMM, MM, dd, hh, h, mm, ss, ampm, HH, H;
      // Convert real date parts into formatted versions
      var value = new Object();
      if (y.length < 4) {
        y = "" + (y - 0 + 1900);
      }
      value["y"] = "" + y;
      value["yyyy"] = y;
      value["yy"] = y.substring(2, 4);
      value["M"] = M;
      value["MM"] = LZ(M);
      value["MMMM"] = MONTH_NAMES[M - 1];
      value["MMM"] = MONTH_NAMES[M + 11];
      value["d"] = d;
      value["dd"] = LZ(d);
      value["ddd"] = DAY_NAMES[E + 7];
      value["dddd"] = DAY_NAMES[E];
      value["H"] = H;
      value["HH"] = LZ(H);
      if (H == 0) {
        value["h"] = 12;
      } else if (H > 12) {
        value["h"] = H - 12;
      } else {
        value["h"] = H;
      }
      value["hh"] = LZ(value["h"]);
      if (H > 11) {
        value["K"] = H - 12;
      } else {
        value["K"] = H;
      }
      value["k"] = H + 1;
      value["KK"] = LZ(value["K"]);
      value["kk"] = LZ(value["k"]);
      if (H > 11) {
        value["tt"] = "PM";
      } else {
        value["tt"] = "AM";
      }
      value["m"] = m;
      value["mm"] = LZ(m);
      value["s"] = s;
      value["ss"] = LZ(s);

      while (i_format < format.length) {
        c = format.charAt(i_format);
        token = "";
        while (format.charAt(i_format) == c && i_format < format.length) {
          token += format.charAt(i_format++);
        }
        if (value[token] != null) {
          result = result + value[token];
        } else {
          result = result + token;
        }
      }
      return result;
    }

    /** 
    * @remarks This function matches a date string with a format string.
    * If the date string matches the format string, it returns the 
    * getTime() of the date. If it does not match, it returns 0.
    * @private
    */

  }, {
    key: 'getDateToFormat',
    value: function getDateToFormat(dateValue, format, formatInfo) {

      var _getInt = function _getInt(str, i, minlength, maxlength) {
        var _isInteger = function _isInteger(val) {
          var digits = '1234567890';
          for (var _i = 0; _i < val.length; _i += 1) {
            if (digits.indexOf(val.charAt(_i)) == -1) {
              return false;
            }
          }return true;
        };

        for (var _x = maxlength; _x >= minlength; _x -= 1) {
          var _token = str.substring(i, i + _x);
          if (_token.length < minlength) {
            return null;
          }
          if (_isInteger(_token)) {
            return _token;
          }
        }return null;
      };

      var dtFormat = formatInfo;
      var monthN = dtFormat.months.long.slice(0);
      var monthAbrev = dtFormat.months.short.slice(0);

      var MONTH_NAMES = (monthN + ',' + monthAbrev).split(',');
      var DAY_NAMES = (dtFormat.days.long + ',' + dtFormat.days.short).split(',');
      var amDesignator = dtFormat.dayPeriods.am;
      var pmDesignator = dtFormat.dayPeriods.pm;

      dateValue = dateValue + '';
      format = format + '';
      var i_val = 0;
      var i_format = 0;
      var c = '';
      var token = '';
      var x;
      var y;
      var now = new Date();
      var year = now.getFullYear();
      var month = now.getMonth() + 1;
      var date = 1;
      var hh = now.getHours();
      var mm = now.getMinutes();
      var ss = now.getSeconds();
      var ampm = '';

      while (i_format < format.length) {
        // Get next token from format string
        c = format.charCodeAt(i_format);
        token = '';
        // parse string literals between ''
        if (c === 39) {
          while (format.charCodeAt(++i_format) !== 39 && i_format < format.length) {
            token += format.charAt(i_format);
          }
        } else {
          while (format.charCodeAt(i_format) == c && i_format < format.length) {
            token += format.charAt(i_format++);
          }
        }
        //  while ((format.charAt(i_format) == c) && (i_format < format.length)) {
        //     token += format.charAt(i_format++);
        // }
        // Extract contents of value based on format token
        if (token === 'yyyy' || token === 'yy' || token === 'y') {
          if (token === 'yyyy') {
            x = 4;y = 4;
          }
          if (token === 'yy') {
            x = 2;y = 2;
          }
          if (token === 'y') {
            x = 2;y = 4;
          }
          year = _getInt(dateValue, i_val, x, y);
          if (year == null) {
            return 0;
          }
          i_val += year.length;
          if (year.length === 2) {
            if (year > 70) {
              year = 1900 + (year - 0);
            } else {
              year = 2000 + (year - 0);
            }
          }
        } else if (token === 'MMM' || token === 'NNN') {
          month = 0;
          for (var i = 0; i < MONTH_NAMES.length; i++) {
            var month_name = MONTH_NAMES[i];
            if (dateValue.substring(i_val, i_val + month_name.length).toLowerCase() == month_name.toLowerCase()) {
              if (token === 'MMM' || token === 'NNN' && i > 11) {
                month = i + 1;
                if (month > 12) {
                  month -= 12;
                }
                i_val += month_name.length;
                break;
              }
            }
          }
          if (month < 1 || month > 12) {
            return 0;
          }
        } else if (token === 'EE' || token === 'E') {
          for (var _i2 = 0; _i2 < DAY_NAMES.length; _i2++) {
            var day_name = DAY_NAMES[_i2];
            if (dateValue.substring(i_val, i_val + day_name.length).toLowerCase() == day_name.toLowerCase()) {
              i_val += day_name.length;
              break;
            }
          }
        } else if (token === 'MM' || token === 'M') {
          month = _getInt(dateValue, i_val, token.length, 2);
          if (month == null || month < 1 || month > 12) {
            return 0;
          }
          i_val += month.length;
        } else if (token === 'dd' || token === 'd') {
          date = _getInt(dateValue, i_val, token.length, 2);
          if (date == null || date < 1 || date > 31) {
            return 0;
          }
          i_val += date.length;
        } else if (token === 'hh' || token === 'h') {
          hh = _getInt(dateValue, i_val, token.length, 2);
          if (hh == null || hh < 1 || hh > 12) {
            return 0;
          }
          i_val += hh.length;
        } else if (token === 'HH' || token === 'H') {
          hh = _getInt(dateValue, i_val, token.length, 2);
          if (hh == null || hh < 0 || hh > 23) {
            return 0;
          }
          i_val += hh.length;
        } else if (token === 'KK' || token === 'K') {
          hh = _getInt(dateValue, i_val, token.length, 2);
          if (hh == null || hh < 0 || hh > 11) {
            return 0;
          }
          i_val += hh.length;
        } else if (token === 'kk' || token === 'k') {
          hh = _getInt(dateValue, i_val, token.length, 2);
          if (hh == null || hh < 1 || hh > 24) {
            return 0;
          }
          i_val += hh.length;hh--;
        } else if (token === 'mm' || token === 'm') {
          mm = _getInt(dateValue, i_val, token.length, 2);
          if (mm == null || mm < 0 || mm > 59) {
            return 0;
          }
          i_val += mm.length;
        } else if (token === 'ss' || token === 's') {
          ss = _getInt(dateValue, i_val, token.length, 2);
          if (ss == null || ss < 0 || ss > 59) {
            return 0;
          }
          i_val += ss.length;
        } else if (token === 'tt') {
          var amLen = amDesignator.length;
          var pmLen = pmDesignator.length;
          if (pmLen !== 0 || amLen !== 0) {
            if (dateValue.substring(i_val, i_val + amLen) === amDesignator) {
              ampm = 'AM';i_val += amLen - 2;
            } else if (dateValue.substring(i_val, i_val + pmLen) === pmDesignator) {
              ampm = 'PM';i_val += pmLen - 2;
            } else {
              return 0;
            }
            i_val += 2;
          }
        } else if (token == 't') {
          if (amDesignator !== '' || pmDesignator !== '') {
            if (dateValue.substring(i_val, i_val + 1) === amDesignator.substring(0, 1)) {
              ampm = 'AM';
            } else if (dateValue.substring(i_val, i_val + 1) === pmDesignator.substring(0, 1)) {
              ampm = 'PM';
            } else {
              return 0;
            }
            i_val += 1;
          }
        } else {
          if (dateValue.substring(i_val, i_val + token.length) != token) {
            return 0;
          } else {
            i_val += token.length;
          }
        }
      }
      // If there are any trailing characters left in the value, it doesn't match
      if (i_val != dateValue.length) {
        return 0;
      }
      // Is date valid for month?
      if (month == 2) {
        // Check for leap year
        if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) {
          // leap year
          if (date > 29) {
            return 0;
          }
        } else {
          if (date > 28) {
            return 0;
          }
        }
      }
      if (month == 4 || month == 6 || month == 9 || month == 11) {
        if (date > 30) {
          return 0;
        }
      }
      // Correct hours value
      if (hh < 12 && ampm == 'PM') {
        hh = hh - 0 + 12;
      } else if (hh > 11 && ampm == 'AM') {
        hh -= 12;
      }
      var newdate = new Date(year, month - 1, date, hh, mm, ss);
      return newdate.getTime();
    }

    /** 
    * For internal use only.
    * @private
    */

  }, {
    key: 'getDate',
    value: function getDate(dateValue) {
      return new Date(dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate());
    }

    /**
    * For internal use only.
    * @private
    */

  }, {
    key: 'getTimeOfDay',
    value: function getTimeOfDay(dateValue) {
      return DateTime.subtract(dateValue, DateTime.getDate(dateValue));
    }

    /** 
     * For internal use only.
     * @private
     * used in resource and list views
     */

  }, {
    key: 'setTimeOfSecond',
    value: function setTimeOfSecond(timeValue, dateValue) {
      var date = new DateTime(dateValue._date);
      date._date.setMilliseconds(timeValue._date.getMilliseconds());
      return date;
    }

    /** 
     * For internal use only.
     * @private
     * used in resource and list views
     */

  }, {
    key: 'setTimeOfMinute',
    value: function setTimeOfMinute(timeValue, dateValue) {
      var date = new DateTime(dateValue._date);
      date._date.setSeconds(timeValue._date.getSeconds());
      date._date.setMilliseconds(timeValue._date.getMilliseconds());
      return date;
    }

    /** 
     * For internal use only.
     * @private
     */

  }, {
    key: 'setTimeOfHour',
    value: function setTimeOfHour(timeValue, dateValue) {
      var date = new DateTime(dateValue._date);
      date._date.setMinutes(timeValue._date.getMinutes());
      date._date.setSeconds(timeValue._date.getSeconds());
      date._date.setMilliseconds(timeValue._date.getMilliseconds());
      return date;
    }

    /** 
     * For internal use only.
     * @private
     */

  }, {
    key: 'setTimeOfDay',
    value: function setTimeOfDay(timeValue, dateValue) {
      var date = new DateTime(dateValue._date);
      date._date.setHours(timeValue._date.getHours());
      date._date.setMinutes(timeValue._date.getMinutes());
      date._date.setSeconds(timeValue._date.getSeconds());
      date._date.setMilliseconds(timeValue._date.getMilliseconds());
      return date;
    }

    /** 
     * For internal use only.
     * @private
     */

  }, {
    key: 'setDayOfWeek',
    value: function setDayOfWeek(timeValue, dateValue) {
      var date = new DateTime(dateValue._date);
      var dayDiff = timeValue._date.getDay() - dateValue._date.getDay();

      date._date.setDate(dateValue._date.getDate() + dayDiff);
      date._date.setHours(timeValue._date.getHours());
      date._date.setMinutes(timeValue._date.getMinutes());
      date._date.setSeconds(timeValue._date.getSeconds());
      date._date.setMilliseconds(timeValue._date.getMilliseconds());
      return date;
    }

    /** 
     * For internal use only.
     * @private
     */

  }, {
    key: 'setDayOfMonth',
    value: function setDayOfMonth(timeValue, dateValue) {
      var date = new DateTime(dateValue._date);
      date._date.setDate(timeValue._date.getDate());
      date._date.setHours(timeValue._date.getHours());
      date._date.setMinutes(timeValue._date.getMinutes());
      date._date.setSeconds(timeValue._date.getSeconds());
      date._date.setMilliseconds(timeValue._date.getMilliseconds());
      return date;
    }

    /** 
     * For internal use only.
     * @private
     */

  }, {
    key: 'setDayOfYear',
    value: function setDayOfYear(timeValue, dateValue) {
      var date = new DateTime(dateValue._date);
      date._date.setMonth(timeValue._date.getMonth());
      date._date.setDate(timeValue._date.getDate());
      date._date.setHours(timeValue._date.getHours());
      date._date.setMinutes(timeValue._date.getMinutes());
      date._date.setSeconds(timeValue._date.getSeconds());
      date._date.setMilliseconds(timeValue._date.getMilliseconds());
      return date;
    }

    /** 
     * For internal use only.
     * @private
     */

  }, {
    key: 'addTicksToDate',
    value: function addTicksToDate(date, ticks) {
      if (date == null) return;
      if (date._date != null) {
        date = date._date;
      } else {
        if (date.getTime == null) date = new Date(date);
      }

      var e = date.getTimezoneOffset();
      var i = new Date(date.getTime() + ticks);
      var h = i.getTimezoneOffset() - e;
      return new DateTime(new Date(i.getTime() + h * DateTime.MillisPerMinute));
    }

    // /** 
    //  * For internal use only.
    //  * @private
    //  */
    // static millisecondsBetween(date1, date2) {
    //   const diff = date2.valueOf() - date1.valueOf();
    //   return DateTime.intDivision(diff, 1);
    // }

    /** 
     * For internal use only.
     * @private
     */

  }, {
    key: 'intDivision',
    value: function intDivision(numerator, denominator) {
      return (numerator - numerator % denominator) / denominator;
    }

    /** 
     * For internal use only.
     * @private
     */

  }, {
    key: 'addMilliseconds2',
    value: function addMilliseconds2(datetime, milliseconds) {
      var date = new Date(datetime.valueOf());
      date.setMilliseconds(date.getMilliseconds() + milliseconds);
      return date;
    }
    /** 
     * For internal use only.
     * @private
     */

  }, {
    key: 'addSeconds2',
    value: function addSeconds2(datetime, seconds) {
      var date = new Date(datetime.valueOf());
      date.setSeconds(date.getSeconds() + seconds);
      return date;
    }

    /** 
    * For internal use only.
    * @private
    */

  }, {
    key: 'addMinutes2',
    value: function addMinutes2(datetime, minutes) {
      var date = new Date(datetime.valueOf());
      date.setMinutes(date.getMinutes() + minutes);
      return date;
    }
    /** 
    * For internal use only.
    * @private
    */

  }, {
    key: 'addHours2',
    value: function addHours2(datetime, hours) {
      var date = new Date(datetime.valueOf());
      date.setHours(date.getHours() + hours);
      return date;
    }
    /** 
    * For internal use only.
    * @private
    */

  }, {
    key: 'addDays2',
    value: function addDays2(datetime, days) {
      var date = new Date(datetime.valueOf());
      date.setDate(date.getDate() + days);
      return date;
    }
    /** 
    * For internal use only.
    * @private
    */

  }, {
    key: 'addWeeks2',
    value: function addWeeks2(datetime, weeks) {
      var date = new Date(datetime.valueOf());
      date.setDate(date.getDate() + weeks * 7);
      return date;
    }
    /** 
    * For internal use only.
    * @private
    */

  }, {
    key: 'addMonths2',
    value: function addMonths2(datetime, months) {
      var date = new Date(datetime.valueOf());
      date.setMonth(date.getMonth() + months);
      return date;
    }
    /** 
    * For internal use only.
    * @private
    */

  }, {
    key: 'addYears2',
    value: function addYears2(datetime, years) {
      var date = new Date(datetime.valueOf());
      date.setFullYear(date.getFullYear() + years);
      return date;
    }
  }, {
    key: 'isSameDate',
    value: function isSameDate(date1, date2) {
      if (date1._date.valueOf() - date2._date.valueOf() == (date1._date.getTimezoneOffset() - date2._date.getTimezoneOffset()) * 60000) return true;
      return false;
    }

    /** 
     * For internal use only.
     * @private
    * used in resource view
     */

  }, {
    key: 'getFirstDateAfter',
    value: function getFirstDateAfter(date, unit, unitCount, formatInfo) {
      var firstDayOfWeek = +formatInfo.firstDayOfWeek;
      var res;

      if (unit != TimeUnit.Week || firstDayOfWeek == DayOfWeek.Monday) res = DateTime.truncate(date, unit, unitCount);else res = DateTime.truncateWeek(date, unit, unitCount, formatInfo);

      if (res.lessThan(date)) res = DateTime.add(res, unit, unitCount); //TODO: handle MaxValue

      return res;
    }

    /** 
     * For internal use only.
     * @private
     * used in resource view
     */

  }, {
    key: 'truncate',
    value: function truncate(date, unit, unitCount) {
      var totalUnits;
      var ts = TimeSpan.fromMilliseconds(Math.abs(date._ticks - DateTime.minValue()._ticks));
      switch (unit) {
        case TimeUnit.Second:
          totalUnits = ts.seconds;break;
        case TimeUnit.Minute:
          totalUnits = ts.minutes;break;
        case TimeUnit.Hour:
          totalUnits = ts.hours;break;
        case TimeUnit.Day:
          totalUnits = ts.days;break;
        case TimeUnit.Week:
          totalUnits = ts.days / 7;break;
        case TimeUnit.Month:
          totalUnits = 12 * (date.year - 1) + date.month;break;
        case TimeUnit.Year:
          totalUnits = date.year;break;
      }

      totalUnits = Math.floor(totalUnits / unitCount) * unitCount;

      return DateTime.add(DateTime.minValue(), unit, totalUnits);
    }

    /** 
     * For internal use only.
     * @private
     * used in resource view
     */

  }, {
    key: 'truncateWeek',
    value: function truncateWeek(date, unit, unitCount, formatInfo) {
      if (unit != TimeUnit.Week) return DateTime.truncate(date, unit, unitCount);
      var totalUnits;
      var first = +formatInfo.firstDayOfWeek;
      var d;
      var diff = first - 1;
      if (diff >= 0) d = DateTime.addDays(DateTime.minValue(), diff);else d = DateTime.addDays(DateTime.minValue(), 6);

      var ts = TimeSpan.fromMilliseconds(Math.abs(date._ticks - d._ticks));
      totalUnits = ts.days / 7;

      totalUnits = Math.floor(totalUnits / unitCount) * unitCount;
      return DateTime.add(d, unit, totalUnits);
    }

    /** 
    * For internal use only.
    * @private
    * used in resource view
    */

  }, {
    key: 'add',
    value: function add(time, change) {
      var res;
      if (time - DateTime.minValue() < -change) res = DateTime.minValue();else if (DateTime.maxValue - time < change) res = DateTime.maxValue;else res = time + change;
      return res;
    }

    /** 
    * For internal use only.
    * @private
    * used in resource view
    */

  }, {
    key: 'add',
    value: function add(date, unit, unitCount) {
      switch (unit) {
        case TimeUnit.Second:
          return DateTime.addSeconds(date, unitCount);
        case TimeUnit.Minute:
          return DateTime.addMinutes(date, unitCount);
        case TimeUnit.Hour:
          return DateTime.addHours(date, unitCount);
        case TimeUnit.Unspecified:
        case TimeUnit.Day:
          return DateTime.addDays(date, unitCount);
        case TimeUnit.Week:
          return DateTime.addDays(date, 7 * unitCount);
        case TimeUnit.Month:
          return DateTime.addMonths(date, unitCount);
        case TimeUnit.Year:
          return DateTime.addYears(date, unitCount);
        default:
          return unitCount > 0 ? DateTime.maxValue() : DateTime.minValue();
      }
    }

    /** 
    * For internal use only.
    * @private
    * used in resource view
    */

  }, {
    key: 'getNextDate',
    value: function getNextDate(date, unit, unitCount) {
      return DateTime.add(date, unit, unitCount);
    }

    /** 
    * For internal use only.
    * @private
    * used in resource view
    */

  }, {
    key: 'getPreviousDate',
    value: function getPreviousDate(date, unit, unitCount) {
      return DateTime.add(date, unit, -unitCount);
    }

    /** 
    * For internal use only.
    * @private
    * used in resource view
    */

  }, {
    key: 'isTimeSpanShorter',
    value: function isTimeSpanShorter(date, unit, unitCount, formatInfo) {
      var after = DateTime.getFirstDateAfter(date, unit, unitCount, formatInfo);
      var prev = DateTime.getPreviousDate(date, unit, unitCount);
      return date != after && date != prev;
    }
  }, {
    key: 'MillisPerSecond',
    get: function get$$1() {
      return 1000;
    }

    /**
     * The milliseconds in one minute.
     */

  }, {
    key: 'MillisPerMinute',
    get: function get$$1() {
      return 60 * DateTime.MillisPerSecond;
    }

    /**
     * The milliseconds in one hour.
     */

  }, {
    key: 'MillisPerHour',
    get: function get$$1() {
      return 60 * DateTime.MillisPerMinute;
    }

    /**
     * The milliseconds in one day.
     */

  }, {
    key: 'MillisPerDay',
    get: function get$$1() {
      return 24 * DateTime.MillisPerHour;
    }

    /**
     * The ticks in one millisecond.
     */

  }, {
    key: 'TicksPerMillisecond',
    get: function get$$1() {
      return 10000;
    }

    /**
     * The ticks in one second.
     */

  }, {
    key: 'TicksPerSecond',
    get: function get$$1() {
      return 10000000;
    }

    /**
     * The ticks in one minute.
     */

  }, {
    key: 'TicksPerMinute',
    get: function get$$1() {
      return 60 * DateTime.TicksPerSecond;
    }

    /**
     * The ticks in one hour.
     */

  }, {
    key: 'TicksPerHour',
    get: function get$$1() {
      return 60 * DateTime.TicksPerMinute;
    }

    /**
    * The ticks in one day.
    */

  }, {
    key: 'TicksPerDay',
    get: function get$$1() {
      return 24 * DateTime.TicksPerHour;
    }
  }]);
  return DateTime;
}();

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
 * Generates unique ids.
 */
var IdGenerator = function () {
  function IdGenerator() {
    classCallCheck(this, IdGenerator);
  }

  createClass(IdGenerator, null, [{
    key: 'generate',

    /**
     * Generates a new id that starts with the specified prefix.
     * @param {String} prefix A prefix to insert at the beginning of the identifier.
     * @returns A string containing the generated identifier.
     */
    value: function generate(prefix) {
      var result, i, j;
      result = '';
      for (j = 0; j < 32; j++) {
        if (j == 8 || j == 12 || j == 16 || j == 20) result = result + '-';
        i = Math.floor(Math.random() * 16).toString(16).toLowerCase();
        result = result + i;
      }
      this._guid = prefix + result;
      return this._guid;
    }
  }]);
  return IdGenerator;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * @class Represents an array of arbitrary objects.
 */
var IEnumerable = function () {

    /**
     * Initializes a new instance of the IEnumerable class.
     * @constructor
     * @param {Array} [items] The underlying array data structure of the collection.
    */
    function IEnumerable(items) {
        classCallCheck(this, IEnumerable);

        this._items = items == undefined ? [] : items;
    }

    /**
     * Gets the collection as an array.
    * @returns {Array} The underlying array data structure of the collection.
    */


    createClass(IEnumerable, [{
        key: "items",
        value: function items() {
            return this._items;
        }

        /**
        * Gets the collection as an array in reverse order.
        * @returns {Array} The underlying array data structure of the collection in reverse order.
        */

    }, {
        key: "reverse",
        value: function reverse() {
            return this._items.reverse();
        }

        /**
        * Gets the element at the given index.
        * @param {Number} index The index.
        * @returns {Object} The element at the given index.
        */

    }, {
        key: "item",
        value: function item(index) {
            return this._items[index];
        }

        /**
        * Gets the number of elements.
        * @returns {Number} The number of elements.
        */

    }, {
        key: "count",
        value: function count() {
            return this._items.length;
        }

        /**
        * Checks if the given element is present in the collection.
        * @param {Object} item The object to check for.
        * @returns {Boolean} True if the element is found, otherwise false.
        */

    }, {
        key: "contains",
        value: function contains(item) {
            return this._items.indexOf(item) > -1;
        }

        /**
        * Adds an object to the end of the collection.
        * @param {Object} item The object to add.
        */

    }, {
        key: "add",
        value: function add(item) {
            this._items.push(item);
        }

        /**
        * Adds a range of elements to the end of the collection.
        * @param {Array} range The range to add.
        */

    }, {
        key: "addRange",
        value: function addRange(range) {
            for (var i = 0; i < range.length; i++) {
                this._items.push(range[i]);
            }
        }

        /**
        * Removes an element from the collection.
        * @param {Object} item The object to remove.
        */

    }, {
        key: "remove",
        value: function remove(item) {
            var index = this._items.indexOf(item);
            if (index > -1) this._items.splice(index, 1);
        }

        /**
        * Removes a range of elements starting from the given index.
        * @param {Number} index The starting index of the range.
        * @param {Number} count The length of the range.
        */

    }, {
        key: "removeRange",
        value: function removeRange(index, count) {
            return this._items.splice(index, count);
        }

        /**
        * Removes the element at the given index.
        * @param {Number} index The index.
        */

    }, {
        key: "removeAt",
        value: function removeAt(itemIndex) {
            this._items.splice(itemIndex, 1);
        }

        /**
        * Clears the collection.
        */

    }, {
        key: "clear",
        value: function clear() {
            this._items = [];
        }

        /**
        * Creates a copy of the collection.
        * @returns {IEnumerable} A copy of this collection.
        */

    }, {
        key: "clone",
        value: function clone() {
            var result = new IEnumerable();
            result._items = this._items.slice();
            return result;
        }

        /**
        * Copies a range of elements from this collection to a destination collection.
        * @param {IEnumerable} destination The destination collection.
        * @param {Number} length The length of the range to copy.
        * @param {Number} [sourceIndex] The starting index of the range to copy.
        * @param {Number} [destinationIndex] The index at which the range should be copied.
        */

    }, {
        key: "copyTo",
        value: function copyTo(destination, length, sourceIndex, destinationIndex) {
            var l = length == undefined ? this._items.length : length;
            var s = sourceIndex == undefined ? 0 : sourceIndex;
            var d = destinationIndex == undefined ? 0 : destinationIndex;

            for (var i = s; i < l; i++) {
                destination._items[d + i] = this._items[i];
            }
        }

        /**
        * Sorts the underlying array.
        * @param {Function} [compareFn] The comparing function.
        */

    }, {
        key: "sort",
        value: function sort(compareFn) {
            this._items.sort(compareFn);
        }

        /**
        * Gets the index of a given object in a collection.
        * @param {Object} obj The object to look for.
        * @param {Number} [fromIndex] The starting index to search from.
        * @returns {Number} The index of the object, or -1 if the object is not present in the collection.
        */

    }, {
        key: "indexOfItem",
        value: function indexOfItem(obj, fromIndex) {
            if (fromIndex == null) {
                fromIndex = 0;
            } else if (fromIndex < 0) {
                fromIndex = Math.max(0, this._items.length + fromIndex);
            }
            for (var i = fromIndex, j = this._items.length; i < j; i++) {
                if (this._items[i] === obj) return i;
            }
            return -1;
        }

        /**
        * Adds an element to the collection at the specified index.
        * @param {Number} index The index.
        * @param {Object} item The object to add.
        */

    }, {
        key: "insert",
        value: function insert(index, item) {
            this._items.splice(index, 0, item);
        }

        /**
        * Returns a new Object array, containing the contents of the collection.
        * @returns {Array} The array.
        */

    }, {
        key: "toArray",
        value: function toArray$$1() {
            return this._items.slice(0);
        }

        /**
        * Invokes a transform function on each item and returns the maximum value in a sequence of numbers.
        * @param {Function} selector A transform function to invoke on each element.
        * @returns {Number} The maximum number in the sequence.
        */

    }, {
        key: "max",
        value: function max(selector) {
            if (this.count() == 0) return null;
            var max = Number.NEGATIVE_INFINITY;
            for (var i = 0; i < this.count(); i++) {
                var current = selector(this.item(i));
                max = Math.max(max, current);
            }
            return max;
        }

        /**
        * Invokes a transform function on each item and returns the
        * minimum value in a sequence of numbers.
        * @param {Function} selector A transform function to invoke on each element.
        * @returns {Number} The minimum number in the sequence.
        */

    }, {
        key: "min",
        value: function min(selector) {
            if (this.count() == 0) return null;
            var min = Number.POSITIVE_INFINITY;
            for (var i = 0; i < this.count(); i++) {
                var current = selector(this.item(i));
                min = Math.min(min, current);
            }
            return min;
        }

        /**
        * Computes the sum of the sequence of number values that are obtained by invoking a transform function on each element.
        * @param {Function} selector A transform function to invoke on each element.
        * @returns {Number} The sum of the number values in the sequence.
        */

    }, {
        key: "sum",
        value: function sum(selector) {
            var sum = 0;
            for (var i = 0; i < this.count(); i++) {
                sum += selector(this.item(i));
            }return sum;
        }

        /**
        * Projects each element of a sequence into a new form.
        * @param {Function} selector A transform function to invoke on each element.
        * @returns {IEnumerable} An collection whose elements are the result
        * of invoking the transform function on each element.
        */

    }, {
        key: "select",
        value: function select(selector) {
            var result = new IEnumerable();
            for (var i = 0; i < this.count(); i++) {
                var tResult = selector(this.item(i));
                result.add(tResult);
            }
            return result;
        }

        /**
        * Filters a sequence of values based on a predicate.
        * @param {Function} selector A function to test each element for a condition.
        * @returns {IEnumerable} An collection that contains elements from the input sequence that satisfy the condition.
        */

    }, {
        key: "where",
        value: function where(selector) {
            var result = new IEnumerable();
            for (var i = 0; i < this.count(); i++) {
                var tResult = selector(this.item(i));
                if (tResult) result.add(this.item(i));
            }
            return result;
        }

        /**
        * Executes a provided function once for each element.
        * @param {Function} callback A function to execute for each element.
        * @param {Object} context The invokation context.
        */

    }, {
        key: "forEach",
        value: function forEach(callback, context) {
            var l = this.count();
            for (var i = 0; i < l; i++) {
                callback.call(context, this.items()[i], i, this);
            }
        }
    }, {
        key: "intersects",
        value: function intersects(list) {
            var result = new IEnumerable();
            for (var element in list) {
                if (this.contains(element)) result.add(element);
            }return result;
        }
    }]);
    return IEnumerable;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * @class Represents an array of arbitrary objects.
 * @augments IEnumerable
 */
var List = function (_IEnumerable) {
    inherits(List, _IEnumerable);

    /**
     * Initializes a new instance of the List class.
     * @constructor
     * @param {Array} [items] The underlying array data structure of the list.
     */
    function List(items) {
        classCallCheck(this, List);
        return possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, items));
    }

    return List;
}(IEnumerable);

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2015-2016, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/** 
* @class Specifies the type of the collection changed action.
*/
var NotifyCollectionChangedAction = {
  Add: 1,
  Remove: -1,
  Reset: 0

  /** 
  * @class The base type of classes that define arguments passed to event handler functions.
  */
};var EventArgs =

/** Initializes a new instance of the EventArgs class. */
function EventArgs() {
  classCallCheck(this, EventArgs);
};

/**
* @class Provides a value to use with events that do not have event data.
* @augments EventArgs
*/
var EmptyEventArgs = function (_EventArgs) {
  inherits(EmptyEventArgs, _EventArgs);

  /** Initializes a new instance of the EmptyEventArgs class. */
  function EmptyEventArgs() {
    classCallCheck(this, EmptyEventArgs);
    return possibleConstructorReturn(this, (EmptyEventArgs.__proto__ || Object.getPrototypeOf(EmptyEventArgs)).call(this));
  }

  return EmptyEventArgs;
}(EventArgs);

/**
* @class Provides a value to use with cancellable events.
* @augments EventArgs
*/
var CancelEventArgs = function (_EventArgs2) {
  inherits(CancelEventArgs, _EventArgs2);

  /** Initializes a new instance of the CancelEventArgs class. */
  function CancelEventArgs() {
    classCallCheck(this, CancelEventArgs);

    var _this2 = possibleConstructorReturn(this, (CancelEventArgs.__proto__ || Object.getPrototypeOf(CancelEventArgs)).call(this));

    _this2.m_cancel = false;
    return _this2;
  }

  /**
  * Gets a value indicating whether to allow the current operation.
  * @returns {Boolean} true to cancel the operation; otherwise, false.
  */


  createClass(CancelEventArgs, [{
    key: "cancel",
    get: function get$$1() {
      return this.m_cancel;
    }

    /**
    * Sets a value indicating whether to allow the current operation.
    * @param {Boolean} value true to cancel the operation; otherwise, false.
    */
    ,
    set: function set$$1(value) {
      this.m_cancel = value;
    }
  }]);
  return CancelEventArgs;
}(EventArgs);

/**
* @class Provides data for PropertyChanged events.
* @augments EventArgs
*/
var PropertyChangedEventArgs = function (_EventArgs3) {
  inherits(PropertyChangedEventArgs, _EventArgs3);

  /** Initializes a new instance of the PropertyChangedEventArgs class. */
  function PropertyChangedEventArgs(propertyName) {
    classCallCheck(this, PropertyChangedEventArgs);

    var _this3 = possibleConstructorReturn(this, (PropertyChangedEventArgs.__proto__ || Object.getPrototypeOf(PropertyChangedEventArgs)).call(this));

    _this3.m_propertyName = propertyName;
    return _this3;
  }

  /**
  * Gets the name of the property that changed.
  * @returns {string} The name of the property.
  */


  createClass(PropertyChangedEventArgs, [{
    key: "propertyName",
    get: function get$$1() {
      return this.m_propertyName;
    }
  }]);
  return PropertyChangedEventArgs;
}(EventArgs);
/**
* @class Provides data for CollectionChanged events.
* @augments EventArgs
*/
var NotifyCollectionChangedEventArgs = function (_EventArgs4) {
  inherits(NotifyCollectionChangedEventArgs, _EventArgs4);

  /**
  * Initializes a new instance of the NotifyCollectionChangedEventArgs class.
  * @param {NotifyCollectionChangedAction} action The action that caused the event.
  * @param {Array} [changes] The items affected by the change.
  * @param {Number} [index] The index where the change occurred.
  */
  function NotifyCollectionChangedEventArgs(action, changes, index) {
    classCallCheck(this, NotifyCollectionChangedEventArgs);

    var _this4 = possibleConstructorReturn(this, (NotifyCollectionChangedEventArgs.__proto__ || Object.getPrototypeOf(NotifyCollectionChangedEventArgs)).call(this));

    _this4.m_action = action;

    if (changes === null && index === null && action !== NotifyCollectionChangedAction.Reset) throw new Error();

    if (action === NotifyCollectionChangedAction.Add) {
      _this4.m_newItems = changes;
    } else if (action === NotifyCollectionChangedAction.Remove) {
      _this4.m_oldItems = changes;
    }
    return _this4;
  }
  /**
  * Gets the action that caused the vent.
  * @returns {NotifyCollectionChangedAction} The action that caused the event.
  */


  createClass(NotifyCollectionChangedEventArgs, [{
    key: "action",
    get: function get$$1() {
      return this.m_action;
    }
    /**
    * Gets a list of the items affected by a Remove action.
    * @returns {Array} The list of affected items.
    */

  }, {
    key: "oldItems",
    get: function get$$1() {
      return this.m_oldItems;
    }
    /**
    * Gets the list of new items involved in the change.
    * @returns {Array} The list of involed items.
    */

  }, {
    key: "newItems",
    get: function get$$1() {
      return this.m_newItems;
    }
  }]);
  return NotifyCollectionChangedEventArgs;
}(EventArgs);

/**
* @class Provides data for CollectionChanging events.
* @augments CancelEventArgs
*/
var NotifyCollectionChangingEventArgs = function (_CancelEventArgs) {
  inherits(NotifyCollectionChangingEventArgs, _CancelEventArgs);

  /**
  * Initializes a new instance of the NotifyCollectionChangingEventArgs class.
  * @param {NotifyCollectionChangedAction} action The action that caused the event.
  * @param {Array} [changes] The items affected by the change.
  * @param {Number} [index] The index where the change occurred.
  */
  function NotifyCollectionChangingEventArgs(action, changes, index) {
    classCallCheck(this, NotifyCollectionChangingEventArgs);

    var _this5 = possibleConstructorReturn(this, (NotifyCollectionChangingEventArgs.__proto__ || Object.getPrototypeOf(NotifyCollectionChangingEventArgs)).call(this));

    _this5.m_action = action;

    if (changes === null && index === null && action !== NotifyCollectionChangedAction.Reset) throw new Error();

    if (action === NotifyCollectionChangedAction.Add) {
      _this5.m_newItems = changes;
    } else if (action === NotifyCollectionChangedAction.Remove) {
      _this5.m_oldItems = changes;
    }
    return _this5;
  }
  /**
  * Gets the action that caused the event.
  * @returns {NotifyCollectionChangedAction} The action that caused the event.
  */


  createClass(NotifyCollectionChangingEventArgs, [{
    key: "action",
    get: function get$$1() {
      return this.m_action;
    }
    /**
    * Gets a list of the items affected by a Remove action.
    * @returns {Array} The list of affected items.
    */

  }, {
    key: "oldItems",
    get: function get$$1() {
      return this.m_oldItems;
    }
    /**
    * Gets the list of new items involved in the change.
    * @returns {Array} The list of involed items.
    */

  }, {
    key: "newItems",
    get: function get$$1() {
      return this.m_newItems;
    }
  }]);
  return NotifyCollectionChangingEventArgs;
}(CancelEventArgs);

/**
* @class Provides data for PropertyValueChanged events.
* @augments EventArgs
*/
var PropertyEventArgs = function (_EventArgs5) {
  inherits(PropertyEventArgs, _EventArgs5);

  /**
  * Initlializes a new instance of the PropertyEventArgs class.
  * @param {String} propertyName The name of the property that changed.
  * @param {Object} oldValue The old value of the property.
  * @param {Object} newValue The new value of the property.
  */
  function PropertyEventArgs(propertyName, oldValue, newValue) {
    classCallCheck(this, PropertyEventArgs);

    var _this6 = possibleConstructorReturn(this, (PropertyEventArgs.__proto__ || Object.getPrototypeOf(PropertyEventArgs)).call(this));

    _this6.m_propertyName = propertyName;
    _this6.m_oldValue = oldValue;
    _this6.m_newValue = newValue;
    return _this6;
  }
  /**
  * Gets the name of the property that changed.
  */


  createClass(PropertyEventArgs, [{
    key: "propertyName",
    get: function get$$1() {
      return this.m_propertyName;
    }
    /**
    * Gets the value of the property before the change.
    */

  }, {
    key: "oldValue",
    get: function get$$1() {
      return this.m_oldValue;
    }
    /**
    * Gets the current value of the property.
    */

  }, {
    key: "newValue",
    get: function get$$1() {
      return this.m_newValue;
    }
  }]);
  return PropertyEventArgs;
}(EventArgs);

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2015-2016, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* @class Represents a dispatcher for an event.
*/
var EventDispatcher = function () {
  function EventDispatcher() {
    classCallCheck(this, EventDispatcher);

    this.handlers = [];
  }

  /**
  * Subcribes an event listener to this event.
  */


  createClass(EventDispatcher, [{
    key: "addEventListener",
    value: function addEventListener(handler) {
      var index = this.handlers.indexOf(handler);
      if (index === -1) this.handlers.push(handler);
    }
    /**
    * Removes an event listener from this event.
    */

  }, {
    key: "removeEventListener",
    value: function removeEventListener(handler) {
      var index = this.handlers.indexOf(handler);
      if (index > -1) this.handlers.splice(index);
    }
    /**
    * Raises this event.
    */

  }, {
    key: "raiseEvent",
    value: function raiseEvent(sender, args) {
      this.handlers.slice(0).forEach(function (h) {
        return h(sender, args);
      });
    }
  }]);
  return EventDispatcher;
}();

/**
* @class Represents a dispatcher for PropertyChanged events.
*/
var PropertyChangedEventDispatcher = function (_EventDispatcher) {
  inherits(PropertyChangedEventDispatcher, _EventDispatcher);

  function PropertyChangedEventDispatcher() {
    classCallCheck(this, PropertyChangedEventDispatcher);
    return possibleConstructorReturn(this, (PropertyChangedEventDispatcher.__proto__ || Object.getPrototypeOf(PropertyChangedEventDispatcher)).apply(this, arguments));
  }

  return PropertyChangedEventDispatcher;
}(EventDispatcher);

/**
* @class Represents a dispatcher for NotifyCollectionChanged events.
*/
var NotifyCollectionChangedEventDispatcher = function (_EventDispatcher2) {
  inherits(NotifyCollectionChangedEventDispatcher, _EventDispatcher2);

  function NotifyCollectionChangedEventDispatcher() {
    classCallCheck(this, NotifyCollectionChangedEventDispatcher);
    return possibleConstructorReturn(this, (NotifyCollectionChangedEventDispatcher.__proto__ || Object.getPrototypeOf(NotifyCollectionChangedEventDispatcher)).apply(this, arguments));
  }

  return NotifyCollectionChangedEventDispatcher;
}(EventDispatcher);

/**
* @class Represents a dispatcher for NotifyCollectionChanging events.
*/
var NotifyCollectionChangingEventDispatcher = function (_EventDispatcher3) {
  inherits(NotifyCollectionChangingEventDispatcher, _EventDispatcher3);

  function NotifyCollectionChangingEventDispatcher() {
    classCallCheck(this, NotifyCollectionChangingEventDispatcher);
    return possibleConstructorReturn(this, (NotifyCollectionChangingEventDispatcher.__proto__ || Object.getPrototypeOf(NotifyCollectionChangingEventDispatcher)).apply(this, arguments));
  }

  return NotifyCollectionChangingEventDispatcher;
}(EventDispatcher);

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * @class Represents a collection of arbitrary objects.
 * @augments List
 * @property {NotifyCollectionChangedEventDispatcher} collectionChanged Occurs when an item is added, removed, changed, moved, or the entire list is refreshed.
 * @property {PropertyChangedEventDispatcher} propertyChanged Occurs when a property value changes.
 */
var ObservableCollection = function (_List) {
    inherits(ObservableCollection, _List);

    /**
     * Initializes a new instance of the ObservableCollection class.
     * @constructor
     * @param {Array} [items] The underlying array data structure of the collection.
     */
    function ObservableCollection(items) {
        classCallCheck(this, ObservableCollection);

        var _this = possibleConstructorReturn(this, (ObservableCollection.__proto__ || Object.getPrototypeOf(ObservableCollection)).call(this, items));

        _this.m_collectionChanged = new NotifyCollectionChangedEventDispatcher();
        _this.m_propertyChanged = new PropertyChangedEventDispatcher();
        _this.m_collectionChanging = new NotifyCollectionChangingEventDispatcher();
        return _this;
    }

    /**
    * Raises the collectionChanged event. 
    * @param {NotifyCollectionChangedEventArgs} args An instance of the NotifyCollectionChangedEventArgs class.
    */


    createClass(ObservableCollection, [{
        key: 'onCollectionChanged',
        value: function onCollectionChanged(args) {
            this.m_collectionChanged.raiseEvent(this, args);
        }

        /**
         * Occurs when an item is added, removed, changed, moved, or the entire list is refreshed.
         */

    }, {
        key: 'onPropertyChanged',


        /**
        * Raises the propertyChanged event.
        * @param {PropertyChangedEventArgs} args An instance of the PropertyChangedEventArgs class.
        */
        value: function onPropertyChanged(args) {
            this.m_propertyChanged.raiseEvent(this, args);
        }

        /**
         * Occurs when a property value changes.
         */

    }, {
        key: 'onCollectionChanging',


        /**
        * Raises the collectionChanging validation event. 
        * @param {NotifyCollectionChangingEventArgs} args An instance of the NotifyCollectionChangingEventArgs class.
        */value: function onCollectionChanging(args) {
            this.m_collectionChanging.raiseEvent(this, args);
            return args.cancel;
        }

        /**
         * Occurs just before an item is added, removed, changed, moved, or the entire list is refreshed.
         */

    }, {
        key: 'add',


        /**
         * Adds an object to the collection.
         * @param {Object} item The item to add.
         */
        value: function add(item) {
            if (this.onCollectionChanging(new NotifyCollectionChangingEventArgs(NotifyCollectionChangedAction.Add, [item], this.count()))) return;
            get(ObservableCollection.prototype.__proto__ || Object.getPrototypeOf(ObservableCollection.prototype), 'add', this).call(this, item);
            this.onCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, [item], this.count() - 1));
        }

        /**
         * Deletes an object from the collection
         * @param {TObject} item The item to remove.
         */

    }, {
        key: 'remove',
        value: function remove(item) {
            var removedItem = item;
            var itemIndex = this.indexOfItem(item);
            if (this.onCollectionChanging(new NotifyCollectionChangingEventArgs(NotifyCollectionChangedAction.Remove, [removedItem], itemIndex))) return;
            get(ObservableCollection.prototype.__proto__ || Object.getPrototypeOf(ObservableCollection.prototype), 'remove', this).call(this, item);
            this.onCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, [removedItem], itemIndex));
        }

        /**
         * Deletes a range of elements from the collection
         * @param {Number} index The starting index of the range to remove.
         * @param {Number} count The length of the range to remove.
         */

    }, {
        key: 'removeRange',
        value: function removeRange(index, count) {
            var itemsToRemove = new IEnumerable();
            get(ObservableCollection.prototype.__proto__ || Object.getPrototypeOf(ObservableCollection.prototype), 'copyTo', this).call(this, itemsToRemove, count, index);
            if (this.onCollectionChanging(new NotifyCollectionChangingEventArgs(NotifyCollectionChangedAction.Remove, itemsToRemove.toArray(), index))) return [];
            var items = get(ObservableCollection.prototype.__proto__ || Object.getPrototypeOf(ObservableCollection.prototype), 'removeRange', this).call(this, index, count);
            this.onCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, items, index));
            return items;
        }

        /**
         * Delete the element at the specified index.
         * @param {Number} itemIndex The index to remove at.
         */

    }, {
        key: 'removeAt',
        value: function removeAt(itemIndex) {
            var removedItem = this.item(itemIndex);
            if (this.onCollectionChanging(new NotifyCollectionChangingEventArgs(NotifyCollectionChangedAction.Remove, [removedItem], itemIndex))) return;
            get(ObservableCollection.prototype.__proto__ || Object.getPrototypeOf(ObservableCollection.prototype), 'removeAt', this).call(this, itemIndex);
            this.onCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, [removedItem], itemIndex));
        }

        /**
         * Clears the collection
         */

    }, {
        key: 'clear',
        value: function clear() {
            if (this.onCollectionChanging(new NotifyCollectionChangingEventArgs(NotifyCollectionChangedAction.Reset))) return;
            get(ObservableCollection.prototype.__proto__ || Object.getPrototypeOf(ObservableCollection.prototype), 'clear', this).call(this);
            this.onCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
        }
    }, {
        key: 'collectionChanged',
        get: function get$$1() {
            return this.m_collectionChanged;
        }
    }, {
        key: 'propertyChanged',
        get: function get$$1() {
            return this.m_propertyChanged;
        }
    }, {
        key: 'collectionChanging',
        get: function get$$1() {
            return this.m_collectionChanging;
        }
    }]);
    return ObservableCollection;
}(List);

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
 * @class Instances of the Resource class contain information about arbitrary resources.
 * @property {String} id Gets or sets the string identifier for this resource.
 * @property {String} name Gets or sets the name for this resource.
 * @property {Object} tag Gets or sets custom data associated with the resource.
 */
var Resource = function () {
  /**
   * Initializes a new instance of the Resource class.
   * @constructor
   */
  function Resource() {
    classCallCheck(this, Resource);

    this._id = IdGenerator.generate('RSC');
    this._name = '';
    this._tag = null;
  }

  /**
   * Gets the string identifier for this resource.
   */


  createClass(Resource, [{
    key: 'saveToXml',


    /**
        * Saves the resource content into an XML element.
        * @param {Element} element An XML DOM element that will contain the resource's data.
        * @param {XmlPersistContext} context An object providing contextual information about the serialization process and some helper serialization methods.
        */
    value: function saveToXml(element, context) {
      context.writeString(this.id, "id", element);
      context.writeString(this.name, "name", element);
      context.writeTag(this, this.tag, "tag", element);
    }
    /**
    * Loads the resource content from an XML element.
    * @param {Element} element An XML DOM element that contains the resource's serialized content.
    * @param {XmlPersistContext} context An object providing contextual information about the serialization process and some helper serialization methods.
    */

  }, {
    key: 'loadFromXml',
    value: function loadFromXml(element, context) {
      this._id = context.readString("id", element);
      this._name = context.readString("name", element);
      this._tag = context.readTag(this, "tag", element);
    }

    /**
    * Serializes this resource into a JSON string.
    * @returns {String} A string containing the resource's JSON representation.
    */

  }, {
    key: 'toJson',
    value: function toJson() {
      var json = {
        id: this.id,
        name: this.name,
        tag: this.tag || null
      };
      return json;
    }

    /**
    * Deserializes this resource from a JSON string.
    * @param {String} json A string created by the toJson method.
    */

  }, {
    key: 'fromJson',
    value: function fromJson(json) {
      this.id = json.id;
      this.name = json.name;
      this.tag = json.tag;
    }

    /**
    * @private
    */

  }, {
    key: 'equals',
    value: function equals(resource) {
      if (!resource) return false;
      return this.id === resource.id;
    }
  }, {
    key: 'id',
    get: function get$$1() {
      return this._id;
    }
    /**
     * Sets the string identifier for this resource.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._id = value;
    }

    /**
     * Gets the name of the resource.
     */

  }, {
    key: 'name',
    get: function get$$1() {
      return this._name;
    }
    /**
     * Sets the name of the resource.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._name = value;
    }

    /**
     * Gets custom data associated with the resource.
     */

  }, {
    key: 'tag',
    get: function get$$1() {
      return this._tag;
    }
    /**
     * Sets custom data associated with the resource.
     * @param {Object} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._tag = value;
    }
  }]);
  return Resource;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* @class Represents an object that holds contact data for a person.
* @augments Resource
* @property {String} firstName Gets or sets the first name of the contact.
* @property {String} middleName Gets or sets the middle name of the contact.
* @property {String} lastName Gets or sets the last name of the contact.
* @property {String} address Gets or sets the address of the contact.
* @property {String} phone Gets or sets the phone of the contact.
* @property {String} email Gets or sets the email of the contact.
*/

var Contact = function (_Resource) {
  inherits(Contact, _Resource);

  /**
   * Initializes a new instance of the Contact class.
    * @constructor
   */
  function Contact() {
    classCallCheck(this, Contact);

    var _this = possibleConstructorReturn(this, (Contact.__proto__ || Object.getPrototypeOf(Contact)).call(this));

    _this.id = IdGenerator.generate('CNT');
    /** @private {string} */
    _this._firstName = '';
    /** @private {string} */
    _this._middleName = '';
    /** @private {string} */
    _this._lastName = '';
    /** @private {string} */
    _this._address = '';
    /** @private {string} */
    _this._phone = '';
    /** @private {string} */
    _this._email = '';
    return _this;
  }

  /**
   * Gets the first name of the contact.
   */


  createClass(Contact, [{
    key: 'saveToXml',


    /**
        * Saves the contact content into an XML element.
        * @param {Element} element An XML DOM element that will contain the contact's data.
        * @param {XmlPersistContext} context An object providing contextual information about the serialization process and some helper serialization methods.
        */
    value: function saveToXml(element, context) {
      get(Contact.prototype.__proto__ || Object.getPrototypeOf(Contact.prototype), 'saveToXml', this).call(this, element, context);

      context.writeString(this.firstName, "firstname", element);
      context.writeString(this.middleName, "middlename", element);
      context.writeString(this.lastName, "lastname", element);
      context.writeString(this.address, "address", element);
      context.writeString(this.phone, "phone", element);
      context.writeString(this.email, "email", element);
    }
    /**
    * Loads the contact content from an XML element.
    * @param {Element} element An XML DOM element that contains the contact's serialized content.
    * @param {XmlPersistContext} context An object providing contextual information about the serialization process and some helper serialization methods.
    */

  }, {
    key: 'loadFromXml',
    value: function loadFromXml(element, context) {
      get(Contact.prototype.__proto__ || Object.getPrototypeOf(Contact.prototype), 'loadFromXml', this).call(this, element, context);

      this._firstName = context.readString("firstname", element);
      this._middleName = context.readString("middlename", element);
      this._lastName = context.readString("lastname", element);
      this._address = context.readString("address", element);
      this._phone = context.readString("phone", element);
      this._email = context.readString("email", element);
    }

    /**
    * Serializes this contact into a JSON string.
    * @returns {String} A string containing the contact's JSON representation.
    */

  }, {
    key: 'toJson',
    value: function toJson() {
      var json = get(Contact.prototype.__proto__ || Object.getPrototypeOf(Contact.prototype), 'toJson', this).call(this);

      json.firstName = this.firstName;
      json.middleName = this.middleName;
      json.lastName = this.lastName;
      json.address = this.address;
      json.phone = this.phone;
      json.email = this.email;

      return json;
    }

    /**
    * Deserializes this contact from a JSON string.
    * @param {String} json A string created by the toJson method.
    */

  }, {
    key: 'fromJson',
    value: function fromJson(json) {
      get(Contact.prototype.__proto__ || Object.getPrototypeOf(Contact.prototype), 'fromJson', this).call(this, json);

      this._firstName = json.firstName;
      this._middleName = json.middleName;
      this._lastName = json.lastName;
      this._address = json.address;
      this._phone = json.phone;
      this._email = json.email;
    }

    /** 
    * For internal use only.
    * @private
    */

  }, {
    key: 'toString',
    value: function toString() {
      return (this.firstName ? this.firstName + ' ' : '') + this.lastName;
    }
  }, {
    key: 'firstName',
    get: function get$$1() {
      return this._firstName;
    }
    /**
      * Sets the first name of the contact.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._firstName = value;
    }

    /**
     * Gets the middle name of the contact.
     */

  }, {
    key: 'middleName',
    get: function get$$1() {
      return this._middleName;
    }
    /**
      * Sets the middle name of the contact.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._middleName = value;
    }

    /**
     * Gets the last name of the contact.
     */

  }, {
    key: 'lastName',
    get: function get$$1() {
      return this._lastName;
    }
    /**
     * Sets the last name of the contact.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._lastName = value;
    }

    /**
     * Gets the address of the contact.
     */

  }, {
    key: 'address',
    get: function get$$1() {
      return this._address;
    }
    /**
     * Sets the address of the contact.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._address = value;
    }

    /**
     * Gets the phone of the contact.
     */

  }, {
    key: 'phone',
    get: function get$$1() {
      return this._phone;
    }
    /**
     * Sets the phone of the contact.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._phone = value;
    }

    /**
     * Gets the e-mail address of the contact.
     */

  }, {
    key: 'email',
    get: function get$$1() {
      return this._email;
    }
    /**
     * Sets the e-mail address of the contact.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._email = value;
    }
  }]);
  return Contact;
}(Resource);

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
 * @class Specifies data that identifies a location.
 * @augments Resource
 * @property {String} address Gets or sets the address of the location.
 * @property {String} country Gets or sets the country of the location.
 * @property {String} city Gets or sets the city of the location.
 * @property {String} state Gets or sets the state of the location.
 * @property {String} zipCode Gets or sets the zip code of the location.
 */
var Location = function (_Resource) {
  inherits(Location, _Resource);

  /**
   * Initializes a new instance of the Location class.
   * @constructor
   */
  function Location() {
    classCallCheck(this, Location);

    var _this = possibleConstructorReturn(this, (Location.__proto__ || Object.getPrototypeOf(Location)).call(this));

    _this.id = IdGenerator.generate('LOC');

    /** @private {string} */
    _this._address = '';
    /** @private {string} */
    _this._country = '';
    /** @private {string} */
    _this._city = '';
    /** @private {string} */
    _this._state = '';
    /** @private {string} */
    _this._zipCode = '';
    return _this;
  }

  /**
   * Gets the address of the location.
   */


  createClass(Location, [{
    key: 'toString',


    /** 
    * For internal use only.
    * @private
    */
    value: function toString() {
      return this.name;
    }

    /**
       * Saves the location content into an XML element.
       * @param {Element} element An XML DOM element that will contain the location's data.
       * @param {XmlPersistContext} context An object providing contextual information about the serialization process and some helper serialization methods.
       */

  }, {
    key: 'saveToXml',
    value: function saveToXml(element, context) {
      get(Location.prototype.__proto__ || Object.getPrototypeOf(Location.prototype), 'saveToXml', this).call(this, element, context);

      context.writeString(this.address, "address", element);
      context.writeString(this.country, "country", element);
      context.writeString(this.city, "city", element);
      context.writeString(this.state, "state", element);
      context.writeString(this.zipcode, "zipcode", element);
    }
    /**
    * Loads the location content from an XML element.
    * @param {Element} element An XML DOM element that contains the location's serialized content.
    * @param {XmlPersistContext} context An object providing contextual information about the serialization process and some helper serialization methods.
    */

  }, {
    key: 'loadFromXml',
    value: function loadFromXml(element, context) {
      get(Location.prototype.__proto__ || Object.getPrototypeOf(Location.prototype), 'loadFromXml', this).call(this, element, context);

      this._address = context.readString("address", element);
      this._country = context.readString("country", element);
      this._city = context.readString("city", element);
      this._state = context.readString("state", element);
      this._zipcode = context.readString("zipcode", element);
    }

    /**
     * Serializes this location into a JSON string.
     * @returns {String} A string containing the location's JSON representation.
     */

  }, {
    key: 'toJson',
    value: function toJson() {
      var json = get(Location.prototype.__proto__ || Object.getPrototypeOf(Location.prototype), 'toJson', this).call(this);

      json.address = this.address;
      json.country = this.country;
      json.city = this.city;
      json.state = this.state;
      json.zipcode = this.zipcode;

      return json;
    }

    /**
    * Deserializes this location from a JSON string.
    * @param {String} json A string created by the toJson method.
    */

  }, {
    key: 'fromJson',
    value: function fromJson(json) {
      get(Location.prototype.__proto__ || Object.getPrototypeOf(Location.prototype), 'fromJson', this).call(this, json);

      this._address = json.address;
      this._country = json.country;
      this._city = json.city;
      this._state = json.state;
      this._zipcode = json.zipcode;
    }
  }, {
    key: 'address',
    get: function get$$1() {
      return this._address;
    }
    /**
     * Sets the address of the location.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._address = value;
    }

    /**
     * Gets the country of this location.
     */

  }, {
    key: 'country',
    get: function get$$1() {
      return this._country;
    }
    /**
     * Sets the country of this location.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._country = value;
    }

    /**
     * Gets the city of this location.
     */

  }, {
    key: 'city',
    get: function get$$1() {
      return this._city;
    }
    /**
     * Sets the city of this location.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._city = value;
    }

    /**
     * Gets the state of this location.
     */

  }, {
    key: 'state',
    get: function get$$1() {
      return this._state;
    }
    /**
     * Sets the state of this location.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._state = value;
    }

    /**
     * Gets the zip-code of this location.
     */

  }, {
    key: 'zipCode',
    get: function get$$1() {
      return this._zipCode;
    }
    /**
     * Sets the zip-code of this location.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._zipCode = value;
    }
  }]);
  return Location;
}(Resource);

if (!String.format) {
  String.format = function (format) {
    var args = Array.prototype.slice.call(arguments, 1);
    return format.replace(/{(\d+)}/g, function (match, number) {
      return typeof args[number] !== 'undefined' ? args[number] : match;
    });
  };
}

/**
 * @class Contains DOM helper functions.
 */

var DomUtils = function () {
  function DomUtils() {
    classCallCheck(this, DomUtils);
  }

  createClass(DomUtils, null, [{
    key: 'getCursorPosition',
    value: function getCursorPosition(e, parent, scroller) {

      var parentloc = { x: 0, y: 0, width: 0, height: 0 };
      if (parent) parentloc = DomUtils.getBounds(parent);

      var a, b;
      //   var bodyScroll = DomUtils.getScrollXY();
      var bodyScroll = { scrollLeft: 0, scrollTop: 0 };
      if (scroller) {
        a = e.clientX - parentloc.x + scroller.scrollLeft + bodyScroll.scrollLeft;
        b = e.clientY - parentloc.y + scroller.scrollTop + bodyScroll.scrollTop;
      } else if (parent) {
        a = e.clientX - parentloc.x + parent.scrollLeft + bodyScroll.scrollLeft;
        b = e.clientY - parentloc.y + parent.scrollTop + bodyScroll.scrollTop;
      } else {
        a = e.clientX + bodyScroll.scrollLeft;
        b = e.clientY + bodyScroll.scrollTop;
      }
      return { x: a, y: b };
    }
  }, {
    key: 'getLocation',
    value: function getLocation(element) {
      var bounds = element.getBoundingClientRect();
      return { x: bounds.left, y: bounds.top };
    }
  }, {
    key: 'getBounds',
    value: function getBounds(element) {
      var bounds = element.getBoundingClientRect();
      return { x: bounds.left, y: bounds.top, width: bounds.width, height: bounds.height };
    }

    // helper function for calculating bounds of an element within parent

  }, {
    key: 'getRelativeBounds',
    value: function getRelativeBounds(element, parent) {
      var parentloc = DomUtils.getBounds(parent);
      var bounds = new Object();

      if (parent.style.position == 'absolute') {
        bounds.x = element.offsetLeft;
        bounds.y = element.offsetTop;
      } else {
        var pos = DomUtils.getLocation(element);
        bounds.x = pos.x - parentloc.x + parent.scrollLeft;
        bounds.y = pos.y - parentloc.y + parent.scrollTop;
      }

      var b = DomUtils.getBounds(element);
      bounds.width = b.width;
      bounds.height = b.height;
      return bounds;
    }
  }, {
    key: 'getBodySize',
    value: function getBodySize() {
      var h = 0;
      var w = 0;

      if (document.documentElement && document.documentElement.clientHeight) {
        w = document.documentElement.clientWidth;
        h = document.documentElement.clientHeight;
      } else if (document.body) {
        w = document.body.clientWidth;
        h = document.body.clientHeight;
      }
      var bounds = DomUtils.getBounds(document.body);

      return { height: h, width: w, x: bounds.x, y: bounds.y };
    }
  }, {
    key: 'getScrollXY',
    value: function getScrollXY() {
      var sl = 0;
      var st = 0;

      if (window.pageXOffset) {
        sl = window.pageXOffset;
        st = window.pageYOffset;
      } else {
        if (document.body.scrollTop != 0) st = document.body.scrollTop;else st = document.documentElement.scrollTop;
        if (document.body.scrollLeft != 0) sl = document.body.scrollLeft;else sl = document.documentElement.scrollLeft;
      }
      return { scrollLeft: sl, scrollTop: st };
    }
  }, {
    key: 'addCssClass',
    value: function addCssClass(element, className) {
      if (element && className) {
        element.classList.add(className);
      }
    }
  }, {
    key: 'removeCssClass',
    value: function removeCssClass(element, className) {
      if (element && className) {
        element.classList.remove(className);
      }
    }
  }, {
    key: 'hasCssClass',
    value: function hasCssClass(element, className) {
      if (element && className) {
        return element.classList.contains(className);
      }
    }
  }, {
    key: 'getParent',
    value: function getParent(element, className) {
      var parent = element.parentNode;
      while (parent != document.body) {
        if (parent) {
          if (parent.classList.contains(className)) return parent;else parent = parent.parentNode;
        } else return null;
      }
      return null;
    }
  }, {
    key: 'removeNode',
    value: function removeNode(element, parentElement) {
      if (element) {
        if (!element.parentNode) {
          if (parentElement) parentElement.appendChild(element);else document.body.appendChild(element);
        }
        element.parentNode.removeChild(element);
      }
    }
  }, {
    key: 'removeNodes',
    value: function removeNodes(elementList) {
      if (elementList) {
        Array.prototype.forEach.call(elementList, function (element) {
          DomUtils.removeNode(element);
        });
      }
    }
  }, {
    key: 'firstRealChild',
    value: function firstRealChild(element) {
      for (var i = 0; i < element.childNodes.length; i++) {
        if (element.childNodes[i].nodeType == 1) {
          return element.childNodes[i];
        }
      }
    }
  }, {
    key: 'isPointInBounds',
    value: function isPointInBounds(point, bounds) {
      if (point == null || bounds == null) {
        return false;
      }
      if (point.x <= bounds.x || point.x >= bounds.x + bounds.width) {
        return false;
      }
      if (point.y <= bounds.y || point.y >= bounds.y + bounds.height) {
        return false;
      }
      return true;
    }
  }, {
    key: 'getPointInBounds',
    value: function getPointInBounds(point, bounds) {
      if (point.x <= bounds.x) {
        point.x = -1;
      } else {
        point.x = point.x - bounds.x;
      }
      if (point.y <= bounds.y) {
        point.y = -1;
      } else {
        point.y = point.y - bounds.y;
      }
      return { x: point.x, y: point.y };
    }

    /* Extends obj1 with properties from obj2 */

  }, {
    key: 'extend',
    value: function extend(obj1, obj2) {
      for (var key in obj2) {
        if (obj2.hasOwnProperty(key)) {
          if (_typeof(obj1[key]) === 'object' && _typeof(obj2[key]) === 'object') {

            if (obj1[key] instanceof IEnumerable) {
              obj1[key]._items = obj2[key];
            } else {
              obj1[key] = obj2[key];
              DomUtils.extend(obj1[key], obj2[key]);
            }
          } else {
            obj1[key] = obj2[key];
          }
        }
      }
      return obj1;
    }

    /* Gets an enum value from key */

  }, {
    key: 'getKeyByValue',
    value: function getKeyByValue(obj, value) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          if (obj[prop] === value) return prop;
        }
      }
    }
  }]);
  return DomUtils;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
 * @class Represents reminders associated with schedule items.
 * @property {ReminderType} type Gets or sets the type of this reminder.
 * @property {TimeSpan} timeInterval Gets or sets how much time before the item's scheduled start time to raise the event that triggers the reminder.
 * @property {DateTime} time Gets or sets the time when the Reminder is triggered.
 * @property {String} message Gets or sets the message to display as a reminder.
 */
var Reminder = function () {
  /**
   * Initializes a new instance of the Reminder class.
    * @constructor
   */
  function Reminder(options) {
    classCallCheck(this, Reminder);

    /** @private {ReminderType} */
    this._type = ReminderType.Leading;
    /** @private {number} */
    this._timeInterval = new TimeSpan(0);
    /** @private {DateTime} */
    this._time = DateTime.minValue();
    /** @private {string} */
    this._message = '';

    this._changedEvent = new EventDispatcher();

    if (options) {
      DomUtils.extend(this, options);
    }
  }

  /**
   * Returns an exact copy of this Reminder object.
   * @returns The newly created Reminder object.
   */


  createClass(Reminder, [{
    key: 'clone',
    value: function clone() {
      var reminder = new Reminder();

      reminder._type = this._type;
      reminder._timeInterval = this._timeInterval.clone();
      reminder._time = this._time;
      reminder._message = this._message;

      return reminder;
    }

    /**
     * Raises the changed event.
     * @package
     */

  }, {
    key: 'onChanged',
    value: function onChanged() {
      this._changedEvent.raiseEvent(new EmptyEventArgs());
    }

    /**
     * Gets the type of this reminder.
     */

  }, {
    key: 'saveToXml',


    /**
        * Saves the reminder content into an XML element.
        * @param {Element} element An XML DOM element that will contain the reminder's data.
        * @param {XmlPersistContext} context An object providing contextual information about the serialization process and some helper serialization methods.
        */
    value: function saveToXml(element, context) {
      context.writeString(DomUtils.getKeyByValue(ReminderType, this.type), "type", element);
      if (this.type == ReminderType.Leading) context.writeInt(this.timeInterval.ticks, "timeInterval", element);else context.writeDateTime(this.time, "date", element);
      context.writeString(this.message, "message", element);
    }

    /**
    * Loads the reminder content from an XML element.
    * @param {Element} element An XML DOM element that contains the reminder's serialized content.
    * @param {XmlPersistContext} context An object providing contextual information about the serialization process and some helper serialization methods.
    */

  }, {
    key: 'loadFromXml',
    value: function loadFromXml(element, context) {
      this._type = ReminderType[context.readString("type", element)];

      if (this._type == ReminderType.Leading) this._timeInterval = new TimeSpan(context.readInt("timeInterval", element));else this._time = context.readDateTime("date", element);

      this._message = context.readString("message", element);
    }

    /**
     * Serializes this reminder into a JSON string.
     * @returns {String} A string containing the reminder's JSON representation.
     */

  }, {
    key: 'toJson',
    value: function toJson() {
      var json = {};
      json.type = this.type;
      if (this.type == ReminderType.Leading) json.timeInterval = this.timeInterval.ticks;else json.time = this.time._date.valueOf();
      json.message = this.message;

      return json;
    }

    /**
    * Deserializes this reminder from a JSON string.
    * @param {String} json A string created by the toJson method.
    */

  }, {
    key: 'fromJson',
    value: function fromJson(json) {
      this._type = json.type;
      if (this._type == ReminderType.Leading) this._timeInterval = new TimeSpan(json.timeInterval);else this._time = new DateTime(new Date(json.time));
      this._message = json.message;
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return this._type;
    }
    /**
      * Sets the type of this reminder.
     * @param {ReminderType} value One of the ReminderType enumeration values.
     */
    ,
    set: function set$$1(value) {
      if (this._type === value) return;

      this._type = value;
      this.onChanged();
    }

    /**
     * Gets how much time before the item's scheduled start
     * time to raise the event that triggers the reminder.
     * @remarks The value of this property is considered only if the type of
      * the reminder is set to ReminderType.Leading.
     */

  }, {
    key: 'timeInterval',
    get: function get$$1() {
      return this._timeInterval;
    }
    /**
     * Sets how much time before the item's scheduled start
     * time to raise the event that triggers the reminder.
     * @param {TimeSpan} value The new property value.
     * @remarks The value of this property is considered only if the type of
      * the reminder is set to ReminderType.Leading.
     */
    ,
    set: function set$$1(value) {
      if (this._timeInterval.ticks < 0) return;

      if (this._timeInterval > Reminder.maxInterval) return;

      if (this._timeInterval.equals(value)) return;

      this._timeInterval = value;
      this.onChanged();
    }

    /**
     * Gets the time when the Reminder is triggered. 
     * @remarks The value of this property is considered only if the type of
     * the reminder is set to ReminderType.Exact.
     */

  }, {
    key: 'time',
    get: function get$$1() {
      return this._time;
    }
    /**
     * Sets the time when the Reminder is triggered. 
     * @param {DateTime} value The new property value.
     * @remarks The value of this property is considered only if the type of
     * the reminder is set to ReminderType.Exact.
     */
    ,
    set: function set$$1(value) {
      if (this._time.equals(value)) return;

      this._time = value;
      this.onChanged();
    }

    /**
     * Gets the message to display as a reminder.
     */

  }, {
    key: 'message',
    get: function get$$1() {
      return this._message;
    }
    /**
      * Sets the message to display as a reminder.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._message === value) return;

      this._message = value;
      this.onChanged();
    }

    /**
     * Raised when the reminder is changed.
     */

  }, {
    key: 'changed',
    get: function get$$1() {
      return this._changedEvent;
    }
  }], [{
    key: 'maxInterval',
    get: function get$$1() {
      return TimeSpan.fromMilliseconds(DateTime.MillisPerDay * 2);
    }
  }]);
  return Reminder;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
 * @class Represents a task in the calendar.
 * @augments Resource
 * @property {DateTime} dueDate Gets or sets the due date of the task.
 * @property {DateTime} startDate Gets or sets the start date of the task.
 * @property {DateTime} actualStart Gets or sets the actual start date of the task.
 * @property {DateTime} actualEnd Gets or sets the actual completion date of the task.
 * @property {String} subject Gets or sets the subject of the task.
 * @property {String} details Gets or sets the details of the task.
 * @property {TaskPriority} priority Gets or sets the priority of the task.
 * @property {TaskStatus} status Gets or sets the status of the task.
 * @property {Number} progress Gets or sets the progress of the task.
 * @property {Number} estimatedDuration Gets or sets the estimated duration of the task.
 * @property {Number} actualDuration Gets or sets the actual duration of the task.
 * @property {Number} estimatedCost Gets or sets the estimated cost of the task.
 * @property {Number} actualCost Gets or sets the actual cost of the task.
 * @property {Reminder} reminder Gets or sets the reminder of the task.
*/
var Task = function (_Resource) {
  inherits(Task, _Resource);

  /**
   * Initializes a new instance of the Task class.
   * @constructor
   */
  function Task() {
    classCallCheck(this, Task);

    var _this = possibleConstructorReturn(this, (Task.__proto__ || Object.getPrototypeOf(Task)).call(this));

    _this.id = IdGenerator.generate('TSK');
    /** @private {DateTime} */
    _this._dueDate = DateTime.maxValue();
    /** @private {DateTime} */
    _this._startDate = DateTime.minValue();
    /** @private {DateTime} */
    _this._actualEnd = DateTime.maxValue();
    /** @private {DateTime} */
    _this._actualStart = DateTime.minValue();
    /** @private {boolean} */
    _this._allDayEvent = false;
    /** @private {string} */
    _this._subject = '';
    /** @private {string} */
    _this._details = '';
    /** @private {TaskStatus} */
    _this._status = TaskStatus.NotStarted;
    /** @private {TaskPriority} */
    _this._priority = TaskPriority.Normal;
    /** @private {number} */
    _this._progress = 0;
    /** @private {number} */
    _this._estimatedDuration = 0;
    /** @private {number} */
    _this._actualDuration = 0;
    /** @private {number} */
    _this._estimatedCost = 0;
    /** @private {number} */
    _this._actualCost = 0;

    /** @private {Reminder} */
    _this._reminder = null;
    return _this;
  }

  /**
   * Gets the task's due date.
   */


  createClass(Task, [{
    key: 'saveToXml',


    /**
       * Saves the task content into an XML element.
       * @param {Element} element An XML DOM element that will contain the task's data.
       * @param {XmlPersistContext} context An object providing contextual information about the serialization process and some helper serialization methods.
       */
    value: function saveToXml(element, context) {
      get(Task.prototype.__proto__ || Object.getPrototypeOf(Task.prototype), 'saveToXml', this).call(this, element, context);

      context.writeDateTime(this.dueDate, "dueDate", element);
      context.writeDateTime(this.startDate, "startDate", element);
      context.writeDateTime(this.actualEnd, "actualEnd", element);
      context.writeDateTime(this.actualStart, "actualStart", element);

      context.writeBool(this.allDayEvent, "allDayEvent", element);

      context.writeString(this.subject, "subject", element);
      context.writeString(this.details, "details", element);
      context.writeString(this.status.toString(), "status", element);
      context.writeString(this.priority.oString(), "priority", element);
      context.writeFloat(this.progress, "progress", element);
      context.writeInt(this.estimatedDuration, "estimatedDuration", element);
      context.writeInt(this.actualDuration, "actualDuration", element);
      context.writeFloat(this.estimatedCost, "estimatedCost", element);
      context.writeFloat(this.actualCost, "actualCost", element);

      context.writeReminder(this.reminder, "reminder", element);
    }
    /**
    * Loads the task content from an XML element.
    * @param {Element} element An XML DOM element that contains the task's serialized content.
    * @param {XmlPersistContext} context An object providing contextual information about the serialization process and some helper serialization methods.
    */

  }, {
    key: 'loadFromXml',
    value: function loadFromXml(element, context) {
      get(Task.prototype.__proto__ || Object.getPrototypeOf(Task.prototype), 'loadFromXml', this).call(this, element, context);

      this._dueDate = context.readDateTime("dueDate", element);
      this._startDate = context.readDateTime("startDate", element);
      this._actualEnd = context.readDateTime("actualEnd", element);
      this._actualStart = context.readDateTime("actualStart", element);
      this._allDayEvent = context.readBool("allDayEvent", element);

      this._subject = context.readString("subject", element);
      this._details = context.readString("details", element);
      this._status = TaskStatus[context.readString("status", element)];
      this._priority = TaskPriority[context.readString("priority", element)];
      this._progress = context.readFloat("progress", element);
      this._estimatedDuration = context.readInt("estimatedDuration", element);
      this._actualDuration = context.readInt("actualDuration", element);
      this._estimatedCost = context.readFloat("estimatedCost", element);
      this._actualCost = context.readFloat("actualCost", element);

      this._reminder = context.readReminder("reminder", element);
    }

    /**
    * Serializes this task into a JSON string.
    * @returns {String} A string containing the task's JSON representation.
    */

  }, {
    key: 'toJson',
    value: function toJson() {
      var json = get(Task.prototype.__proto__ || Object.getPrototypeOf(Task.prototype), 'toJson', this).call(this);

      json.dueDate = this.dueDate._ticks;
      json.startDate = this.startDate._ticks;
      json.actualEnd = this.actualEnd._ticks;
      json.actualStart = this.actualStart._ticks;
      json.allDayEvent = this.allDayEvent;

      json.subject = this.subject;
      json.details = this.details;
      json.status = this.status;
      json.priority = this.priority;
      json.progress = this.progress;

      json.estimatedDuration = this.estimatedDuration;
      json.actualDuration = this.actualDuration;
      json.estimatedCost = this.estimatedCost;
      json.actualCost = this.actualCost;

      json.reminder = this.reminder ? this.reminder.toJson() : null;

      return json;
    }

    /**
    * Deserializes this task from a JSON string.
    * @param {String} json A string created by the toJson method.
    */

  }, {
    key: 'fromJson',
    value: function fromJson(json) {
      get(Task.prototype.__proto__ || Object.getPrototypeOf(Task.prototype), 'fromJson', this).call(this, json);

      this.dueDate = new DateTime(json.dueDate);
      this.startDate = new DateTime(json.startDate);
      this.actualEnd = new DateTime(json.actualEnd);
      this.actualStart = new DateTime(json.actualStart);
      this.allDayEvent = json.allDayEvent;

      this.subject = json.subject;
      this.details = json.details;
      this.status = json.status;
      this.priority = json.priority;
      this.progress = json.progress;

      this.estimatedDuration = json.estimatedDuration;
      this.actualDuration = json.actualDuration;
      this.estimatedCost = json.estimatedCost;
      this.actualCost = json.actualCost;

      if (json.reminder) {
        this.reminder = new Reminder();
        this.reminder.fromJson(json.reminder);
      }
    }
  }, {
    key: 'dueDate',
    get: function get$$1() {
      return this._dueDate;
    }
    /**
     * Sets the task's due date.
     * @param {DateTime} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._dueDate = value;
    }

    /**
     * Gets the task's start date.
     */

  }, {
    key: 'startDate',
    get: function get$$1() {
      return this._startDate;
    }
    /**
     * Sets the task's start date.
     * @param {DateTime} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._startDate = value;
    }

    /**
     * Gets the task's actual completion date.
     */

  }, {
    key: 'actualEnd',
    get: function get$$1() {
      return this._actualEnd;
    }
    /**
     * Sets the task's actual completion date.
     * @param {DateTime} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._actualEnd = value;
    }

    /**
     * Gets the task's actual start date.
     */

  }, {
    key: 'actualStart',
    get: function get$$1() {
      return this._actualStart;
    }
    /**
     * Sets the task's actual start date.
     * @param {DateTime} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._actualStart = value;
    }

    /**
     * Gets the subject of the task.
     */

  }, {
    key: 'subject',
    get: function get$$1() {
      return this._subject;
    }
    /**
     * Sets the subject of the task.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._subject = value;
    }

    /**
     * Gets the detailed description of the Task.
     */

  }, {
    key: 'details',
    get: function get$$1() {
      return this._details;
    }
    /**
     * Sets the detailed description of the Task.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._details = value;
    }

    /**
     * Gets the status of the task.
     */

  }, {
    key: 'status',
    get: function get$$1() {
      return this._status;
    }
    /**
     * Sets the status of the task.
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._status = value;
    }

    /**
     * Gets the task priority.
     */

  }, {
    key: 'priority',
    get: function get$$1() {
      return this._priority;
    }
    /**
     * Sets the task priority.
     * @param {TaskPriority} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._priority = value;
    }

    /**
     * Gets the task progress measured in percents.
     */

  }, {
    key: 'progress',
    get: function get$$1() {
      return this._progress;
    }
    /**
     * Sets the task progress measured in percents.
     * @param {Number} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (value < 0 || value > 100) return;

      this._progress = value;
    }

    /**
     * Gets the estimated duration of the task measured in minutes.
     */

  }, {
    key: 'estimatedDuration',
    get: function get$$1() {
      return this._estimatedDuration;
    }
    /**
     * Sets the estimated duration of the task measured in minutes.
     * @param {Number} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._estimatedDuration = value;
    }

    /**
     * Gets the actual duration for this task measured in minutes.
     */

  }, {
    key: 'actualDuration',
    get: function get$$1() {
      return this._actualDuration;
    }
    /**
     * Sets the actual duration for this task measured in minutes.
     * @param {Number} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._actualDuration = value;
    }

    /**
     * Gets the estimated cost of the task.
     */

  }, {
    key: 'estimatedCost',
    get: function get$$1() {
      return this._estimatedCost;
    }
    /**
     * Sets the estimated cost of the task.
     * @param {Number} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._estimatedCost = value;
    }

    /**
     * Gets the actual cost of this task.
     */

  }, {
    key: 'actualCost',
    get: function get$$1() {
      return this._actualCost;
    }
    /**
     * Sets the actual cost of this task.
     * @param {Number} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._actualCost = value;
    }

    /**
     * Gets the reminder for this task.
     */

  }, {
    key: 'reminder',
    get: function get$$1() {
      return this._reminder;
    }
    /**
     * Sets the reminder for this task.
     * @param {Reminder} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._reminder = value;
    }
  }]);
  return Task;
}(Resource);

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
 * Represents an exception of the recurrence pattern.
 */
var RecurrenceException = function () {
  /**
   * Initializes a new instance of the RecurrenceException class.
   */
  function RecurrenceException(item, index) {
    classCallCheck(this, RecurrenceException);

    /** @private {Item} */
    this._item = item;
    /** @private {number} */
    this._index = index;
    /** @private {boolean} */
    this._deleted = false;
  }

  /**
   * Mark this occurrence as deleted.
   * @package
   */


  createClass(RecurrenceException, [{
    key: "setDeleted",
    value: function setDeleted() {
      this._deleted = true;
    }

    /**
     * Gets or sets the zero-based index of this occurrence.
     * @package
     */

  }, {
    key: "isDeleted",


    /**
     * Gets or sets a value indicating whether this event occurrence has been deleted.
     */
    value: function isDeleted() {
      return this._deleted;
    }
  }, {
    key: "index",
    get: function get$$1() {
      return this._index;
    }
    /**
     * @package
     */
    ,
    set: function set$$1(value) {
      this._index = value;
    }

    /**
     * Gets the item representing the recurrence exception.
     */

  }, {
    key: "item",
    get: function get$$1() {
      return this._item;
    }
    /**
     * @package
     */
    ,
    set: function set$$1(value) {
      this._item = value;
    }
  }]);
  return RecurrenceException;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
* @class Represents a collection of keys and values.
*/
var Dictionary = function () {
    /**
     * Initializes a new instance of the Dictionary class.
        * @constructor
     */
    function Dictionary() {
        classCallCheck(this, Dictionary);

        this._keys = new List();
        this._values = new List();
    }

    /**
    * Associates the specified value with the specified key within the dictionary.
    * @param {TKey} key The key to associate the value with.
    * @param {TValue} value The value to associate.
    */


    createClass(Dictionary, [{
        key: "set",
        value: function set$$1(key, value) {
            if (this._keys.indexOfItem(key) > -1) throw new Error("key already exists in this dictionary");

            this._keys.add(key);
            this._values.add(value);
        }

        /**
        * Gets the value associated with the specified key within the dictionary.
        * @param {TKey} key The key whose value to get.
        */

    }, {
        key: "get",
        value: function get$$1(key) {
            var index = this._keys.indexOfItem(key);
            if (index > -1) {
                return this._values.items()[index];
            }
            return null;
        }

        /**
        * Determines whether the dictionary contains a specific key.
        * @param {TKey} key The key to locate in the dictionary.
        * @returns {Boolean} true if the element exists in the collection, otherwise false.
        */

    }, {
        key: "contains",
        value: function contains(key) {
            return this._keys.indexOfItem(key) > -1;
        }

        /**
        * Removes the element with the specified key from the dictionary.
        * @param {TKey} key The key of the element to remove.
        */

    }, {
        key: "remove",
        value: function remove(key) {
            var index = this._keys.indexOfItem(key);
            if (index > -1) {
                this._keys.removeAt(index);
                this._values.removeAt(index);
            }
        }

        /** Gets the number of key/value pairs contained in the dictionary */

    }, {
        key: "count",
        get: function get$$1() {
            return this._keys.count();
        }

        /** Gets an array with all keys in the dictionary. */

    }, {
        key: "keys",
        get: function get$$1() {
            return this._keys;
        }

        /** Gets an array with all values in the dictionary. */

    }, {
        key: "values",
        get: function get$$1() {
            return this._values;
        }
    }]);
    return Dictionary;
}();

var locale = {
    "locale": "en-US",
    "date": {
        "dateFormats": {
            "shortDate": "d/MM/yyyy",
            "shortTime": "h:mm tt",
            "longDate": "dddd, MMMM dd, yyyy",
            "longTime": "h:mm:ss tt",
            "dayMonth": "d/MM",
            "yearMonth": "MMMM, yyyy",
            "full": "dddd, MMMM dd, yyyy h:mm:ss tt"
        },
        "months": {
            "narrow": ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
            "short": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "long": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
        },
        "days": {
            "narrow": ["S", "M", "T", "W", "T", "F", "S"],
            "short": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "long": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        },
        "dayPeriods": {
            "am": "AM",
            "pm": "PM"
        },
        "firstDayOfWeek": 0
    },
    "strings": {
        "newFormHeader": "New Appointment",
        "editFormHeader": "Edit Appointment",
        "newRecurrenceFormHeader": "New Recurrence",
        "editRecurrenceFormHeader": "Edit Recurrence",
        "cueFormHeader": "Cue items",
        "dateCaption": "Date",
        "datesCaption": "Dates",
        "subjectCaption": "Subject",
        "startTimeCaption": "Start time",
        "endTimeCaption": "End time",
        "allDayEventCaption": "All day event",
        "reminderCaption": "Reminder",
        "detailsCaption": "Details",
        "contactsCaption": "Contacts",
        "todayCaption": "Today",
        "locationCaption": "Location",
        "patternCaption": "Pattern",
        "rangeCaption": "Range of recurrence",
        "everyCaption": "Every",
        "ofEveryCaption": "of every",
        "startCaption": "Start",
        "noEndCaption": "No end date",
        "endAfterCaption": "End after",
        "endDateCaption": "End by",
        "saveButtonCaption": "Save",
        "optionsButtonCaption": "Options",
        "cancelButtonCaption": "Cancel",
        "recurrenceButtonCaption": "Recurrence",
        "deleteButtonCaption": "Delete",
        "secondsValue": "seconds",
        "minuteValue": "minute",
        "minutesValue": "minutes",
        "hourValue": "hour",
        "hoursValue": "hours",
        "dayValue": "day",
        "daysValue": "days",
        "weeksValue": "weeks",
        "monthValue": "month",
        "dailyValue": "Daily",
        "weeklyValue": "Weekly",
        "monthlyValue": "Monthly",
        "yearlyValue": "Yearly",
        "intervalValue": "By time interval",
        "firstValue": "first",
        "secondValue": "second",
        "thirdValue": "third",
        "fourthValue": "fourth",
        "lastValue": "last",
        "weekendValue": "weekend",
        "weekdayValue": "weekday",
        "recurrenceDailyOnePattern": "Occurs every day",
        "recurrenceDailyTwoPattern": "Occurs every [Days] days",
        "recurrenceDailyThreePattern": "Occurs every weekday",
        "recurrenceDailyFourPattern": "Occurs every weekend day",
        "recurrenceWeeklyOnePattern": "Occurs every [DaysOfWeek]",
        "recurrenceWeeklyTwoPattern": "Occurs every [Weeks] weeks on [DaysOfWeek]",
        "recurrenceMonthlyOnePattern": "Occurs day [DayOfMonth] of every [Months] month(s)",
        "recurrenceMonthlyTwoPattern": "Occurs the [Occurrence] [Day] of every [Months] month(s)",
        "recurrenceYearlyOnePattern": "Occurs every [MonthOfYear] [DayOfMonth]",
        "recurrenceYearlyTwoPattern": "Occurs the [Occurrence] [Day] of [MonthOfYear]",
        "recurrenceIntervalPattern": "Occurs every [Interval.Days] days [Interval.Hours] hours [Interval.Minutes] minutes [Interval.Seconds] seconds",
        "recurrenceStartDatePattern": "effective [StartDate]",
        "recurrenceEndDatePattern": "until [EndDate]",
        "recurrenceTimeOnePattern": "from [StartTime] to [EndTime]",
        "recurrenceTimeTwoPattern": "at [StartTime]"
    }
};

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
 * @class Defines recurrence patterns for items scheduled to repeat over and over again.
 * @property {RecurrencePattern} pattern Gets or sets the recurrence pattern.
 * @property {DailyRecurrence} daily  Gets or sets the type of daily recurrence.
 * @property {MonthlyRecurrence} monthly Gets or sets the type of monthly recurrence.
 * @property {YearlyRecurrence} yearly Gets or sets the type of yearly recurrence.
 * @property {Number} days Gets or sets the number of days between two consecutive occurrences of the same event.
 * @property {Number} dayOfMonth Gets or sets the day of the month when the event occurs.
 * @property {Number} weeks Gets or sets the number of weeks between two consecutive occurrences of the event.
 * @property {DaysOfWeek} daysOfWeek Gets or sets the days of the week when the event occurs.
 * @property {Number} months Gets or sets the number of months between two consecutive occurrences of the same event.
 * @property {Number} monthOfYear Gets or sets the month of the year when the event occurs.
 * @property {Occurrence} occurrence Gets or sets on which occurrence of the week within the month the event occurs.
 * @property {DayOfWeekType} day Gets or sets a value indicating the day of the week when the event occurs.
 * @property {Number} interval Gets or sets the interval of recurrence.
 * @property {DateTime} startDate Gets or sets the date and time of the event's first occurrence.
 * @property {RecurrenceEnd} end Gets orsets the last time when the event occurs.
 * @property {Number} numOccurrences Gets or sets how many times a recurring event should occur.
 * @property {DateTime} endDate Gets or sets the end date of the recurrence.
 * @property {Dictionary} exceptions Gets a list with all recurrence exceptions.
 * @property {Item} master Gets the master item for the recurrence.
 */
var Recurrence = function () {
  /**
   * Initializes a new instance of the Recurrence class.
   * @constructor
   */
  function Recurrence() {
    classCallCheck(this, Recurrence);

    /** @private {RecurrencePattern} */
    this._pattern = RecurrencePattern.Weekly;
    /** @private {DailyRecurrence} */
    this._daily = DailyRecurrence.ByDayInterval;
    /** @private {MonthlyRecurrence} */
    this._monthly = MonthlyRecurrence.ByDayNumber;
    /** @private {YearlyRecurrence} */
    this._yearly = YearlyRecurrence.SpecificDate;

    /** @private {number} */
    this._days = 1;
    /** @private {number} */
    this._dayOfMonth = 1;
    /** @private {number} */
    this._weeks = 1;
    /** @private {DaysOfWeek} */
    this._daysOfWeek = DaysOfWeek.Monday;
    /** @private {number} */
    this._months = 1;
    /** @private {number} */
    this._monthOfYear = 1;
    /** @private {Occurrence} */
    this._occurrence = Occurrence.First;
    /** @private {DayOfWeekType} */
    this._day = DayOfWeekType.AnyDay;
    /** @private {number} */
    this._interval = DateTime.MillisPerHour;

    /** @private {DateTime} */
    this._startDate = DateTime.today();
    /** @private {RecurrenceEnd} */
    this._end = RecurrenceEnd.NumOccurrences;
    /** @private {number} */
    this._numOccurrences = 10;
    /** @private {DateTime} */
    this._endDate = DateTime.today();

    /** @private {Dictionary} */
    this._exceptions = new Dictionary();
    /** @private {Item} */
    this._master = null;

    this._resetEvent = new EventDispatcher();
  }

  /**
   * Creates an exact copy of this Recurrence object.
   * @returns A new Recurrence object, identical to the current one.
   */


  createClass(Recurrence, [{
    key: 'clone',
    value: function clone() {
      var clone = new Recurrence();
      clone.applyPattern(this);

      return clone;
    }

    /**
     * Determines whether two Recurrence objects define the same recurrence pattern.
     * @param {Recurrence} recurrence  A Recurrence object to compare with this recurrence.
     * @returns true if the Recurrence instances have the same recurrence pattern; otherwise false.
     */

  }, {
    key: 'samePatternAs',
    value: function samePatternAs(recurrence) {
      if (!recurrence) return false;

      if (this._pattern !== recurrence._pattern) return false;

      if (this._daily !== recurrence._daily) return false;

      if (this._monthly !== recurrence._monthly) return false;

      if (this._yearly !== recurrence._yearly) return false;

      if (this._days !== recurrence._days) return false;

      if (this._dayOfMonth !== recurrence._dayOfMonth) return false;

      if (this._weeks !== recurrence._weeks) return false;

      if (this._daysOfWeek !== recurrence._daysOfWeek) return false;

      if (this._months !== recurrence._months) return false;

      if (this._monthOfYear !== recurrence._monthOfYear) return false;

      if (this._occurrence !== recurrence._occurrence) return false;

      if (this._day !== recurrence._day) return false;

      if (this._interval !== recurrence._interval) return false;

      if (this._startDate !== recurrence._startDate) return false;

      if (this._end !== recurrence._end) return false;

      if (this._numOccurrences !== recurrence._numOccurrences) return false;

      if (this._endDate !== recurrence._endDate) return false;

      return true;
    }

    /**
     * Copies the property values of the specified Recurrence object as
     * values for the properties of this Recurrence object.
     * 
     * This method behaves similarly to the clone method but does not create a new object.
     * @param {Recurrence} recurrence The Recurrence object whose fields to copy.
     */

  }, {
    key: 'applyPattern',
    value: function applyPattern(recurrence) {
      if (this.samePatternAs(recurrence)) return;

      // Transfer all fields
      this._pattern = recurrence._pattern;
      this._daily = recurrence._daily;
      this._monthly = recurrence._monthly;
      this._yearly = recurrence._yearly;
      this._days = recurrence._days;
      this._dayOfMonth = recurrence._dayOfMonth;
      this._weeks = recurrence._weeks;
      this._daysOfWeek = recurrence._daysOfWeek;
      this._months = recurrence._months;
      this._monthOfYear = recurrence._monthOfYear;
      this._occurrence = recurrence._occurrence;
      this._day = recurrence._day;
      this._interval = recurrence._interval;
      this._startDate = recurrence._startDate.clone();
      this._end = recurrence._end;
      this._numOccurrences = recurrence._numOccurrences;
      if (recurrence._endDate) this._endDate = recurrence._endDate.clone();

      // Since the current pattern has changed, all exceptions are lost
      this.onReset();
    }

    /**
     * Returns the end date for this recurrence.
     * 
     * The end date is calculated based on the specified repeat number if RecurrenceEnd is set to NumOccurrences.
     * @returns {DateTime} The end date of the recurrence if the recurrence is set to expire or DateTime.MaxValue otherwise.
     */

  }, {
    key: 'getEndDate',
    value: function getEndDate() {
      if (this._end === RecurrenceEnd.Never) return DateTime.maxValue();

      if (this._end === RecurrenceEnd.EndDate) return this._endDate;

      var date = this._startDate.clone();
      var index = 0;
      while (index < this._numOccurrences) {
        var dateRef = { value: date };
        var next = this.getNextOccurrence(dateRef);
        date = dateRef.value;
        if (next) {
          index += 1;
          if (index >= this._numOccurrences) break;
        }

        // Advance date
        switch (this._pattern) {
          case RecurrencePattern.Daily:
            switch (this._daily) {
              case DailyRecurrence.ByDayInterval:
                date = date.addDays(this._days);
                break;

              case DailyRecurrence.EveryWorkday:
              case DailyRecurrence.EveryWeekend:
                date = date.addDays(1);
                break;

              default:
                break;
            }
            break;

          case RecurrencePattern.Weekly:
            {
              var weeksToSkip = this._weeks;

              // If we are on the first item, skip only 1 week
              if (index === 0) weeksToSkip = 1;

              if (date.dayOfWeek === DayOfWeek.Saturday) date = date.addDays(7 * (weeksToSkip - 1) + 1);else if (!next) date = date.addDays(7 * (weeksToSkip - 1));else date = date.addDays(1);
              break;
            }

          case RecurrencePattern.Monthly:
            {
              // Advance to the next month
              var daysToAdvance = date.daysInMonth - date.day + 1;

              date = date.addDays(daysToAdvance);

              // Advance few more months
              if (next) {
                for (var i = 0; i < this._months - 1; i += 1) {
                  daysToAdvance = date.daysInMonth;
                  date = date.addDays(daysToAdvance);
                }
              }
              break;
            }

          case RecurrencePattern.Yearly:
            date = date.addDays(1);
            break;

          case RecurrencePattern.ByTimeInterval:
            date = date.addMilliseconds(this._interval);
            break;

          default:
            break;
        }

        // Make sure the next calculation will not overflow DateTime
        if (date.year >= 9000) break;
      }

      return date;
    }

    /**
     * Associates the recurrence with the specified item. If the supplied reference is null,
     * the recurrence is detached from the currently associated master.
     * @param {Item} master The item to associate with.
     */

  }, {
    key: 'associateWith',
    value: function associateWith(master) {
      if (this._master === master) return;

      // If there is a current master item, notify it that it is recurring item no longer
      if (this._master) this._master.recurrence = null;

      this._master = master;

      // Clear all current exceptions
      this.onReset();
    }

    /**
     * Resets the recurrence and raises the event.
     * @private
     */

  }, {
    key: 'onReset',
    value: function onReset() {
      if (this._exceptions.count === 0) return;

      // Do reset the exception list
      this._exceptions = new Dictionary(); //.clear();

      // Raise the reset event
      this._resetEvent.raiseEvent(this, new EmptyEventArgs());
    }

    /**
     * Retrieves the number of the appropriate day within the specified month.
     * @private
     */

  }, {
    key: 'getDayOfTheMonth',
    value: function getDayOfTheMonth(date, occurrence, day) {
      var year = date.year;
      var month = date.month;
      var daysInMonth = date.daysInMonth;

      if (day === DayOfWeekType.AnyDay) {
        if (occurrence === Occurrence.Last) return daysInMonth;

        return occurrence + 1;
      }

      if (day === DayOfWeekType.Workday) {
        if (occurrence === Occurrence.Last) {
          var theDay = daysInMonth;
          var dayOfWeek = DateTime.fromDateParts(year, month, theDay).dayOfWeek;

          while (dayOfWeek === DayOfWeek.Saturday || dayOfWeek === DayOfWeek.Sunday) {
            theDay -= 1;
            dayOfWeek = (dayOfWeek + 6) % 7;
          }

          return theDay;
        } else {
          var _theDay = 1;
          var left = 1 + occurrence;
          var _dayOfWeek = DateTime.fromDateParts(year, month, 1).dayOfWeek;

          while (true) {
            if (_dayOfWeek !== DayOfWeek.Saturday && _dayOfWeek !== DayOfWeek.Sunday) left -= 1;

            if (left === 0) break;

            _theDay += 1;
            _dayOfWeek = (_dayOfWeek + 1) % 7;
          }

          return _theDay;
        }
      }

      if (day === DayOfWeekType.Weekend) {
        if (occurrence === Occurrence.Last) {
          var _theDay2 = daysInMonth;
          var _dayOfWeek2 = DateTime.fromDateParts(year, month, _theDay2).dayOfWeek;

          while (_dayOfWeek2 !== DayOfWeek.Saturday && _dayOfWeek2 !== DayOfWeek.Sunday) {
            _theDay2 -= 1;
            _dayOfWeek2 = (_dayOfWeek2 + 6) % 7;
          }

          return _theDay2;
        } else {
          var _theDay3 = 1;
          var _left = 1 + occurrence;
          var _dayOfWeek3 = DateTime.fromDateParts(year, month, 1).dayOfWeek;

          while (true) {
            if (_dayOfWeek3 === DayOfWeek.Saturday || _dayOfWeek3 === DayOfWeek.Sunday) _left -= 1;

            if (_left === 0) break;

            _theDay3 += 1;
            _dayOfWeek3 = (_dayOfWeek3 + 1) % 7;
          }

          return _theDay3;
        }
      }

      // It is a day of the week
      var needed = day - DayOfWeekType.Sunday;

      if (occurrence === Occurrence.Last) {
        var _theDay4 = daysInMonth;
        var _dayOfWeek4 = DateTime.fromDateParts(year, month, _theDay4).dayOfWeek;

        while (_dayOfWeek4 !== needed) {
          _theDay4 -= 1;
          _dayOfWeek4 = (_dayOfWeek4 + 6) % 7;
        }

        return _theDay4;
      } else {
        var _theDay5 = 1;
        var _left2 = 1 + occurrence;
        var _dayOfWeek5 = DateTime.fromDateParts(year, month, 1).dayOfWeek;

        while (true) {
          if (_dayOfWeek5 === needed) _left2 -= 1;

          if (_left2 === 0) break;

          _theDay5 += 1;
          _dayOfWeek5 = (_dayOfWeek5 + 1) % 7;
        }

        return _theDay5;
      }
    }

    /**
     * Locates and returns the date of the first occurrence after the specified date.
     * @private
     */

  }, {
    key: 'gotoFirstOccurrence',
    value: function gotoFirstOccurrence(date, refIndex) {
      refIndex.value = 0;

      if (date.equals(this._startDate) && this._pattern !== RecurrencePattern.ByTimeInterval) return date;

      switch (this._pattern) {
        case RecurrencePattern.Daily:
          switch (this._daily) {
            case DailyRecurrence.ByDayInterval:
              {
                // Calculate the number of days between date and the recurrence startdate
                var days = date.subtract(this._startDate) / DateTime.MillisPerDay;
                var daysToAdvance = (this._days - days % this._days) % this._days;

                // Calculate the initial index of the first item
                refIndex.value = (days + daysToAdvance) / this._days;

                return date.addDays(daysToAdvance);
              }

            case DailyRecurrence.EveryWorkday:
              {
                // Calculate the number of days between date and the recurrence startdate
                var _days = date.subtract(this._startDate) / DateTime.MillisPerDay;

                // We are processing only whole weeks for simplicity
                if (_days < 7) break;

                // Advance only with the number of whole weeks
                var _daysToAdvance = _days - _days % 7;

                // Calculate the initial index of the first item
                refIndex.value = _daysToAdvance / 7 * 5;

                // TODO: this will break with non-mutable dates!
                return this._startDate.clone().addDays(_daysToAdvance);
              }

            case DailyRecurrence.EveryWeekend:
              {
                // Calculate the number of days between date and the recurrence startdate
                var _days2 = date.subtract(this._startDate) / DateTime.MillisPerDay;

                // We are processing only whole weeks for simplicity
                if (_days2 < 7) break;

                // Advance only with the number of whole weeks
                var _daysToAdvance2 = _days2 - _days2 % 7;

                // Calculate the initial index of the first item
                refIndex.value = _daysToAdvance2 / 7 * 2;

                // TODO: this will break with non-mutable dates!
                return this._startDate.clone().addDays(_daysToAdvance2);
              }

            default:
              break;
          }
          break;

        case RecurrencePattern.Weekly:
          {
            // Calculate the number of days between date and the recurrence startdate
            var _days3 = date.subtract(this._startDate) / DateTime.MillisPerDay;

            // We are processing only whole week ranges for simplicity
            if (_days3 < this._weeks * 7) break;

            // Advance only with the number of whole week ranges
            var _daysToAdvance3 = _days3 - _days3 % (this._weeks * 7);

            // Calculate the number of recurrences in a week range
            var inRange = 0;
            if ((this._daysOfWeek & DaysOfWeek.Monday) > 0) inRange += 1;
            if ((this._daysOfWeek & DaysOfWeek.Tuesday) > 0) inRange += 1;
            if ((this._daysOfWeek & DaysOfWeek.Wednesday) > 0) inRange += 1;
            if ((this._daysOfWeek & DaysOfWeek.Thursday) > 0) inRange += 1;
            if ((this._daysOfWeek & DaysOfWeek.Friday) > 0) inRange += 1;
            if ((this._daysOfWeek & DaysOfWeek.Saturday) > 0) inRange += 1;
            if ((this._daysOfWeek & DaysOfWeek.Sunday) > 0) inRange += 1;

            // Calculate the initial index of the first item
            refIndex.value = _daysToAdvance3 / (this._weeks * 7) * inRange;

            // TODO: this will break with non-mutable dates!
            return this._startDate.clone().addDays(_daysToAdvance3);
          }

        case RecurrencePattern.Monthly:
          switch (this._monthly) {
            case MonthlyRecurrence.ByDayNumber:
              {
                // Calculate the month and year when this pattern starts
                var month = this._startDate.month;
                var year = this._startDate.year;
                if (this._startDate.day > Math.min(this._dayOfMonth, DateTime.fromDateParts(year, month).dayOfMonth)) {
                  month += 1;
                  if (month > 12) {
                    month = 1;
                    year += 1;
                  }
                }

                // Calculate the month and year of the specified start date
                var startMonth = date.month;
                var startYear = date.year;
                if (date.day < Math.min(this._dayOfMonth, DateTime.fromDateParts(startYear, startMonth).dayOfMonth)) {
                  startMonth -= 1;
                  if (startMonth < 1) {
                    startMonth = 12;
                    startYear -= 1;
                  }
                }

                // Calculate the absolute start month
                startMonth += (startYear - year) * 12;

                if (startMonth < month) break;

                // The number of month ranges between month and startMonth
                refIndex.value = 1 + (startMonth - month - 1) / this._months;

                // Calculate the start year
                startMonth = month + refIndex.value /* - 1*/ * this._months;
                startYear = year + (startMonth - 1) / 12;
                startMonth = (startMonth - 1) % 12 + 1;

                var dayOfMonth = Math.min(this._dayOfMonth, DateTime.fromDateParts(startYear, startMonth).dayOfMonth);

                return DateTime.fromDateParts(startYear, startMonth, dayOfMonth);
              }

            case MonthlyRecurrence.ByDayType:
              {
                // Calculate the month and year when this pattern starts
                var _month = this._startDate.month;
                var _year = this._startDate.year;
                var _dayOfMonth = this.getDayOfTheMonth(this._startDate, this._occurrence, this._day);
                if (this._startDate.Day > _dayOfMonth) {
                  _month += 1;
                  if (_month > 12) {
                    _month = 1;
                    _year += 1;
                  }
                }

                // Calculate the month and year of the specified start date
                var _startMonth = date.month;
                var _startYear = date.year;
                _dayOfMonth = this.getDayOfTheMonth(date, this._occurrence, this._day);
                if (date.day < _dayOfMonth) {
                  _startMonth -= 1;
                  if (_startMonth < 1) {
                    _startMonth = 12;
                    _startYear -= 1;
                  }
                }

                // Calculate the absolute start month
                _startMonth += (_startYear - _year) * 12;

                if (_startMonth <= _month) break;

                // The number of month ranges between month and startMonth
                refIndex.value = 1 + (_startMonth - _month - 1) / this._months;

                // Calculate the start year
                _startMonth = _month + (refIndex.value - 1) * this._months;
                _startYear = _year + (_startMonth - 1) / 12;
                _startMonth = (_startMonth - 1) % 12 + 1;

                _dayOfMonth = this.getDayOfTheMonth(DateTime.fromDateParts(_startYear, _startMonth, 1), this._occurrence, this._day);

                return DateTime.fromDateParts(_startYear, _startMonth, _dayOfMonth);
              }

            default:
              break;
          }
          break;

        case RecurrencePattern.Yearly:
          switch (this._yearly) {
            case YearlyRecurrence.SpecificDate:
              {
                // Calculate the year when this pattern starts
                var _month2 = this._startDate.month;
                var _year2 = this._startDate.year;
                var _dayOfMonth2 = Math.min(this._dayOfMonth, DateTime.fromDateParts(_year2, _month2).dayOfMonth);
                if (_month2 > this._monthOfYear - 1 || _month2 === this._monthOfYear - 1 && _dayOfMonth2 > this._startDate.day) {
                  _year2 += 1;
                }

                // Calculate the year of the specified start date
                var _startMonth2 = date.month;
                var _startYear2 = date.year;
                _dayOfMonth2 = Math.min(this._dayOfMonth, DateTime.fromDateParts(_startYear2, _startMonth2).dayOfMonth);
                if (_startMonth2 < this._monthOfYear - 1 || _startMonth2 === this._monthOfYear - 1 && _dayOfMonth2 < date.day) {
                  _startYear2 -= 1;
                }

                if (_startYear2 < _year2) break;

                refIndex.value = _startYear2 - _year2;

                return DateTime.fromDateParts(_startYear2, this._monthOfYear - 1, 1);
              }

            case YearlyRecurrence.ByDayType:
              {
                // Calculate the year when this pattern starts
                var _month3 = this._startDate.month;
                var _year3 = this._startDate.year;
                var _dayOfMonth3 = this.getDayOfTheMonth(this._startDate, this._occurrence, this._day);
                if (_month3 > this._monthOfYear - 1 || _month3 === this._monthOfYear - 1 && _dayOfMonth3 > this._startDate.day) {
                  _year3 += 1;
                }

                // Calculate the year of the specified start date
                var _startMonth3 = date.month;
                var _startYear3 = date.year;
                _dayOfMonth3 = this.getDayOfTheMonth(date, this._occurrence, this._day);
                if (_startMonth3 < this._monthOfYear - 1 || _startMonth3 === this._monthOfYear - 1 && _dayOfMonth3 < date.day) {
                  _startYear3 -= 1;
                }

                if (_startYear3 < _year3) break;

                refIndex.value = _startYear3 - _year3;

                return DateTime.fromDateParts(_startYear3, this._monthOfYear - 1, 1);
              }

            default:
              break;
          }
          break;

        case RecurrencePattern.ByTimeInterval:
          {
            if (date.lessThan(this._master.startTime)) return this._master.startTime;

            var millis = date.subtract2(this._master.startTime);
            var interval = this._interval;
            var items = millis / interval;
            refIndex.value = items;
            if (items !== 0 && millis % items > 0) refIndex.value += 1;

            // TODO: this will break with non-mutable dates!
            return this._master.startTime.clone().addMilliseconds(refIndex.value * interval);
          }

        default:
          break;
      }

      return this._startDate;
    }

    /**
     * Adjusts the date to the date of the next occurrence right after or at the specified date.
     * @private
     */

  }, {
    key: 'getNextOccurrence',
    value: function getNextOccurrence(refStartDate) {
      var date = refStartDate.value.clone();

      // Setup the item according to the recurrence pattern
      switch (this._pattern) {
        case RecurrencePattern.Daily:
          switch (this._daily) {
            case DailyRecurrence.ByDayInterval:
              // Do nothing
              break;

            case DailyRecurrence.EveryWorkday:
              {
                var dayOfWeek = date.dayOfWeek;
                if (dayOfWeek === DayOfWeek.Saturday || dayOfWeek === DayOfWeek.Sunday) {
                  var daysToAdvance = 2 - (dayOfWeek + 1) % 7;
                  date = date.addDays(daysToAdvance);
                }
                break;
              }

            case DailyRecurrence.EveryWeekend:
              {
                var _dayOfWeek6 = date.dayOfWeek;
                if (_dayOfWeek6 !== DayOfWeek.Saturday && _dayOfWeek6 !== DayOfWeek.Sunday) {
                  var _daysToAdvance4 = 6 - _dayOfWeek6;
                  date = date.addDays(_daysToAdvance4);
                }
                break;
              }

            default:
              break;
          }
          break;

        case RecurrencePattern.Weekly:
          {
            // Flags: 0 - Sunday, 6 - Saturday
            var days = [];

            days.push((this._daysOfWeek & DaysOfWeek.Sunday) > 0);
            days.push((this._daysOfWeek & DaysOfWeek.Monday) > 0);
            days.push((this._daysOfWeek & DaysOfWeek.Tuesday) > 0);
            days.push((this._daysOfWeek & DaysOfWeek.Wednesday) > 0);
            days.push((this._daysOfWeek & DaysOfWeek.Thursday) > 0);
            days.push((this._daysOfWeek & DaysOfWeek.Friday) > 0);
            days.push((this._daysOfWeek & DaysOfWeek.Saturday) > 0);

            var i = date.dayOfWeek;

            while (i < 7) {
              if (days[i]) break;

              i += 1;
              if (i !== 7) date = date.addDays(1);
            }

            if (i === 7) {
              refStartDate.value = date;
              return false;
            }
            break;
          }

        case RecurrencePattern.Monthly:
          {
            var dayOfMonth;
            switch (this._monthly) {
              case MonthlyRecurrence.ByDayNumber:
                {
                  // const dayOfMonth = Math.min(this._dayOfMonth, date.getDate());

                  // if (date.getDate() > dayOfMonth)
                  //   return false;

                  // date = DateTime.fromDateParts(date.year, date.month, dayOfMonth);
                  var test = new DateTime(new Date(date._date.getFullYear(), date._date.getMonth()));
                  dayOfMonth = Math.min(this.dayOfMonth, test.getDaysInMonth(test.isLeapYear()));

                  if (date.day > dayOfMonth) return false;

                  date = DateTime.fromDateParts(date.year, date.month, dayOfMonth);
                  break;
                }

              case MonthlyRecurrence.ByDayType:
                {
                  // Calculate the day of the month of the occurrance
                  dayOfMonth = this.getDayOfTheMonth(date, this._occurrence, this._day);

                  if (date.day > dayOfMonth) return false;

                  date = DateTime.fromDateParts(date.year, date.month, dayOfMonth);
                  break;
                }

              default:
                break;
            }
            break;
          }

        case RecurrencePattern.Yearly:
          switch (this._yearly) {
            case YearlyRecurrence.SpecificDate:
              {
                if (date.month === this._monthOfYear - 1) {
                  // We are the same month as required
                  var daysInMonth = date.daysInMonth;
                  var _dayOfMonth4 = Math.min(this._dayOfMonth, daysInMonth);

                  if (date.day <= _dayOfMonth4) {
                    var _daysToAdvance5 = _dayOfMonth4 - date.day;
                    date = date.addDays(_daysToAdvance5);
                    break;
                  } else {
                    // We are the same month, but we are after the required day.
                    // Advance to the first day of the next month
                    var _daysToAdvance6 = daysInMonth - date.day + 1;
                    date = date.addDays(_daysToAdvance6);
                  }
                }

                while (date.month !== this._monthOfYear - 1) {
                  // Advance to next month
                  date = date.addDays(date.daysInMonth - date.day + 1);
                }

                // Advance to the required day
                var dayOfMonth2 = Math.min(this._dayOfMonth, date.daysInMonth);
                if (dayOfMonth2 > 1) date = date.addDays(dayOfMonth2 - date.day);
                break;
              }

            case YearlyRecurrence.ByDayType:
              {
                if (date.month === this._monthOfYear - 1) {
                  // We are the same month as required
                  var _dayOfMonth6 = this.getDayOfTheMonth(date, this._occurrence, this._day);

                  if (date.day <= _dayOfMonth6) {
                    var _daysToAdvance7 = _dayOfMonth6 - date.day;
                    date = date.addDays(_daysToAdvance7);
                    break;
                  } else {
                    // We are the same month, but we are after the required day;
                    // Advance to the first day of the next month
                    var _daysInMonth = date.daysInMonth;
                    var _daysToAdvance8 = _daysInMonth - date.day + 1;
                    date = date.addDays(_daysToAdvance8);
                  }
                }

                while (date.month !== this._monthOfYear - 1) {
                  // Advance to next month
                  date = date.addDays(date.daysInMonth - date.day + 1);
                }

                // Advance to the required day
                var _dayOfMonth5 = this.getDayOfTheMonth(date, this._occurrence, this._day);
                if (_dayOfMonth5 > 1) date = date.addDays(_dayOfMonth5 - 1);
                break;
              }

            default:
              break;
          }
          break;

        case RecurrencePattern.ByTimeInterval:
          //date += _interval;
          break;

        default:
          break;

      }

      refStartDate.value = date;

      return true;
    }

    /**
     * Gets the occurrence right after or at the specified start date. This function ignores
     * the end date of the recurrence so it will always return a valid item.
     * @private
     */
    // TODO: rename

  }, {
    key: '_getNextOccurrence',
    value: function _getNextOccurrence(master, refStartDate) {
      if (!this.getNextOccurrence(refStartDate)) return null;

      // Instantiate the item (through the copy constructor)
      var startDate = refStartDate.value.clone();
      var item = new Item();

      if (this._pattern !== RecurrencePattern.ByTimeInterval) {
        var year = startDate.year;
        var month = startDate.month;
        var day = startDate.day;

        var startHour = this._master.startTime.hour;
        var startMinute = this._master.startTime.minute;
        var startSecond = this._master.startTime.second;

        item.startTime = DateTime.fromDateParts(year, month, day, startHour, startMinute, startSecond);
      } else {
        item.startTime = startDate;
      }

      var duration;
      if (item.allDayEvent) {
        duration = DateTime.millisecondsBetween(master.endTime, master.startTime);
        item.endTime = DateTime.addTicksToDate(item.startTime, duration);
      } else {
        duration = master.endTime.valueOf() - master.startTime.valueOf();
        item.endTime = new DateTime(new Date(item.startTime.valueOf() + duration));
      }

      return item;
    }

    /**
     * Returns the occurrence with the specified index.
     * @remarks This function might take considerable amount of time if you specify a large index in an infinite recurrence.
     * @param {Number} index The index of the occurrence to retrieve.
     * @param {*} refIsDeleted If the specified occurrence is an exception, this parameter
     * indicates upon function completion whether the exception is deleted or not.
     * @param {Boolean} noException Specifies whether to return the original item, in case this occurrence is an exception.
     * @returns {Item} A reference to the occurrence with the specified index or null, if there is no such occurrence.
     */

  }, {
    key: 'getOccurrence',
    value: function getOccurrence(index, refIsDeleted, noException) {
      // Cannot generate items for recurrences that are not associated
      if (!this._master) throw new Error('The recurrence is not associated with an item.');

      if (index < 0) throw new Error('Index cannot be negative.');

      if (this._end === RecurrenceEnd.NumOccurrences) {
        if (index >= this._numOccurrences) return null;
      }

      var start = this._startDate.clone();
      var end = DateTime.maxValue();
      if (this._end === RecurrenceEnd.EndDate && this._endDate.lessThan(end)) end = this._endDate;

      var i = 0;
      var refI = { value: i };
      var result = null;
      var date = this.gotoFirstOccurrence(this._startDate.clone(), refI);
      i = refI.value;

      while (true) {
        if (date.greaterThan(end)) break;

        if (this._end === RecurrenceEnd.NumOccurrences) {
          if (i >= this._numOccurrences) break;
        }

        // Get the next occurrence
        var refDate = { value: date };
        var item = this._getNextOccurrence(this._master, refDate);
        date = refDate.value;
        if (date.greaterThan(end)) break;

        if (item && date.greaterThanOrEqual(start)) {
          if (i === index) {
            // Copy properties from the master
            item.copyOccurrence(this._master);

            // Mark the item as occurrence
            item.setOccurrence(this, i);

            result = item;
            break;
          }
        }

        if (item) i += 1;

        // Advance date
        switch (this._pattern) {
          case RecurrencePattern.Daily:
            switch (this._daily) {
              case DailyRecurrence.ByDayInterval:
                date = date.addDays(this._days);
                break;

              case DailyRecurrence.EveryWorkday:
              case DailyRecurrence.EveryWeekend:
                date = date.addDays(1);
                break;

              default:
                break;
            }
            break;

          case RecurrencePattern.Weekly:
            {
              var weeksToSkip = this._weeks;

              // If we are on the first item, skip only 1 week
              if (i === 0) weeksToSkip = 1;

              if (date.dayOfWeek === DayOfWeek.Saturday) date = date.addDays(7 * (weeksToSkip - 1) + 1);else if (!item) date = date.addDays(7 * (weeksToSkip - 1));else date = date.addDays(1);
              break;
            }

          case RecurrencePattern.Monthly:
            {
              // Advance to the next month
              var daysToAdvance = date.daysInMonth - date.day + 1;

              date = date.addDays(daysToAdvance);

              // Advance few more months
              if (item) {
                for (var m = 0; m < this._months - 1; m += 1) {
                  daysToAdvance = date.daysInMonth;
                  date = date.addDays(daysToAdvance);
                }
              }
              break;
            }

          case RecurrencePattern.Yearly:
            date = date.addDays(1);
            break;

          case RecurrencePattern.ByTimeInterval:
            date = date.addMilliseconds(this._interval);
            break;

          default:
            break;

        }
      }

      // Check if the item is an exception
      if (result) {
        if (this._exceptions.contains(index) && !noException) {
          var exception = this._exceptions.get(index);

          result = exception.item;
          if (refIsDeleted) refIsDeleted.value = exception.isDeleted();
        }
      }

      return result;
    }

    /**
     * Creates occurrence items for this Recurrence in the specified date range.
     * @remarks The Calendar control uses this method to generate item occurrences
     * when a recurrent item must be displayed in the current view.
     * @param {DateTime} startDate The range start date.
     * @param {DateTime} endDate The range end date.
     * A collection of Item instances representing each occurrence of the recurrent event in the specified date range.
     */

  }, {
    key: 'generateItems',
    value: function generateItems(startDate, endDate) {
      // Cannot generate items for recurrences that are not associated
      if (!this._master) throw new Error('Cannot generate items for recurrence that is not associated.');

      var result = [];

      var start = startDate.clone();
      if (this._pattern !== RecurrencePattern.ByTimeInterval) start = startDate.date;
      if (this._startDate.greaterThan(start)) start = this._startDate;

      var end = endDate;
      if (this._end === RecurrenceEnd.EndDate && this._endDate.lessThan(end)) end = this._endDate;

      var index = 0;
      var refIndex = { value: index };
      var date = this.gotoFirstOccurrence(start.clone(), refIndex);
      index = refIndex.value;
      while (true) {
        if (date.greaterThan(end)) break;

        if (this._end === RecurrenceEnd.NumOccurrences) {
          if (index >= this._numOccurrences) break;
        }

        // Get the next occurrence
        var refDate = { value: date };
        var item = this._getNextOccurrence(this._master, refDate);
        date = refDate.value;
        if (date.greaterThan(end)) break;
        if (item && date.greaterThanOrEqual(start)) {
          // Copy properties from the master
          item.copyOccurrence(this._master);

          // Mark the item as occurrence
          item.setOccurrence(this, index);

          // Add the item to resulting list
          result.push(item);
        }

        if (item) index += 1;

        // Advance date
        switch (this._pattern) {
          case RecurrencePattern.Daily:
            switch (this._daily) {
              case DailyRecurrence.ByDayInterval:
                date = date.addDays(this._days);
                break;

              case DailyRecurrence.EveryWorkday:
              case DailyRecurrence.EveryWeekend:
                date = date.addDays(1);
                break;

              default:
                break;
            }
            break;

          case RecurrencePattern.Weekly:
            {
              var weeksToSkip = this._weeks;

              // If we are on the first item, skip only 1 week
              if (index === 0) weeksToSkip = 1;

              if (date.dayOfWeek === DayOfWeek.Saturday) date = date.addDays(7 * (weeksToSkip - 1) + 1);else if (!item) date = date.addDays(7 * (weeksToSkip - 1));else date = date.addDays(1);
              break;
            }

          case RecurrencePattern.Monthly:
            {
              // Advance to the next month
              var daysToAdvance = date.daysInMonth - date.day + 1;

              date = date.addDays(daysToAdvance);

              // Advance few more months
              if (item) {
                for (var i = 0; i < this._months - 1; i += 1) {
                  daysToAdvance = date.daysInMonth;
                  date = date.addDays(daysToAdvance);
                }
              }
              break;
            }

          case RecurrencePattern.Yearly:
            date = date.addDays(1);
            break;

          case RecurrencePattern.ByTimeInterval:
            date = date.addMilliseconds(this._interval);
            break;

          default:
            break;
        }
      }

      // Remove all deleted occurrences and substitute all exceptions
      var processedExceptions = new Dictionary();
      for (var _i = 0; _i < result.length;) {
        index = result[_i].occurrenceIndex;
        if (this._exceptions.contains(index)) {
          var exception = this._exceptions.get(index);

          processedExceptions.set(exception, exception);

          // If the exception is actually deleted, mark it for removal
          if (exception.isDeleted()) {
            result.splice(_i, 1);
            continue;
          }

          result[_i] = exception.item;
        }

        _i += 1;
      }

      // Add all remaining exceptions to the list
      var values = this._exceptions.values;
      for (var _i2 = 0; _i2 < values.length; _i2 += 1) {
        var _exception = values[_i2];
        if (processedExceptions.contains(_exception)) continue;

        if (!_exception.isDeleted()) result.push(_exception.item);
      }

      return result;
    }

    /**
     * Removes all exceptions of this Recurrence.
     */

  }, {
    key: 'clearExceptions',
    value: function clearExceptions() {
      this.onReset();
    }

    /**
     * Marks the specified item as an exception in the Recurrence pattern.
     * @remarks The Calendar control calls this method when a user drags an occurrence item or edits its text,
     * thus creating an exception of the recurrence.
     * @param {Item} item The item to be marked as an exception.
     * @param {Boolean} [deleted] Specifies whether the exception is created by deleting one
     * occurrence from the recurrent pattern or by changing the occurrence time properties.
     * @param {*} reminder For internal use.
     */

  }, {
    key: 'markException',
    value: function markException(item, deleted, reminder) {
      // If the item is Occurrence it is sensible to mark it as exception.
      // If the item is already Exception it can be marked as exception but
      // only if it is about to be deleted.
      // If neither of the above is true, the item would not be marked.
      if (item.recurrenceState !== RecurrenceState.Occurrence) {
        if (item.recurrenceState !== RecurrenceState.Exception || !deleted) return;
      }

      // Search first whether the item is within the list already
      var exception = void 0;
      var index = item.occurrenceIndex;

      if (this._exceptions.contains(index)) {
        exception = this._exceptions.get(index);
        if (deleted) exception.setDeleted();
      } else {
        exception = new RecurrenceException(item, index);
        // Mark as deleted
        if (deleted) exception.setDeleted();
        this._exceptions.set(index, exception);
      }

      // Set the item flag
      item.setException();

      if (reminder) item.reminder = reminder;else if (item.recurrence.master.reminder) item.reminder = item.recurrence.master.reminder.clone();

      // TODO:
      // item.style = item.recurrence.master.style.clone();
    }

    /**
     * Removes the exception associated with the specified item from the recurrence.
     * @param {Item} item The item whose exception to remove.
     */

  }, {
    key: 'removeException',
    value: function removeException(item) {
      var keys = this._exceptions.keys;
      for (var i = 0; i < keys.length; i += 1) {
        var index = keys[i];
        if (item.occurrenceIndex !== index) continue;

        // Restore the item state
        item.setOccurrence(this, index);

        // Remove from exception list
        this._exceptions.remove(index);

        break;
      }
    }

    // /**
    //    * Returns a string that represents this recurrence
    //    * @returns {String} A string that represents the Recurrence object.
    //    */
    // toString() {
    //   const builder = [];

    //   const dayNames = [
    //     'Sunday',
    //     'Monday',
    //     'Tuesday',
    //     'Wednesday',
    //     'Thursday',
    //     'Friday',
    //     'Saturday',
    //   ];

    //   const monthNames = [
    //     'January',
    //     'February',
    //     'March',
    //     'April',
    //     'May',
    //     'June',
    //     'July',
    //     'August',
    //     'September',
    //     'October',
    //     'November',
    //     'December',
    //   ];

    //   const occurrence = [
    //     'first',
    //     'second',
    //     'third',
    //     'fourth',
    //     'last',
    //   ];

    //   const day = [
    //     'day',
    //     'weekday',
    //     'weekend day',
    //     dayNames[0],
    //     dayNames[1],
    //     dayNames[2],
    //     dayNames[3],
    //     dayNames[4],
    //     dayNames[5],
    //     dayNames[6],
    //   ];

    //   const shortDatePattern = 'MMM dd, yyyy';
    //   const shortTimePattern = 'hh:mm';

    //   switch (this._pattern) {
    //     case RecurrencePattern.Daily:
    //       builder.push('Occurs every');

    //       switch (this._daily) {
    //         case DailyRecurrence.ByDayInterval:
    //           if (this._days === 1) {
    //             builder.push(' day');
    //           } else {
    //             builder.push(' ');
    //             builder.push(this._days.toString());
    //             builder.push(' days');
    //           }
    //           break;

    //         case DailyRecurrence.EveryWorkday:
    //           builder.push(' weekday');
    //           break;

    //         case DailyRecurrence.EveryWeekend:
    //           builder.push(' weekend day');
    //           break;

    //         default:
    //           break;
    //       }
    //       break;

    //     case RecurrencePattern.Weekly:
    //       {
    //         builder.push('Occurs every');

    //         if (this._weeks > 1) {
    //           builder.push(' ');
    //           builder.push(this._weeks.toString());
    //           builder.push(' week(s) on');
    //         }

    //         const days = [];

    //         days.push((this._daysOfWeek & DaysOfWeek.Sunday) > 0);
    //         days.push((this._daysOfWeek & DaysOfWeek.Monday) > 0);
    //         days.push((this._daysOfWeek & DaysOfWeek.Tuesday) > 0);
    //         days.push((this._daysOfWeek & DaysOfWeek.Wednesday) > 0);
    //         days.push((this._daysOfWeek & DaysOfWeek.Thursday) > 0);
    //         days.push((this._daysOfWeek & DaysOfWeek.Friday) > 0);
    //         days.push((this._daysOfWeek & DaysOfWeek.Saturday) > 0);

    //         let count = 0;
    //         days.forEach((b) => { if (b) count += 1; });

    //         let current = 0;
    //         for (let i = 0; i < days.length; i += 1) {
    //           if (days[i]) {
    //             if (current > 0) {
    //               if (count === 2) {
    //                 builder.push(' and');
    //               } else {
    //                 if (current < count - 1) {
    //                   builder.push(',');
    //                 } else {
    //                   builder.push(', and');
    //                 }
    //               }
    //             }

    //             builder.push(' ');
    //             builder.push(dayNames[i]);
    //             current += 1;
    //           }
    //         }
    //         break;
    //       }

    //     case RecurrencePattern.Monthly:
    //       switch (this._monthly) {
    //         case MonthlyRecurrence.ByDayNumber:
    //           builder.push('Occurs day ');
    //           builder.push(this._dayOfMonth.toString());
    //           builder.push(' of every ');
    //           builder.push(this._months.toString());
    //           builder.push(' month(s)');
    //           break;

    //         case MonthlyRecurrence.ByDayType:
    //           builder.push('Occurs the ');
    //           builder.push(occurrence[this._occurrence]);
    //           builder.push(' ');
    //           builder.push(day[this._day]);
    //           builder.push(' of every ');
    //           builder.push(this._months.toString());
    //           builder.push(' month(s)');
    //           break;

    //         default:
    //           break;
    //       }
    //       break;

    //     case RecurrencePattern.Yearly:
    //       switch (this._yearly) {
    //         case YearlyRecurrence.SpecificDate:
    //           builder.push('Occurs every ');
    //           builder.push(monthNames[this._monthOfYear - 1]);
    //           builder.push(' ');
    //           builder.push(this._dayOfMonth.toString());
    //           break;

    //         case YearlyRecurrence.ByDayType:
    //           builder.push('Occurs the ');
    //           builder.push(occurrence[this._occurrence]);
    //           builder.push(' ');
    //           builder.push(day[this._day]);
    //           builder.push(' of ');
    //           builder.push(monthNames[this._monthOfYear - 1]);
    //           break;

    //         default:
    //           break;
    //       }
    //       break;

    //     case RecurrencePattern.ByTimeInterval:
    //       {
    //         builder.push('Occurs every ');

    //         let interval = this._interval;
    //         const days2 = Math.floor(interval / DateTime.MillisPerDay);
    //         interval = interval % DateTime.MillisPerDay;
    //         const hours = Math.floor(interval / DateTime.MillisPerHour);
    //         interval = interval % DateTime.MillisPerHour;
    //         const minutes = Math.floor(interval / DateTime.MillisPerMinute);
    //         interval = interval % DateTime.MillisPerMinute;
    //         const seconds = Math.floor(interval / DateTime.MillisPerSecond);

    //         if (days2 !== 0) {
    //           builder.push(days2.toString());
    //           builder.push(' days');
    //         }

    //         if (hours !== 0) {
    //           builder.push(' ');
    //           builder.push(hours.toString());
    //           builder.push(' hours');
    //         }

    //         if (minutes !== 0) {
    //           builder.push(' ');
    //           builder.push(minutes.toString());
    //           builder.push(' minutes');
    //         }

    //         if (seconds !== 0) {
    //           builder.push(' ');
    //           builder.push(seconds.toString());
    //           builder.push(' seconds');
    //         }
    //         break;
    //       }

    //     default:
    //       break;
    //   }

    //   builder.push(' effective ');
    //   builder.push(this._startDate.toString(shortDatePattern));

    //   if (this._end !== RecurrenceEnd.Never) {
    //     builder.push(' until ');
    //     builder.push(this.getEndDate().toString(shortDatePattern));
    //   }

    //   if (this._pattern === RecurrencePattern.ByTimeInterval)
    //     return builder.join('');

    //   if (this._master) {
    //     if (!((this._master.startTime.timeOfDay === 0 || this._master.allDayEvent) &&
    //       (this._master.endTime.timeOfDay === 0 || this._master.allDayEvent))) {
    //       if (this._master.startTime.timeOfDay !== this._master.endTime.timeOfDay) {
    //         builder.push(' from ');
    //         builder.push(this._master.startTime.toString(shortTimePattern));

    //         builder.push(' to ');
    //         builder.push(this._master.endTime.toString(shortTimePattern));
    //       } else {
    //         builder.push(' at ');
    //         builder.push(this._master.startTime.toString(shortTimePattern));
    //       }
    //     }
    //   }

    //   return builder.join('');
    // }

    /**
        * Returns a localized string that represents this Recurrence using the specified date
        * and time formatting info and localization information.
        * @param {Object} formatInfo Specifies how date and time values are formatted and displayed.
        * @param {Object} localInfo Specifies localized strings used in the representation.
        * @returns {String}  A localized string representation of this Recurrence object.
        */

  }, {
    key: 'toLocalizedString',
    value: function toLocalizedString(formatInfo, localInfo) {
      var possibilities = [localInfo.recurrenceDailyOnePattern, localInfo.recurrenceDailyTwoPattern, localInfo.recurrenceDailyThreePattern, localInfo.recurrenceDailyFourPattern, localInfo.recurrenceWeeklyOnePattern, localInfo.recurrenceWeeklyTwoPattern, localInfo.recurrenceMonthlyOnePattern, localInfo.recurrenceMonthlyTwoPattern, localInfo.recurrenceYearlyOnePattern, localInfo.recurrenceYearlyTwoPattern, localInfo.recurrenceIntervalPattern, localInfo.recurrenceStartDatePattern, localInfo.recurrenceEndDatePattern, localInfo.recurrenceTimeOnePattern, localInfo.recurrenceTimeTwoPattern];

      var minutes = Math.floor(this.interval / DateTime.MillisPerHour * 60) % 60;
      var seconds = Math.round(this.interval / DateTime.MillisPerHour * 60 % 60 * 60 % 60);
      if (seconds >= 60) {
        minutes += seconds / 60;
        seconds -= 60 * (seconds / 60);
      }

      var replacements = new Dictionary();
      replacements.set('Days', this.days);
      replacements.set('DaysOfWeek', this.getDaysOfWeekString(formatInfo));
      replacements.set('Weeks', this.weeks);
      replacements.set('DayOfMonth', this.dayOfMonth);
      replacements.set('Months', this.months);
      replacements.set('Occurrence', this.getOccurrenceString(localInfo));
      replacements.set('Day', this.getDayOfWeekTypeString(formatInfo, localInfo));
      replacements.set('MonthOfYear', formatInfo.months.long[this.monthOfYear]);
      replacements.set('Interval.Days', Math.floor(this.interval / DateTime.MillisPerHour / 24.0));
      replacements.set('Interval.Hours', Math.floor(this.interval / DateTime.MillisPerHour % 24));
      replacements.set('Interval.Minutes', minutes);
      replacements.set('Interval.Seconds', seconds);
      replacements.set('StartDate', this.startDate.toString(formatInfo.dateFormats.shortDate, formatInfo));
      replacements.set('EndDate', this.getEndDate().toString(formatInfo.dateFormats.shortDate, formatInfo));
      replacements.set('StartTime', this._master != null ? this._master.startTime.toString(formatInfo.dateFormats.shortTime, formatInfo) : '');
      replacements.set('EndTime', this._master != null ? this._master.endTime.toString(formatInfo.dateFormats.shortTime, formatInfo) : '');

      var outcome = this.getOutcome();

      var formattedString = String.format('{0} {1}', possibilities[outcome[0]], possibilities[11]);
      if (outcome[1] !== -1) {
        formattedString += String.format(' {0}', possibilities[outcome[1]]);
      }
      if (outcome[2] !== -1) {
        formattedString += String.format(' {0}', possibilities[outcome[2]]);
      }
      var keys = '\\[(' + replacements.keys.items().join('|') + ')\\]';
      var regex = new RegExp(keys, 'g');

      var result = formattedString.replace(regex, function (m) {
        var val = m.replace('[', '').replace(']', '');
        if (replacements.contains(val)) {
          return replacements.get(val);
        }
        return m;
      });

      return result;
    }

    /**
    * @private
    */

  }, {
    key: 'getDaysOfWeekString',
    value: function getDaysOfWeekString(formatInfo) {
      var builder = '';
      var days = [];

      days[0] = (this.daysOfWeek & DaysOfWeek.Sunday) > 0;
      days[1] = (this.daysOfWeek & DaysOfWeek.Monday) > 0;
      days[2] = (this.daysOfWeek & DaysOfWeek.Tuesday) > 0;
      days[3] = (this.daysOfWeek & DaysOfWeek.Wednesday) > 0;
      days[4] = (this.daysOfWeek & DaysOfWeek.Thursday) > 0;
      days[5] = (this.daysOfWeek & DaysOfWeek.Friday) > 0;
      days[6] = (this.daysOfWeek & DaysOfWeek.Saturday) > 0;

      for (var i = 0, l = days.length; i < l; i++) {
        if (days[i] == true) {
          builder = builder.concat(formatInfo.days.long[i], ', ');
          
        }
      }
      if (builder.length > 0) {
        builder = builder.substr(0, builder.length - 2);
      }
      return builder;
    }

    /**
    * @private
    */

  }, {
    key: 'getOccurrenceString',
    value: function getOccurrenceString(localInfo) {
      var occurrence = [localInfo.firstValue, localInfo.secondValue, localInfo.thirdValue, localInfo.fourthValue, localInfo.lastValue];
      return occurrence[this.occurrence];
    }

    /**
    * @private
    */

  }, {
    key: 'getDayOfWeekTypeString',
    value: function getDayOfWeekTypeString(formatInfo, localInfo) {
      var day = [localInfo.dayValue, localInfo.weekdayValue, localInfo.weekendValue, formatInfo.days.long[0], formatInfo.days.long[1], formatInfo.days.long[2], formatInfo.days.long[3], formatInfo.days.long[4], formatInfo.days.long[5], formatInfo.days.long[6]];

      return day[this.day];
    }

    /**
    * @private
    */

  }, {
    key: 'getOutcome',
    value: function getOutcome() {
      var result = [-1, -1, -1];
      var first = -1;
      switch (this.pattern) {
        case RecurrencePattern.Daily:
          switch (this.dailyRecurrence) {
            case DailyRecurrence.ByDayInterval:
              if (this.days === 1) {
                first = 0;
              } else {
                first = 1;
              }
              break;
            case DailyRecurrence.EveryWorkday:
              first = 2;
              break;
            case DailyRecurrence.EveryWeekend:
              first = 3;
              break;
          }
          break;
        case RecurrencePattern.Weekly:
          if (this.weeks == 1) {
            first = 4;
          } else {
            first = 5;
          }
          break;
        case RecurrencePattern.Monthly:
          switch (this.monthlyRecurrence) {
            case MonthlyRecurrence.ByDayNumber:
              first = 6;
              break;
            case MonthlyRecurrence.ByDayType:
              first = 7;
              break;
          }
          break;
        case RecurrencePattern.Yearly:
          switch (this.yearlyRecurrence) {
            case YearlyRecurrence.SpecificDate:
              first = 8;
              break;
            case YearlyRecurrence.ByDayType:
              first = 9;
              break;
          }
          break;
        case RecurrencePattern.ByTimeInterval:
          first = 10;
          break;
      }
      result[0] = first;

      if (this.recurrenceEnd != RecurrenceEnd.Never) {
        result[1] = 12;
      }

      if (this.pattern == RecurrencePattern.ByTimeInterval) {
        return result;
      }

      if (this._master != null && this._master.startTime !== 0 && this._master.endTime !== 0) {
        var timeS = this._master.startTime.getTimeOfTheDay();
        var timeE = this._master.endTime.getTimeOfTheDay();

        if (!((timeS == 0 || this._master.allDayEvent) && (timeE == 0 || this._master.allDayEvent))) {
          if (timeS != timeE) {
            result[2] = 13;
          } else {
            result[2] = 14;
          }
        }
      }
      return result;
    }

    /**
     * Gets or sets the recurrence pattern.
     */

  }, {
    key: 'getExceptions',


    /**
     * Gets a list with all recurrence exceptions.
     */
    value: function getExceptions() {
      return this._exceptions.values;
    }

    /**
     * Gets the master item for the recurrence.
     * 
     * To associate a Recurrence with an Item, set the Item's Recurrence property to the Recurrence object.
     */

  }, {
    key: 'extend',


    /**
    * @private
    */
    value: function extend(data) {
      this.applyPattern(data);
    }

    /**
    * @private
    */

  }, {
    key: 'daysOfWeekToString',
    value: function daysOfWeekToString() {
      return this.getDaysOfWeekString(locale.date);
    }

    /**
    * @private
    */

  }, {
    key: 'daysOfWeekFromString',
    value: function daysOfWeekFromString(value) {
      var days = 0;
      for (var i = 0, l = 6; i <= l; i++) {
        if (value.indexOf(locale.date.days.long[i]) > -1) {
          days |= Math.pow(2, i);
        }
      }
      return days;
    }

    /**
        * Saves the recurrence content into an XML element.
        * @param {Element} element An XML DOM element that will contain the recurrence's data.
        * @param {MindFusion.Diagramming.XmlPersistContext} context An object providing contextual information about the serialization process and some helper serialization methods.
        */

  }, {
    key: 'saveToXml',
    value: function saveToXml(element, context) {
      context.writeString(DomUtils.getKeyByValue(RecurrencePattern, this._pattern), "pattern", element);
      context.writeString(DomUtils.getKeyByValue(DailyRecurrence, this._daily), "daily", element);
      context.writeString(DomUtils.getKeyByValue(MonthlyRecurrence, this._monthly), "monthly", element);
      context.writeString(DomUtils.getKeyByValue(YearlyRecurrence, this._yearly), "yearly", element);

      context.writeInt(this._days, "days", element);
      context.writeInt(this._dayOfMonth, "dayOfMonth", element);
      context.writeInt(this._weeks, "weeks", element);

      //context.writeString(DomUtils.getKeysByValue(DaysOfWeek, this._daysOfWeek), "daysOfWeek", element);
      context.writeString(this.daysOfWeekToString(), "daysOfWeek", element);

      context.writeInt(this._months, "months", element);
      context.writeInt(this._monthOfYear, "monthOfYear", element);
      context.writeString(DomUtils.getKeyByValue(Occurrence, this._occurrence), "occurrence", element);
      context.writeString(DomUtils.getKeyByValue(DayOfWeekType, this._day), "day", element);
      context.writeInt(this._interval * DateTime.TicksPerMillisecond, "interval", element);

      context.writeDateTime(this._startDate, "startDate", element);
      context.writeString(DomUtils.getKeyByValue(RecurrenceEnd, this._end), "end", element);
      context.writeInt(this._numOccurrences, "numOccurrences", element);
      context.writeDateTime(this._endDate, "endDate", element);

      // write exceptions
      var exceptionsElement = context.addChildElement("exceptions", element);
      for (var i = 0; i < this._exceptions._keys.count(); i++) {
        var exception = this._exceptions.get(this._exceptions._keys.items()[i]);

        var exceptionElement = context.addChildElement("exception", exceptionsElement);

        // Write exception index
        context.writeInt(exception._index, "index", exceptionElement);
        // Write 'deleted' flag
        context.writeBool(exception._deleted, "deleted", exceptionElement);
        // Write item itself, directly into the exception element
        context.saveItem(exception._item, exceptionElement, "");
      }
    }

    /**
    * Loads the recurrence content from an XML element.
    * @param {Element} element An XML DOM element that contains the recurrence's serialized content.
    * @param {MindFusion.Scheduling.XmlPersistContext} context An object providing contextual information about the serialization process and some helper serialization methods.
    */

  }, {
    key: 'loadFromXml',
    value: function loadFromXml(element, context) {
      this._pattern = RecurrencePattern[context.readString("pattern", element)];
      this._daily = DailyRecurrence[context.readString("daily", element)];
      this._monthly = MonthlyRecurrence[context.readString("monthly", element)];
      this._yearly = YearlyRecurrence[context.readString("yearly", element)];

      this._days = context.readInt("days", element);
      this._dayOfMonth = context.readInt("dayOfMonth", element);
      this._weeks = context.readInt("weeks", element);

      // this._daysOfWeek = DaysOfWeek[context.readString("daysOfWeek", element)];
      this._daysOfWeek = this.daysOfWeekFromString(context.readString("daysOfWeek", element));

      this._months = context.readInt("months", element);
      this._monthOfYear = context.readInt("monthOfYear", element);
      this._occurrence = Occurrence[context.readString("occurrence", element)];
      this._day = DayOfWeekType[context.readString("day", element)];

      this._interval = context.readInt("interval", element) / DateTime.TicksPerMillisecond;

      this._startDate = context.readDateTime("startDate", element);
      this._end = RecurrenceEnd[context.readString("end", element)];
      this._numOccurrences = context.readInt("numOccurrences", element);
      this._endDate = context.readDateTime("endDate", element);

      // Load the exceptions
      this.onReset();

      var nodes = element.getElementsByTagName("exceptions")[0];
      var child = nodes.firstElementChild;
      while (child != null) {

        // Read exception index
        var index = context.readInt("index", child);

        // Read 'deleted' flag
        var deleted = context.readBool("deleted", child);

        var item = context.loadItem(child);

        // Create the exception and add it to the list
        var exception = new RecurrenceException(item, index);

        // Mark as deleted
        if (deleted) exception.setDeleted();

        // Mark item as exception
        item.setOccurrence(this, index);
        item.setException();

        this._exceptions.set(index, exception);

        child = child.nextElementSibling;
      }
    }

    /**
    * Serializes this recurrence into a JSON string.
    * @returns {String} A string containing the recurrence's JSON representation.
    */

  }, {
    key: 'toJson',
    value: function toJson() {
      var json = {};
      json.pattern = this.pattern;
      json.daily = this._daily;
      json.monthly = this._monthly;
      json.yearly = this._yearly;

      json.days = this.days;
      json.dayOfMonth = this.dayOfMonth;
      json.weeks = this.weeks;
      json.daysOfWeek = this.daysOfWeek;
      json.months = this.months;
      json.monthOfYear = this.monthOfYear;
      json.occurrence = this.occurrence;
      json.day = this.day;

      json.interval = this.interval;

      json.startDate = this.startDate._date.valueOf();
      json.end = this._end;
      json.numOccurrences = this.numOccurrences;
      json.endDate = this.endDate._date.valueOf();

      // write exceptions
      var exceptions = [];
      for (var i = 0; i < this._exceptions._keys.count(); i++) {
        var exception = this._exceptions.get(this._exceptions._keys.items()[i]);

        var exj = {
          index: exception._index,
          deleted: exception._deleted,
          item: exception._item.toJson()
        };
        exceptions.push(exj);
      }
      json.exceptions = exceptions;

      return json;
    }

    /**
    * Deserializes this recurrence from a JSON string.
    * @param {String} json A string created by the toJson method.
    */

  }, {
    key: 'fromJson',
    value: function fromJson(json, schedule) {
      this._pattern = json.pattern;
      this._daily = json.daily;
      this._monthly = json.monthly;
      this._yearly = json.yearly;

      this._days = json.days;
      this._dayOfMonth = json.dayOfMonth;
      this._weeks = json.weeks;
      this._daysOfWeek = json.daysOfWeek;
      this._months = json.months;
      this._monthOfYear = json.monthOfYear;
      this._occurrence = json.occurrence;
      this._day = json.day;

      this._interval = json.interval;

      this._startDate = new DateTime(new Date(json.startDate));
      this._end = json.end;
      this._numOccurrences = json.numOccurrences;
      this._endDate = new DateTime(new Date(json.endDate));

      // Load the exceptions
      this.onReset();

      for (var i = 0; i < json.exceptions.length; i++) {

        var exj = json.exceptions[i];

        var index = exj.index;
        var deleted = exj.deleted;

        var item = new Item();
        item.fromJson(exj.item, schedule);

        // Create the exception and add it to the list
        var exception = new RecurrenceException(item, index);

        // Mark as deleted
        if (deleted) exception.setDeleted();

        // Mark item as exception
        item.setOccurrence(this, index);
        item.setException();

        this._exceptions.set(index, exception);
      }
    }
  }, {
    key: 'pattern',
    get: function get$$1() {
      return this._pattern;
    }
    /**
     * @param {RecurrencePattern} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._pattern === value) return;

      this._pattern = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets the type of daily recurrence.
     * 
     * This property is used when the Pattern is set to RecurrencePattern.Daily.
     */

  }, {
    key: 'dailyRecurrence',
    get: function get$$1() {
      return this._daily;
    }
    /**
     * @param {DailyRecurrence} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._daily === value) return;

      this._daily = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets the type of monthly recurrence.
     * 
     * The property is used when the Pattern is set to RecurrencePattern.Monthly.
     */

  }, {
    key: 'monthlyRecurrence',
    get: function get$$1() {
      return this._monthly;
    }
    /**
     * @param {MonthlyRecurrence} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._monthly === value) return;

      this._monthly = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets the type of yearly recurrence.
     * 
     * This property is used when the Pattern is set to RecurrencePattern.Yearly.
     */

  }, {
    key: 'yearlyRecurrence',
    get: function get$$1() {
      return this._yearly;
    }
    /**
     * @param {YearlyRecurrence} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._yearly === value) return;

      this._yearly = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets the number of days between two consecutive occurrences of the same event.
     * 
     * This value is used when the recurrence Pattern is set to RecurrencePattern.Daily.
     */

  }, {
    key: 'days',
    get: function get$$1() {
      return this._days;
    }
    /**
     * @param {Number} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (value <= 0) throw new Error('days must be greater than 0.');

      if (this._days === value) return;

      this._days = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets the day of the month when the event occurs.
     * 
     * This property is used when the Pattern is set to RecurrencePattern.Monthly or RecurrencePattern.Yearly.
     */

  }, {
    key: 'dayOfMonth',
    get: function get$$1() {
      return this._dayOfMonth;
    }
    /**
     * @param {Number} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (value <= 0 || value > 31) throw new Error('dayOfMonth must be between 1 and 31.');

      if (this._dayOfMonth === value) return;

      this._dayOfMonth = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets the number of weeks between two consecutive occurrences of the event.
     * 
     * The property is used when the Pattern is set to RecurrencePattern.Weekly.
     */

  }, {
    key: 'weeks',
    get: function get$$1() {
      return this._weeks;
    }
    /**
     * @param {Number} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (value <= 0) throw new Error('weeks must be greater than 0.');

      if (this._weeks === value) return;

      this._weeks = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets the days of the week when the event occurs.
     * 
     * This property is used when the Pattern is set to RecurrencePattern.Weekly.
     */

  }, {
    key: 'daysOfWeek',
    get: function get$$1() {
      return this._daysOfWeek;
    }
    /**
     * @param {DaysOfWeek} value The new property value.
     */
    ,
    set: function set$$1(value) {
      // At least one day should be set
      if (this._daysOfWeek === DaysOfWeek.None) return;

      if (this._daysOfWeek === value) return;

      this._daysOfWeek = value;

      // Changin the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets the number of months between two consecutive occurrences of the same event.
     * 
     * The property is used when the Pattern is set to RecurrencePattern.Monthly.
     */

  }, {
    key: 'months',
    get: function get$$1() {
      return this._months;
    }
    /**
     * @param {Number} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (value <= 0) throw new Error('months must be greater than 0.');

      if (this._months === value) return;

      this._months = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets the month of the year when the event occurs.
     * 
     * The property is used when the Pattern is set to RecurrencePattern.Yearly.
     */

  }, {
    key: 'monthOfYear',
    get: function get$$1() {
      return this._monthOfYear;
    }
    /**
     * @param {Number} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (value <= 0 || value > 12) throw new Error('monthOfYear must be between 1 and 12.');

      if (this._monthOfYear === value) return;

      this._monthOfYear = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets on which occurrence of the week within the month the event occurs.
     * 
     * The property is used when the Pattern is set to RecurrencePattern.Monthly or
     * RecurrencePattern.Yearly and the MonthlyRecurrence or YearlyRecurrence properties
     * are set to MonthlyRecurrence.ByDayType.
     */

  }, {
    key: 'occurrence',
    get: function get$$1() {
      return this._occurrence;
    }
    /**
     * @param {Occurrence} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._occurrence === value) return;

      this._occurrence = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets a value indicating the day of the week when the event occurs.
     * 
     * The property is used when Pattern is set to RecurrencePattern.Monthly or
     * RecurrencePattern.Yearly and the MonthlyRecurrence or YearlyRecurrence properties
     * are set to MonthlyRecurrence.ByDayType.
     */

  }, {
    key: 'day',
    get: function get$$1() {
      return this._day;
    }
    /**
     * @param {DayOfWeekType} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._day === value) return;

      this._day = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets the interval of recurrence.
     * 
     * The property is used when the Pattern is set to RecurrencePattern.ByTimeInterval.
     */

  }, {
    key: 'interval',
    get: function get$$1() {
      return this._interval;
    }
    /**
     * @param {Number} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._interval === value) return;

      this._interval = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets the date and time of the event's first occurrence.
     */

  }, {
    key: 'startDate',
    get: function get$$1() {
      return this._startDate;
    }
    /**
     * @param {DateTime} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._startDate.equals(value)) return;

      this._startDate = value.date;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets the last time when the event occurs.
     */

  }, {
    key: 'recurrenceEnd',
    get: function get$$1() {
      return this._end;
    }
    /**
     * @param {RecurrenceEnd} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._end === value) return;

      this._end = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets how many times a recurring event should occur.
     */

  }, {
    key: 'numOccurrences',
    get: function get$$1() {
      return this._numOccurrences;
    }
    /**
     * @param {Number} value The new property value.
     */
    ,
    set: function set$$1(value) {
      // At least one occurrence has to be defined
      if (value <= 0 || value > 999) throw new Error('numOccurrences must be between 1 and 999.');

      if (this._numOccurrences === value) return;

      this._numOccurrences = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }

    /**
     * Gets or sets the end date of the recurrence.
     * 
     * The property is used when RecurrenceEnd is set to RecurrenceEnd.EndDate.
     */

  }, {
    key: 'endDate',
    get: function get$$1() {
      return this._endDate;
    }
    /**
     * @param {DateTime} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._endDate.equals(value)) return;

      this._endDate = value;

      // Changing the recurrence pattern causes all exceptions to be lost
      this.onReset();
    }
  }, {
    key: 'master',
    get: function get$$1() {
      return this._master;
    }

    /**
     * Raised when the recurrence pattern has been reset, that is, all exceptions have been erased.
     */

  }, {
    key: 'reset',
    get: function get$$1() {
      return this._resetEvent;
    }
  }]);
  return Recurrence;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
 * @class Represents appointments within a schedule.
 * @property {String} id Gets or sets the string identifier for this item.
 * @property {DateTime} startTime Gets or sets item's scheduled start time.
 * @property {DateTime} endTime Gets or sets item's scheduled end time.
 * @property {Boolean} allowChangeStart Gets or sets a value indicating whether users are allowed to change the item's start time.
 * @property {Boolean} allowChangeEnd Gets or sets a value indicating whether users are allowed to change the item's end time.
 * @property {Boolean} allowMove Gets or sets a value indicating whether users are allowed to move the item.
 * @property {Boolean} allDayEvent Gets or sets a value indicating whether the item represents an all day event.
 * @property {String} subject Gets or sets the text rendered in the header for this item by the scheduling control.
 * @property {String} details Gets or sets the description rendered for this item by the scheduling control.
 * @property {Boolean} locked Gets or sets a value indicating whether users are forbidden to modify this item.
 * @property {String} cssClass Gets or sets the css class of the item.
 * @property {Reminder} reminder Gets or sets the reminder for this item.
 * @property {Location} location Gets or sets the location associated with this item.
 * @property {Task} task Gets or sets the task associated with this item.
 * @property {ObservableCollection} contacts Gets the collection of contacts associated with this item.
 * @property {ObservableCollection} resources Gets the collection of resources associated with this item.
 * @property {Boolean} visible Gets or sets a value indicating whether the item is visible or not.
 * @property {Recurrence} recurrence Gets or sets the recurrence pattern of this item.
 * @property {RecurrenceState} recurrenceState Gets the recurrence state of this item.
 * @property {Number} occurrenceIndex Gets the index of a repeating occurrence of a recurring item.
 * @property {Number} priority Gets or sets the priority of the item.
 * @property {Object} tag Gets or sets custom data associated with the item.
 */
var Item = function () {
  /**
   * Initializes a new instance of the Item class.
    * @constructor
   */
  function Item() {
    var _this = this;

    classCallCheck(this, Item);

    /** @private {DateTime} */
    this._startTime = DateTime.minValue();
    /** @private {DateTime} */
    this._endTime = DateTime.maxValue();

    /** @private {boolean} */
    this._allowChangeStart = true;
    /** @private {boolean} */
    this._allowChangeEnd = true;
    /** @private {boolean} */
    this._allowMove = true;
    /** @private {boolean} */
    this._allDayEvent = false;
    /** @private {string} */
    this._subject = '';
    /** @private {string} */
    this._details = '';
    /** @private {boolean} */
    this._locked = false;

    /** @private {string} */
    this._cssClass = '';

    /** @private {Reminder} */
    this._reminder = null;

    /** @private {string} */
    this._id = IdGenerator.generate('ITM');

    /** @private {Location} */
    this._location = null;
    /** @private {Task} */
    this._task = null;

    /** @private {ObservableCollection} */
    this._contacts = new ObservableCollection();
    this._contacts.collectionChanged.addEventListener(function () {
      _this.onCollectionChanged();
    });

    /** @private {ObservableCollection} */
    this._resources = new ObservableCollection();
    this._resources.collectionChanged.addEventListener(function () {
      _this.onCollectionChanged();
    });

    /** @private {boolean} */
    this._visible = true;

    /** @private {Recurrence} */
    this._recurrence = null;
    /** @private {RecurrenceState} */
    this._recurrenceState = RecurrenceState.None;
    /** @private {number} */
    this._occurrenceIndex = -1;
    /** @private {boolean} */
    this._settingRecurrence = false;
    /** @private {number} */
    this._priority = 0;

    this._propertyChangedEvent = new EventDispatcher();
    this._exceptionCreatedEvent = new EventDispatcher();
    this._recurrenceResetEvent = new EventDispatcher();
  }

  /**
   * Raises the propertyChanged event.
   * @package
   */


  createClass(Item, [{
    key: 'onPropertyChanged',
    value: function onPropertyChanged(name, oldValue, newValue) {
      this._propertyChangedEvent.raiseEvent(this, new PropertyEventArgs(name, oldValue, newValue));
    }
  }, {
    key: 'onCollectionChanged',
    value: function onCollectionChanged() {
      this.onPropertyChanged();
      this.markException();
    }

    /**
     * Raises the exceptionCreatedEvent event.
     * @package
     */

  }, {
    key: 'onExceptionCreated',
    value: function onExceptionCreated(sender) {
      this._exceptionCreatedEvent.raiseEvent(sender, new EmptyEventArgs());
    }

    /**
     * Raises the recurrenceResetEvent event.
     * @package
     */

  }, {
    key: 'onRecurrenceReset',
    value: function onRecurrenceReset() {
      this._recurrenceResetEvent.raiseEvent(this, new EmptyEventArgs());
    }

    /**
     * Marks the item as an occurrence of a repeating item.
      * @private
     */

  }, {
    key: 'setOccurrence',
    value: function setOccurrence(recurrence, index) {
      this._recurrence = recurrence;
      this._recurrenceState = RecurrenceState.Occurrence;
      this._occurrenceIndex = index;
    }

    /**
     * Sets the recurrence state of the item to RecurrenceState.Exception.
      * @private
     */

  }, {
    key: 'setException',
    value: function setException() {
      // If already an exception, do nothing
      if (this._recurrenceState === RecurrenceState.Exception) return;

      this._recurrenceState = RecurrenceState.Exception;

      // Raise the ExceptionCreate event on the master,
      // passing as parameter the actual item (i.e. this)
      this._recurrence.master.onExceptionCreated(this);
    }

    /**
     * Called by the recurrence whenever a new occurrence is generated in order to populate
     * the property fields of the instance with values from the master item.
     * @param {Item} master An Item that represents the master.
      * @private
     */

  }, {
    key: 'copyOccurrence',
    value: function copyOccurrence(master) {
      // Note: Occurrences do have the same Id as their corresponding master. This is done to
      // ensure that an occurrence instance has the same structure every time it is generated
      this.id = master.id;
      this.subject = master.subject;
      this.details = master.details;
      this.task = master.task;
      this.location = master.location;
      this.locked = master.locked;
      this.visible = master.visible;
      this.allDayEvent = master.allDayEvent;
      this.allowChangeEnd = master.allowChangeEnd;
      this.allowChangeStart = master.allowChangeStart;
      this.allowMove = master.allowMove;
      this.priority = master.priority;
      this.cssClass = master.cssClass;

      for (var i = 0; i < master.contacts.count(); i += 1) {
        this.contacts.add(master.contacts.items()[i]);
      }for (var _i = 0; _i < master.resources.count(); _i += 1) {
        this.resources.add(master.resources.items()[_i]);
      } // Note: The references to the item's reminder and styles
      // are not cloned from the master until after the item
      // is made an exception to avoid overheat. If the
      // corresponding properties are accessed, there values
      // are obtained from the recurrence master item.
      // The properties would actually be copied(cloned) when
      // the item is marked as an exception (see Recurrence.MarkException)
    }

    /**
     * Marks the item as exception if it is a recurrent item.
     * @private
     */

  }, {
    key: 'markException',
    value: function markException() {
      if (this._recurrence) this._recurrence.markException(this, false);
    }

    /**
     * @private
     */

  }, {
    key: 'onReminderChanged',
    value: function onReminderChanged() {
      this.markException();
    }

    /**
     * Creates an exact copy of this item.
     */

  }, {
    key: 'clone',
    value: function clone() {
      var clone = new Item();

      clone.allDayEvent = this.allDayEvent;
      clone.allowChangeEnd = this.allowChangeEnd;
      clone.allowChangeStart = this.allowChangeStart;
      clone.allowMove = this.allowMove;
      clone.details = this.details;
      clone.endTime = this.endTime;
      clone.subject = this.subject;
      clone.location = this.location;
      clone.locked = this.locked;
      clone.priority = this.priority;
      clone.reminder = this.reminder;
      clone.startTime = this.startTime;
      clone.tag = this.tag;
      clone.task = this.task;
      clone.visible = this.visible;
      for (var i = 0; i < this.contacts.count(); i++) {
        clone.contacts.add(this.contacts.items()[i]);
      }for (var _i2 = 0; _i2 < this.resources.count(); _i2++) {
        clone.resources.add(this.resources.items()[_i2]);
      }return clone;
    }

    /**
     * Gets a list with all contacts associated with this item.
     */

  }, {
    key: 'setResource',


    /**
     * @private
     */
    value: function setResource(resource) {
      if (resource) {
        if (resource instanceof Location) {
          this.location = resource;
        } else if (resource instanceof Contact) {
          this.contacts.clear();
          this.contacts.add(resource);
        } else if (resource instanceof Task) {
          this.task = resource;
        } else if (resource instanceof Resource) {
          this.resources.clear();
          this.resources.add(resource);
        }
      }
    }

    /**
    * @private
    */

  }, {
    key: 'hasResource',
    value: function hasResource(resource) {
      if (resource) {
        if (this.contacts.contains(resource)) return true;

        if (this.location === resource) return true;

        if (this.task === resource) return true;

        if (this.resources.contains(resource)) return true;
      }
      return false;
    }

    /**
    * @private
    */

  }, {
    key: 'extend',
    value: function extend(data) {
      if (data) {
        if (data.startTime) this.startTime = data.startTime;
        if (data.endTime) this.endTime = data.endTime;
        if (data.allDayEvent !== undefined) this.allDayEvent = data.allDayEvent;
        if (data.subject !== undefined) this.subject = data.subject;
        if (data.details !== undefined) this.details = data.details;
        if (data.reminder !== undefined) this.reminder = data.reminder;
        if (data.location !== undefined) this.location = data.location;
        if (data.task !== undefined) this.task = data.task;
        if (data.contacts !== undefined) {
          this.contacts.clear();
          var c = data.contacts._items ? data.contacts._items : data.contacts;
          for (var i = 0; i < c.length; i++) {
            this.contacts.add(c[i]);
          }
        }
        if (data.resources !== undefined) {
          this.resources.clear();
          var r = data._resources._items ? data._resources._items : data._resources;
          for (var i = 0; i < r.length; i++) {
            this.resources.add(r[i]);
          }
        }
      }
    }
  }, {
    key: 'saveToXml',


    /**
        * Saves the item content into an XML element.
        * @param {Element} element An XML DOM element that will contain the item's data.
        * @param {XmlPersistContext} context An object providing contextual information about the serialization process and some helper serialization methods.
        */
    value: function saveToXml(element, context) {
      context.writeString(this.id, "id", element);

      context.writeDateTime(this.startTime, "startTime", element);
      context.writeDateTime(this.endTime, "endTime", element);

      context.writeBool(this.allowChangeStart, "allowChangeStart", element);
      context.writeBool(this.allowChangeEnd, "allowChangeEnd", element);
      context.writeBool(this.allowMove, "allowMove", element);
      context.writeBool(this.allDayEvent, "allDayEvent", element);
      context.writeBool(this.locked, "locked", element);

      context.writeString(this.subject, "subject", element);
      context.writeString(this.details, "details", element);

      context.writeString(this.location ? this.location.id : "", "location", element);
      context.writeString(this.task ? this.task.id : "", "task", element);

      context.writeString(this.cssClass, "cssClass", element);
      context.writeInt(this.priority, "priority", element);

      // write contacts
      var contactsElement = context.addChildElement("attendees", element);
      for (var i = 0; i < this.contacts.count(); i++) {
        context.writeString(this.contacts.items()[i].id, "item", contactsElement);
      } // write resources
      var resourcesElement = context.addChildElement("resources", element);
      for (var i = 0; i < this.resources.count(); i++) {
        context.writeString(this.resources.items()[i].id, "item", resourcesElement);
      }context.writeReminder(this.reminder, "reminder", element);
      context.writeBool(this.visible, "visible", element);
      context.writeTag(this, this.tag, "tag", element);

      if (this.recurrenceState == RecurrenceState.Master) {
        var recurrenceElement = context.addChildElement("recurrence", element);
        this.recurrence.saveToXml(recurrenceElement, context);
      }
    }

    /**
    * Loads the item content from an XML element.
    * @param {Element} element An XML DOM element that contains the item's serialized content.
    * @param {XmlPersistContext} context An object providing contextual information about the serialization process and some helper serialization methods.
    */

  }, {
    key: 'loadFromXml',
    value: function loadFromXml(element, context) {

      this._id = context.readString("id", element);

      this._startTime = context.readDateTime("startTime", element);
      this._endTime = context.readDateTime("endTime", element);

      this._allowChangeStart = context.readBool("allowChangeStart", element, true);
      this._allowChangeEnd = context.readBool("allowChangeEnd", element, true);
      this._allowMove = context.readBool("allowMove", element, true);
      this._allDayEvent = context.readBool("allDayEvent", element);
      this._locked = context.readBool("locked", element);

      this._subject = context.readString("subject", element);
      this._details = context.readString("details", element);

      this._location = context.schedule.getResourceById(context.readString("location", element));
      this._task = context.schedule.getResourceById(context.readString("task", element));

      this._cssClass = context.readString("cssClass", element).trim();

      // load contacts
      this.contacts.clear();
      var nodes = element.getElementsByTagName("attendees")[0];
      var child = nodes.firstElementChild;
      while (child != null) {
        var contact = context.schedule.getResourceById(context.innerText(child));
        this.contacts.add(contact);
        child = child.nextElementSibling;
      }

      // load resources
      this.resources.clear();
      nodes = element.getElementsByTagName("resources")[0];
      child = nodes.firstElementChild;
      while (child != null) {
        var resource = context.schedule.getResourceById(context.innerText(child));
        this.resources.add(resource);
        child = child.nextElementSibling;
      }

      this._visible = context.readBool("visible", element);
      this._tag = context.readTag(this, "tag", element);
      this._priority = context.readInt("priority", element);

      this.reminder = context.readReminder("reminder", element);

      // load recurrence
      var recurrenceElement = context.selectSingleNode("recurrence", element);
      if (!recurrenceElement) return;
      if (context.isEmpty(recurrenceElement)) return;

      this.recurrence = new Recurrence();
      this.recurrence.loadFromXml(recurrenceElement, context);
    }

    /**
    * Serializes this item into a JSON string.
    * @returns {String} A string containing the item's JSON representation.
    */

  }, {
    key: 'toJson',
    value: function toJson() {
      var json = {};

      json.id = this.id;
      json.startTime = this.startTime._date.valueOf();
      json.endTime = this.endTime._date.valueOf();

      json.allowChangeStart = this.allowChangeStart;
      json.allowChangeEnd = this.allowChangeEnd;
      json.allowMove = this.allowMove;
      json.allDayEvent = this.allDayEvent;
      json.locked = this.locked;

      json.subject = this.subject;
      json.details = this.details;

      var contacts = [];
      for (var i = 0, l = this.contacts.count(); i < l; i++) {
        contacts.push(this.contacts.items()[i].id);
      }
      json.contacts = contacts;

      var resources = [];
      for (var i = 0, l = this.resources.count(); i < l; i++) {
        resources.push(this.resources.items()[i].id);
      }
      json.resources = resources;

      json.location = this.location ? this.location.id : null;
      json.task = this.task ? this.task.id : null;
      json.cssClass = this.cssClass;

      json.visible = this.visible;
      json.tag = this.tag;
      json.priority = this.priority;

      json.reminder = this.reminder ? this.reminder.toJson() : null;

      if (this.recurrenceState == RecurrenceState.Master) {
        json.recurrence = this.recurrence.toJson();
      }
      return json;
    }

    /**
    * Deserializes this item from a JSON string.
    * @param {String} json A string created by the toJson method.
    */

  }, {
    key: 'fromJson',
    value: function fromJson(json, schedule) {

      this._id = json.id;

      this._startTime = new DateTime(new Date(json.startTime));
      this._endTime = new DateTime(new Date(json.endTime));

      this._allowChangeStart = json.allowChangeStart;
      this._allowChangeEnd = json.allowChangeEnd;
      this._allowMove = json.allowMove;
      this._allDayEvent = json.allDayEvent;
      this._locked = json.locked;

      this._subject = json.subject;
      this._details = json.details;

      if (json.location) this._location = schedule.getResourceById(json.location);
      if (json.task) this._task = schedule.getResourceById(json.task);

      this._cssClass = json.cssClass;

      this._contacts = new ObservableCollection();
      if (json.contacts) {
        for (var i = 0, l = json.contacts.length; i < l; i++) {
          var contact = schedule.getResourceById(json.contacts[i]);
          this.contacts.add(contact);
        }
      }

      this._resources = new ObservableCollection();
      if (json.resources) {
        for (var i = 0, l = json.resources.length; i < l; i++) {
          var resource = schedule.getResourceById(json.resources[i]);
          this.resources.add(resource);
        }
      }

      this._visible = json.visible;
      this._tag = json.tag;
      this._priority = json.priority;

      if (json.reminder) {
        this.reminder = new Reminder();
        this.reminder.fromJson(json.reminder);
      }

      // load recurrence
      if (json.recurrence) {
        this.recurrence = new Recurrence();
        this.recurrence.fromJson(json.recurrence, schedule);
      }
    }
  }, {
    key: 'contacts',
    get: function get$$1() {
      return this._contacts;
    }

    /**
     * Gets a list with all resources associated with this item.
     */

  }, {
    key: 'resources',
    get: function get$$1() {
      return this._resources;
    }

    /**
     * Gets or sets the item location.
     */

  }, {
    key: 'location',
    get: function get$$1() {
      return this._location;
    }
    /**
     * @param {Location} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._location === value) return;

      var oldValue = this._location;
      this._location = value;

      this.onPropertyChanged('location', oldValue, value);
      this.markException();
    }

    /**
     * Gets or sets the task associated with this item.
     */

  }, {
    key: 'task',
    get: function get$$1() {
      return this._task;
    }
    /**
     * @param {Task} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._task === value) return;

      var oldValue = this._task;
      this._task = value;

      this.onPropertyChanged('task', oldValue, value);
      this.markException();
    }

    /**
     * Gets or sets the string identifier of this item.
     */

  }, {
    key: 'id',
    get: function get$$1() {
      return this._id;
    }
    /**
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._id === value) return;

      var oldValue = this._id;
      this._id = value;

      this.onPropertyChanged('id', oldValue, value);
      this.markException();
    }

    /**
     * Gets or sets a value indicating whether users are allowed to modify this item.
     */

  }, {
    key: 'locked',
    get: function get$$1() {
      return this._locked;
    }
    /**
     * @param {Boolean} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._locked === value) return;

      var oldValue = this._locked;
      this._locked = value;

      this.onPropertyChanged('locked', oldValue, value);
      this.markException();
    }

    /**
     * Gets or sets the item's scheduled start time.
     */

  }, {
    key: 'startTime',
    get: function get$$1() {
      return this._startTime;
    }
    /**
     * @param {DateTime} value The new property value.
     */
    ,
    set: function set$$1(value) {
      // TODO: remove when DateTime is made immutable
      // if (this._startTime.equals(value))
      //     return;

      var oldValue = this._startTime;

      this._startTime = value;

      this.onPropertyChanged('startTime', oldValue, value);
      this.markException();
    }

    /**
     * Gets or sets the item's scheduled end time.
     */

  }, {
    key: 'endTime',
    get: function get$$1() {
      return this._endTime;
    }
    /**
     * @param {DateTime} value The new property value.
     */
    ,
    set: function set$$1(value) {
      // TODO: remove when DateTime is made immutable
      // if (this._endTime.equals(value))
      //     return;

      var oldValue = this._endTime;

      this._endTime = value;

      this.onPropertyChanged('endTime', oldValue, value);
      this.markException();
    }

    /**
     * Gets or sets a value indicating whether users are allowed to change the item's start time.
     */

  }, {
    key: 'allowChangeStart',
    get: function get$$1() {
      return this._allowChangeStart;
    }
    /**
     * @param {Boolean} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._allowChangeStart === value) return;

      this._allowChangeStart = value;

      this.markException();
    }

    /**
     * Gets or sets a value indicating whether users are allowed to change the item's end time.
     */

  }, {
    key: 'allowChangeEnd',
    get: function get$$1() {
      return this._allowChangeEnd;
    }
    /**
     * @param {Boolean} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._allowChangeEnd === value) return;

      this._allowChangeEnd = value;

      this.markException();
    }

    /**
     * Gets or sets a value indicating whether users are allowed to move the item.
     */

  }, {
    key: 'allowMove',
    get: function get$$1() {
      return this._allowMove;
    }
    /**
     * @param {Boolean} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._allowMove === value) return;

      this._allowMove = value;

      this.markException();
    }

    /**
     * Gets or sets a value indicating whether the item is an all-day event.
     * 
     * All day events are displayed in a special header area when the Calendar displays a timetable view.
     */

  }, {
    key: 'allDayEvent',
    get: function get$$1() {
      return this._allDayEvent;
    }
    /**
     * @param {Boolean} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._allDayEvent === value) return;

      this._allDayEvent = value;

      this.markException();
    }

    /**
     * Gets or sets header text displayed for this item by the calendar control.
     */

  }, {
    key: 'subject',
    get: function get$$1() {
      return this._subject;
    }
    /**
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._subject === value) return;

      var oldValue = this._subject;
      this._subject = value;

      this.onPropertyChanged('subject', oldValue, value);

      this.markException();
    }

    /**
    * Gets or sets header text displayed for this item by the calendar control.
    */

  }, {
    key: 'headerText',
    get: function get$$1() {
      return this._subject;
    }
    /**
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._subject === value) return;

      var oldValue = this._subject;
      this._subject = value;

      this.onPropertyChanged('subject', oldValue, value);

      this.markException();
    }

    /**
     * Gets or sets text with details displayed for this item by the scheduling control.
     */

  }, {
    key: 'details',
    get: function get$$1() {
      return this._details;
    }
    /**
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._details === value) return;

      var oldValue = this._details;
      this._details = value;

      this.onPropertyChanged('details', oldValue, value);

      this.markException();
    }

    /**
     * Gets or sets text with details displayed for this item by the scheduling control.
     */

  }, {
    key: 'descriptionText',
    get: function get$$1() {
      return this._details;
    }
    /**
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._details === value) return;

      var oldValue = this._details;
      this._details = value;

      this.onPropertyChanged('details', oldValue, value);

      this.markException();
    }

    /**
     * Gets or sets the reminder for this item.
     */

  }, {
    key: 'reminder',
    get: function get$$1() {
      // If this is a recurring item, return the master's reminder
      if (this._recurrenceState === RecurrenceState.Occurrence) return this._recurrence.master.reminder;

      return this._reminder;
    }
    /**
     * @param {Reminder} value The new property value.
     */
    ,
    set: function set$$1(value) {
      var _this2 = this;

      var changedReminder = false;

      this._reminder = value;
      if (this._reminder !== this.reminder) changedReminder = true;

      if (this._reminder) this._reminder.changed.addEventListener(function () {
        _this2.onReminderChanged();
      });

      // Changing the reminder causes recurrent items to become exceptions
      if (this._recurrence) {
        if (!changedReminder) this._recurrence.markException(this, false);else this._recurrence.markException(this, false, this._reminder);
      }
    }

    /**
     * Gets or sets the recurrence pattern of this item.
     */

  }, {
    key: 'recurrence',
    get: function get$$1() {
      return this._recurrence;
    }
    /**
     * @param {Recurrence} value The new property value.
     */
    ,
    set: function set$$1(value) {
      var _this3 = this;

      if (!value) this._recurrenceState = RecurrenceState.None;

      if (this._recurrence === value) return;

      // If the item is an occurrence or an exception
      // the recurrence is dispatched to its master
      if (this._recurrenceState === RecurrenceState.Occurrence || this._recurrenceState === RecurrenceState.Exception) {
        this._recurrence.master.recurrence = value;
        return;
      }

      if (this._settingRecurrence) return;

      this._settingRecurrence = true;

      // Remove the currently associated recurrence first
      if (this._recurrence) {
        this._recurrence.associateWith(null);
        this._recurrence.reset.removeEventListener(function () {
          _this3.onRecurrenceReset();
        });
      }

      this._recurrence = value;

      if (this._recurrence) {
        this._recurrence.reset.addEventListener(function () {
          _this3.onRecurrenceReset();
        });
        this._recurrence.associateWith(this);
      }

      // Set the recurrence state of this item
      if (this._recurrence) this._recurrenceState = RecurrenceState.Master;else this._recurrenceState = RecurrenceState.None;

      this.onRecurrenceReset();

      this._settingRecurrence = false;
    }

    /**
     * Gets the recurrence state of this item.
     */

  }, {
    key: 'recurrenceState',
    get: function get$$1() {
      return this._recurrenceState;
    }
    /**
     * @param {RecurrenceState} value The new property value.
     * @package
     */
    ,
    set: function set$$1(value) {
      this._recurrenceState = value;
    }

    /**
     * Gets the index of a repeating occurrence of a recurring item.
     * If the item is not recurring, this property returns -1.
     */

  }, {
    key: 'occurrenceIndex',
    get: function get$$1() {
      return this._occurrenceIndex;
    }
    /**
     * @param {Number} value The new property value.
     * @package
     */
    ,
    set: function set$$1(value) {
      this._occurrenceIndex = value;
    }

    /**
     * Gets or sets the priority of the Item.
     * 
     * Items with higher priority are rendered with preference over items with lower priority.
     */

  }, {
    key: 'priority',
    get: function get$$1() {
      return this._priority;
    }
    /**
     * @param {Number} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._priority = value;
    }

    /**
     * Gets or sets whether the item is visible.
     */

  }, {
    key: 'visible',
    get: function get$$1() {
      return this._visible;
    }
    /**
     * @param {ItemStyle} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._visible === value) return;

      var oldValue = this._visible;
      this._visible = value;

      this.onPropertyChanged('visible', oldValue, value);

      this.markException();
    }

    /**
     * Gets or sets the css class of the item.
     */

  }, {
    key: 'cssClass',
    get: function get$$1() {
      return this._cssClass;
    }
    /**
     * @param {String} value The new property value.
     */
    ,
    set: function set$$1(value) {
      this._cssClass = value;
    }

    /**
     * Gets or sets custom data associated with the item.
     * 
     * Use this property to store your custom data. 
     */

  }, {
    key: 'tag',
    get: function get$$1() {
      return this._tag;
    }
    /**
     * @param {*} value The new property value.
     */
    ,
    set: function set$$1(value) {
      if (this._tag === value) return;

      var oldValue = this._tag;
      this._tag = value;
      this.onPropertyChanged('tag', oldValue, value);

      this.markException();
    }

    /**
     * Raised when the a property of the item is changed.
     */

  }, {
    key: 'propertyChanged',
    get: function get$$1() {
      return this._propertyChangedEvent;
    }

    /**
     * Raised when the recurrence pattern associated with the item has been reset.
     */

  }, {
    key: 'recurrenceReset',
    get: function get$$1() {
      return this._recurrenceResetEvent;
    }

    /**
     * Raised when the item is marked as an exception of a recurrence.
     */

  }, {
    key: 'exceptionCreated',
    get: function get$$1() {
      return this._exceptionCreatedEvent;
    }
  }], [{
    key: 'tm',
    get: function get$$1() {
      return [32, 102, 111, 114, 32, 74, 97, 118, 97, 83, 99, 114, 105, 112, 116, 44, 32, 116, 114, 105, 97, 108, 32, 118, 101, 114, 115, 105, 111, 110];
    }
  }]);
  return Item;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* @class Specifies data for form related events
* @augments CancelEventArgs
* @property {BaseForm} form Gets the form related to the event.
*/
var FormEventArgs = function (_CancelEventArgs) {
	inherits(FormEventArgs, _CancelEventArgs);

	/**
 * Initializes a new instance of the FormEventArgs class.
 * @constructor
 * @param {BaseForm} form The form instance related to the event.
 */
	function FormEventArgs(form) {
		classCallCheck(this, FormEventArgs);

		var _this = possibleConstructorReturn(this, (FormEventArgs.__proto__ || Object.getPrototypeOf(FormEventArgs)).call(this));

		_this._form = form;
		return _this;
	}
	/**
 * Gets the form related to the event.
 * @returns {BaseForm} The BaseForm instance related to the event.
 */


	createClass(FormEventArgs, [{
		key: 'form',
		get: function get$$1() {
			return this._form;
		}
	}]);
	return FormEventArgs;
}(CancelEventArgs);
/**
* @class Specifies data for the ButtonClick event.
* @augments CancelEventArgs
* @property {Number} button Gets a value indicating which navigation button is clicked.
*/
var ButtonEventArgs = function (_CancelEventArgs2) {
	inherits(ButtonEventArgs, _CancelEventArgs2);

	/**
 * Initializes a new instance of the ButtonEventArgs class.
 * @constructor
 * @param {Number} button A value indicating which navigation button is clicked.
 */
	function ButtonEventArgs(button) {
		classCallCheck(this, ButtonEventArgs);

		var _this2 = possibleConstructorReturn(this, (ButtonEventArgs.__proto__ || Object.getPrototypeOf(ButtonEventArgs)).call(this));

		_this2._button = button;
		return _this2;
	}

	createClass(ButtonEventArgs, [{
		key: 'button',
		get: function get$$1() {
			return this._button;
		}
	}]);
	return ButtonEventArgs;
}(CancelEventArgs);

/**
* @class Specifies data for cell related events.
* @augments EventArgs
* @property {ViewCell} cell Gets the calendar view cell related to the event.
*/
var CellEventArgs = function (_EventArgs) {
	inherits(CellEventArgs, _EventArgs);

	/**
 * Initializes a new instance of the CellEventArgs class.
 * @constructor
 * @param {ViewCell} cell The calendar view cell related to the event.
 */
	function CellEventArgs(cell) {
		classCallCheck(this, CellEventArgs);

		var _this3 = possibleConstructorReturn(this, (CellEventArgs.__proto__ || Object.getPrototypeOf(CellEventArgs)).call(this));

		_this3._cell = cell;
		return _this3;
	}
	/**
 * Gets the calendar view cell related to the event.
 * @returns {ViewCell} The ViewCell instance related to the event.
 */


	createClass(CellEventArgs, [{
		key: 'cell',
		get: function get$$1() {
			return this._cell;
		}
	}]);
	return CellEventArgs;
}(EventArgs);

/**
* @class Specifies data for header related events.
* @augments EventArgs
* @property {HeaderType} type Gets the type of the header related to the event.
*/
var HeaderEventArgs = function (_EventArgs2) {
	inherits(HeaderEventArgs, _EventArgs2);

	/**
 * Initializes a new instance of the HeaderEventArgs class.
 * @constructor
 * @param {HeaderType} type The type of the header related to the event.
 */
	function HeaderEventArgs(type) {
		classCallCheck(this, HeaderEventArgs);

		var _this4 = possibleConstructorReturn(this, (HeaderEventArgs.__proto__ || Object.getPrototypeOf(HeaderEventArgs)).call(this));

		_this4._type = type;
		return _this4;
	}
	/**
 * Gets the type of the header related to the event.
 * @returns {HeaderType} One of the HeaderType enumeration values.
 */


	createClass(HeaderEventArgs, [{
		key: 'type',
		get: function get$$1() {
			return this._type;
		}
	}]);
	return HeaderEventArgs;
}(EventArgs);

/**
* @class Specifies data for selection related events.
* @augments CancelEventArgs
* @property {DateTime} startTime Gets the start time of the selection.
* @property {DateTime} endTime Gets the end time of the selection.
* @property {Resource} resource Gets the resource related to the event.
*/
var SelectionEventArgs = function (_CancelEventArgs3) {
	inherits(SelectionEventArgs, _CancelEventArgs3);

	/**
 * Initializes a new instance of the SelectionEventArgs class.
 * @constructor
 * @param {DateTime} startTime The start time of the selection.
 * @param {DateTime} endTime The end time of the selection
 * @param {Resource} resource The resource related to the event.
 */
	function SelectionEventArgs(startTime, endTime, resource) {
		classCallCheck(this, SelectionEventArgs);

		var _this5 = possibleConstructorReturn(this, (SelectionEventArgs.__proto__ || Object.getPrototypeOf(SelectionEventArgs)).call(this));

		_this5._startTime = startTime;
		_this5._endTime = endTime;
		_this5._resource = resource;
		return _this5;
	}
	/**
 * Gets the start time of the selection.
 * @returns {DateTime} The start time of the selection.
 */


	createClass(SelectionEventArgs, [{
		key: 'startTime',
		get: function get$$1() {
			return this._startTime;
		}
		/**
  * Gets the end time of the selection.
  * @returns {DateTime} The end time of the selection.
  */

	}, {
		key: 'endTime',
		get: function get$$1() {
			return this._endTime;
		}
		/**
  * Gets resource related to the event.
  * @returns {Resource} The resource related to the event.
  */

	}, {
		key: 'resource',
		get: function get$$1() {
			return this._resource;
		}
	}]);
	return SelectionEventArgs;
}(CancelEventArgs);

/**
* @class Specifies data for item related events.
* @augments CancelEventArgs
* @property {Item} item Gets the item related to the event.
*/
var ItemEventArgs = function (_CancelEventArgs4) {
	inherits(ItemEventArgs, _CancelEventArgs4);

	/**
 * Initializes a new instance of the ItemEventArgs class.
 * @constructor
 * @param {Item} item The item related to the event.
 */
	function ItemEventArgs(item) {
		classCallCheck(this, ItemEventArgs);

		var _this6 = possibleConstructorReturn(this, (ItemEventArgs.__proto__ || Object.getPrototypeOf(ItemEventArgs)).call(this));

		_this6._item = item;
		return _this6;
	}
	/**
 * Gets the item related to the event.
 * @returns {Item} The item related to the event.
 */


	createClass(ItemEventArgs, [{
		key: 'item',
		get: function get$$1() {
			return this._item;
		}
	}]);
	return ItemEventArgs;
}(CancelEventArgs);

/**
* @class Specifies data for the ItemModifying event.
* @augments CancelEventArgs
* @property {Item} item Gets the item that is modified.
* @property {Object} changes Gets the changed properties of the item, associated with the event.
* @property {ItemModifyAction} action Gets the type of action that is modifying the item.
*/
var ItemModifyingEventArgs = function (_CancelEventArgs5) {
	inherits(ItemModifyingEventArgs, _CancelEventArgs5);

	/**
 * Initializes a new instance of the ItemModifyingEventArgs class.
 * @constructor
 * @param {Item} item The new item.
 * @param {Object} changes An object containing the changed properties.
 * @param {ItemModifyAction} action The action that is modifying the item.
 */
	function ItemModifyingEventArgs(item, changes, action) {
		classCallCheck(this, ItemModifyingEventArgs);

		var _this7 = possibleConstructorReturn(this, (ItemModifyingEventArgs.__proto__ || Object.getPrototypeOf(ItemModifyingEventArgs)).call(this));

		_this7._item = item;
		_this7._changes = changes;
		_this7._action = action;
		return _this7;
	}
	/**
 * Gets the item that is modified.
 * @returns {Item} The item that is modified.
 */


	createClass(ItemModifyingEventArgs, [{
		key: 'item',
		get: function get$$1() {
			return this._item;
		}
		/**
  * Gets the changed properties of the item, associated with the event.
  * @returns {Object} An object containing the changed properties.
  */

	}, {
		key: 'changes',
		get: function get$$1() {
			return this._changes;
		}

		/**
  * Gets the type of action that is modifying the item.
  * @returns {ItemModifyAction} One of the ItemModifyAction enumeration values.
  */

	}, {
		key: 'action',
		get: function get$$1() {
			return this._action;
		}
	}]);
	return ItemModifyingEventArgs;
}(CancelEventArgs);

/**
* @class Specifies data for the ItemModified event.
* @augments EventArgs
* @property {Item} item Gets the item that was modified.
* @property {Item} oldItem Gets the item before the modification has occurred.
* @property {ItemModifyAction} action Gets the type of action that is modifying the item.
*/
var ItemModifiedEventArgs = function (_EventArgs3) {
	inherits(ItemModifiedEventArgs, _EventArgs3);

	/**
 * Initializes a new instance of the ItemModifiedEventArgs class.
 * @constructor
 * @param {Item} item The new item.
 * @param {Item} oldItem The old item.
 * @param {ItemModifyAction} action The action that has modified the item.
 */
	function ItemModifiedEventArgs(item, oldItem, action) {
		classCallCheck(this, ItemModifiedEventArgs);

		var _this8 = possibleConstructorReturn(this, (ItemModifiedEventArgs.__proto__ || Object.getPrototypeOf(ItemModifiedEventArgs)).call(this));

		_this8._item = item;
		_this8._oldItem = oldItem;
		_this8._action = action;
		return _this8;
	}
	/**
 * Gets the item that was modified.
 * @returns {Item} The item that was modified.
 */


	createClass(ItemModifiedEventArgs, [{
		key: 'item',
		get: function get$$1() {
			return this._item;
		}
		/**
  * Gets the item before the modification has occurred.
  * @returns {Item} The item before the modification has occurred.
  */

	}, {
		key: 'oldItem',
		get: function get$$1() {
			return this._oldItem;
		}
		/**
  * Gets the type of action that has modified the item.
  * @returns {ItemModifyAction} One of the ItemModifyAction enumeration values.
  */

	}, {
		key: 'action',
		get: function get$$1() {
			return this._action;
		}
	}]);
	return ItemModifiedEventArgs;
}(EventArgs);

/**
* @class Specifies data for task related events.
* @augments CancelEventArgs
* @property {Task} task Gets the Task instance for which the event is raised.
*/
var TaskEventArgs = function (_CancelEventArgs6) {
	inherits(TaskEventArgs, _CancelEventArgs6);

	/**
 * Initializes a new instance of the TaskEventArgs class.
 * @constructor
 * @param {Task} task The Task instance for which the event is raised.
 */
	function TaskEventArgs(task) {
		classCallCheck(this, TaskEventArgs);

		var _this9 = possibleConstructorReturn(this, (TaskEventArgs.__proto__ || Object.getPrototypeOf(TaskEventArgs)).call(this));

		_this9._task = task;
		return _this9;
	}
	/**
 * Gets the task related to the event.
 * @returns {Task} The Task instance for which the event is raised.
 */


	createClass(TaskEventArgs, [{
		key: 'task',
		get: function get$$1() {
			return this._task;
		}
	}]);
	return TaskEventArgs;
}(CancelEventArgs);

/**
* @class Specifies data for the VisibleDateChanged event.
* @augments EventArgs
* @property {DateTime} newDate Gets the new visible date.
* @property {DateTime} prevDate Gets the previous visible date.
*/
var DateChangedEventArgs = function (_EventArgs4) {
	inherits(DateChangedEventArgs, _EventArgs4);

	/**
 * Initializes a new instance of the DateChangedEventArgs class.
 * @constructor
 * @param {DateTime} newDate The new visible date.
 * @param {DateTime} prevDate The previous visible date.
 */
	function DateChangedEventArgs(newDate, prevDate) {
		classCallCheck(this, DateChangedEventArgs);

		var _this10 = possibleConstructorReturn(this, (DateChangedEventArgs.__proto__ || Object.getPrototypeOf(DateChangedEventArgs)).call(this));

		_this10._newDate = newDate;
		_this10._prevDate = prevDate;
		return _this10;
	}
	/**
 * Gets the new visible date.
 * @returns {DateTime} The  new visible date.
 */


	createClass(DateChangedEventArgs, [{
		key: 'newDate',
		get: function get$$1() {
			return this._newDate;
		}
		/**
  * Gets the previous visible date.
  * @returns {DateTime} The previous visible date.
  */

	}, {
		key: 'prevDate',
		get: function get$$1() {
			return this._prevDate;
		}
	}]);
	return DateChangedEventArgs;
}(EventArgs);

/** 
* @namespace MindFusion.Scheduling
*/

/**
* For internal use only.
* @private
*/
var BaseControl = function () {
    function BaseControl(options, parent) {
        var _this = this;

        classCallCheck(this, BaseControl);

        if (options === null || options === {} || options.id === null || parent === null) return null;

        this.id = options.id;
        this.element = options.element;
        this.initValue = options.initValue;
        this.formatInfo = options.formatInfo || {};

        if (options.events !== null) {
            for (var key in options.events) {
                if (options.events.hasOwnProperty(key)) {
                    this.element.addEventListener(key, options.events[key]);
                }
            }
        }

        this.keyUp = new EventDispatcher();
        this.element.addEventListener("keyup", function (e) {
            return _this.onKeyUp(e);
        });
    }

    /**
    * For internal use only.
    * @private
    */


    createClass(BaseControl, [{
        key: 'getValue',
        value: function getValue() {
            if (this.element.type === "checkbox") return this.element.checked;
            return this.element.value;
        }
        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'isChanged',
        value: function isChanged() {
            return this.initValue !== this.getValue();
        }
        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'clearObject',
        value: function clearObject() {
            //    $clearHandlers(this.element); 
        }
    }, {
        key: 'onKeyUp',
        value: function onKeyUp(e) {
            this.keyUp.raiseEvent(this, e);
        }
    }]);
    return BaseControl;
}();

/**
* For internal use only.
* @private
*/
var EditBox = function () {
    function EditBox(options) {
        classCallCheck(this, EditBox);

        if (options === null || options.id === null || options.parent === null) return;
        // Set id
        this.id = options.id;
        // date, time, numeric
        if (options.type !== null) this.type = options.type;else this.type = "date";
        if (options.initValue !== null) {
            this.initValue = options.initValue;
            this.value = options.initValue;
        } else this.value = "";
        if (this.type !== "numeric") {
            this.isOpen = false;
        }
        if (options.theme !== null && typeof options.theme !== "undefined") {
            this.theme = options.theme;
        }
        this.oldValue = null;
        if (options.width !== null) this.width = options.width;
        this.cssClass = "mfp-edit-box";
        this.parentElement = options.parent;
        if (options.visible === false) this.visible = options.visible;

        this.formatInfo = options.formatInfo;
        this.localInfo = options.localInfo;

        this.timeFormat = this.formatInfo.dateFormats.longTime;
        this.dateFormat = this.formatInfo.dateFormats.shortDate;

        this._textBox = null;
        if (this.type === "numeric") {
            this._buttonUp = null;
            this._buttonDown = null;
            this.minValue = options.minValue || 0;
            this.maxValue = options.maxValue || 999;
            this.increment = options.increment || 1;
            this.maxLength = options.maxLength || 3;
            this.cssClass += " mfp-numeric-box";
            if (options.width === undefined) this.width = "40px";
        } else {
            var testDate = new DateTime(new Date(1970, 11, 30, 12, 12, 12));
            this._buttonDropDown = null;
            this._dropDownList = null;
            if (this.type === "date") {
                this.cssClass += " mfp-date-box";
                this.maxLength = testDate.toString(this.dateFormat, this.formatInfo).length; // 31.12.1999 g.
                if (options.width === undefined) this.width = "100px";
            } else {
                this.maxLength = testDate.toString(this.timeFormat, this.formatInfo).length + 2;
                this.cssClass += " mfp-time-box";
                if (options.width === undefined) this.width = "80px";
            }
        }
        this.element = this.drawControl();
    }

    // Common members


    createClass(EditBox, [{
        key: 'drawControl',
        value: function drawControl() {
            var _this2 = this;

            var element = document.createElement("div");
            element.id = this.id;
            element.className = this.cssClass;

            if (this.visible === false) element.style.display = "none";

            var textBox = document.createElement("input");
            textBox.type = "text";
            textBox.className = "mfp-text-box";
            textBox.value = this._getValueAsText();
            textBox.style.width = this.width;
            textBox.maxLength = this.maxLength;

            textBox.addEventListener("mousedown", function (e) {
                return _this2._onTextBoxMouseDown(e);
            });
            textBox.addEventListener("focus", function (e) {
                return _this2._onTextBoxFocus(e);
            });
            textBox.addEventListener("blur", function (e) {
                return _this2._onTextBoxBlur(e);
            });
            textBox.addEventListener("change", function (e) {
                return _this2._onTextBoxChanged(e);
            });
            //  textBox.addEventListener("keydown", e => this._onKeyDown(e));
            textBox.addEventListener("keyup", function (e) {
                return _this2._onKeyUp(e);
            });

            var b;

            if (this.type !== "numeric") {
                element.appendChild(textBox);
                this._textBox = textBox;

                var button = document.createElement("a");
                button.className = "mfp-dropdown-button";
                b = document.createElement("i");
                button.appendChild(b);
                button.addEventListener("mousedown", function (e) {
                    return _this2._onButtonMouseDown(e);
                });
                button.addEventListener("mouseup", function (e) {
                    return _this2._onButtonMouseUp(e);
                });
                element.appendChild(button);
                this._buttonDropDown = button;
            } else {
                var table = document.createElement("table");
                table.cellPadding = 0;
                table.cellSpacing = 0;

                var tr1 = document.createElement("tr");
                table.appendChild(tr1);
                var td1 = document.createElement("td");
                td1.rowSpan = 2;
                tr1.appendChild(td1);
                var td2 = document.createElement("td");
                tr1.appendChild(td2);

                var tr2 = document.createElement("tr");
                table.appendChild(tr2);
                var td3 = document.createElement("td");
                tr2.appendChild(td3);

                td1.appendChild(textBox);
                this._textBox = textBox;

                var upButton = document.createElement("a");
                b = document.createElement("i");
                upButton.appendChild(b);
                upButton.className = "mfp-buttonup";
                upButton.addEventListener("mousedown", function (e) {
                    return _this2._onButtonUpMouseDown(e);
                });
                td2.appendChild(upButton);
                this._buttonUp = upButton;

                var downButton = document.createElement("a");
                b = document.createElement("i");
                downButton.appendChild(b);
                downButton.className = "mfp-buttondown";
                downButton.addEventListener("mousedown", function (e) {
                    return _this2._onButtonDownMouseDown(e);
                });
                td3.appendChild(downButton);
                this._buttonDown = downButton;

                element.appendChild(table);
            }
            return element;
        }
    }, {
        key: '_onKeyUp',
        value: function _onKeyUp(e) {
            if (e.keyCode === 13) {
                e.stopPropagation();
                e.target.blur();
                return false;
            }
        }
    }, {
        key: '_onKeyDown',
        value: function _onKeyDown(e) {
            if (e.keyCode === 13) {
                e.preventDefault();
                return false;
            }
        }
    }, {
        key: 'showDateView',
        value: function showDateView() {
            this.dropDown = this.createDateView();
            var textloc = { x: this._textBox.offsetLeft, y: this._textBox.offsetTop };
            var style = this.dropDown.style;
            style.left = textloc.x + "px";
            style.top = textloc.y + this._textBox.offsetHeight + "px";
            this.parentElement.appendChild(this.dropDown);
            this.isOpen = true;
        }
    }, {
        key: 'showTimeView',
        value: function showTimeView() {
            this.dropDown = this.createTimesView();
            var textloc = { x: this._textBox.offsetLeft, y: this._textBox.offsetTop };
            var style = this.dropDown.style;
            style.left = textloc.x + "px";
            style.top = textloc.y + this._textBox.offsetHeight + "px";
            this.parentElement.appendChild(this.dropDown);
            this.isOpen = true;
        }
    }, {
        key: '_getValueAsText',
        value: function _getValueAsText() {
            var type = this.type;
            if (type === "numeric") return this.value.toString();
            if (type === "date") {
                return this.value.toString(this.dateFormat, this.formatInfo);
            }
            if (type === "time") return this.value.toString(this.timeFormat, this.formatInfo);
            return "";
        }
    }, {
        key: 'getValue',
        value: function getValue() {
            var type = this.type;
            if (type === "numeric") return this._textBox.value;
            if (type === "date") return this.value;
            if (type === "time") return this.value;
            return null;
        }
    }, {
        key: '_updateValue',
        value: function _updateValue(newValue /*ms for date&time, number for numeric*/) {
            switch (this.type) {
                case "date":
                case "time":
                default:
                    var format = this.type === "date" ? this.dateFormat : this.timeFormat;

                    this.oldValue = this.value.toString(format);
                    this.value = new DateTime(new Date(newValue));
                    this._textBox.value = this._getValueAsText();
                    /* var check = this.type === "date";
                     var format = check ? this.dateFormat : this.timeFormat;
                     if (check) {
                         var oldValue = new Date(DateTime.getDateToFormat(this.oldValue, format, this.culture)).setHours(0, 0, 0, 0).valueOf();
                     }
                     else {
                         var oldValue = new Date(DateTime.getDateToFormat(this.oldValue, format, this.culture)).valueOf();
                     }
                     if (oldValue !== newValue) {
                         var value = this.value;
                         this.oldValue = this.value.toString(format);
                         this.value = new DateTime(new Date(newValue));
                         this._textBox.value = this._getValueAsText();
                     }*/
                    break;
                case "numeric":
                    if (newValue >= this.minValue && newValue <= this.maxValue) {
                        this.oldValue = this.value;
                        this.value = newValue;
                        this._textBox.value = this._getValueAsText();
                    }
                    break;
            }
        }
    }, {
        key: 'validateNumericInput',
        value: function validateNumericInput(input) {
            if (this.type !== "numeric") {
                return true;
            }
            var regExp = /^\d{1,3}$/;
            return regExp.test(input);
        }
    }, {
        key: 'clearObject',
        value: function clearObject() {
            //  $clearHandlers(this._textBox);
            //  if (this._buttonDropDown !== null) $clearHandlers(this._buttonDropDown);
            //   if (this._buttonUp !== null) $clearHandlers(this._buttonUp);
            //   if (this._buttonDown !== null) $clearHandlers(this._buttonDown);
            this._closeDropDown();
        }
    }, {
        key: '_closeDropDown',
        value: function _closeDropDown() {
            if (this.dropDown !== null) {
                this.parentElement.removeChild(this.dropDown);
                this.dropDown = null;
                this.isOpen = false;
            }
        }
    }, {
        key: 'isInt',
        value: function isInt(x) {
            var y = parseInt(x, 10);
            if (isNaN(y)) return false;
            return x === y && x.toString() === y.toString();
        }
    }, {
        key: '_onButtonUpMouseDown',
        value: function _onButtonUpMouseDown(e) {
            var elementValue = parseInt(this._textBox.value, 10);
            if (elementValue + this.increment <= this.maxValue) {
                this._textBox.value = elementValue + this.increment;
                e.stopPropagation();
                return true;
            }
        }
    }, {
        key: '_onButtonDownMouseDown',
        value: function _onButtonDownMouseDown(e) {
            var elementValue = parseInt(this._textBox.value);
            if (elementValue - this.increment >= this.minValue) {
                this._textBox.value = elementValue - this.increment;
                e.stopPropagation();
                return true;
            }
        }
    }, {
        key: 'onBlur',
        value: function onBlur(e) {
            if (e.target.getAttribute('class') === 'mfp-dropdown-button') {
                return;
            } else if (this.isOpen === true) {
                var tv = DomUtils.getParent(e.target, "mfp-dtpicker");
                if (tv !== undefined) {
                    return true;
                }
                this._closeDropDown();
            }
        }
    }, {
        key: '_onTextBoxMouseDown',
        value: function _onTextBoxMouseDown(e) {
            e.stopPropagation();
        }
    }, {
        key: '_onTextBoxFocus',
        value: function _onTextBoxFocus(e) {
            this.oldValue = e.target.value;
        }
    }, {
        key: '_onTextBoxBlur',
        value: function _onTextBoxBlur(e) {
            if (this.type === "date" && DateTime.getDateToFormat(e.target.value, this.dateFormat, this.formatInfo) === 0 || this.type === "time" && DateTime.getDateToFormat(e.target.value, this.timeFormat, this.formatInfo) === 0 || this.type === "numeric" && !this.validateNumericInput(e.target.value) || +e.target.value < this.minValue || +e.target.value > this.maxValue) {
                this._textBox.value = this.oldValue;
            }
        }
    }, {
        key: '_onTextBoxChanged',
        value: function _onTextBoxChanged(e) {
            var newValue = e.target.value;
            var val = 0;
            switch (this.type) {
                case "date":
                    val = DateTime.getDateToFormat(newValue, this.dateFormat, this.formatInfo);
                    if (val > 0) {
                        val = new Date(val).setHours(0, 0, 0, 0).valueOf();
                        this._updateValue(val);
                    }
                    break;
                case "time":
                    val = DateTime.getDateToFormat(newValue, this.timeFormat, this.formatInfo);
                    if (val > 0) {
                        this._updateValue(val);
                    }
                    break;
                case "numeric":
                    val = +newValue;
                    if (val) {
                        this._updateValue(val);
                    }
                    break;
            }
        }
    }, {
        key: '_onButtonMouseDown',
        value: function _onButtonMouseDown(e) {
            this.buttonClicked = true;
        }
    }, {
        key: '_onButtonMouseUp',
        value: function _onButtonMouseUp(e) {
            if (this.type === "date") {
                if (this.dropDown == null) this.showDateView();else this._closeDropDown();
            } else {
                if (this.dropDown == null) this.showTimeView();else this._closeDropDown();
            }
            this.buttonClicked = false;
            this._textBox.focus();
        }

        // Time view

    }, {
        key: 'createTimesView',
        value: function createTimesView() {
            var _this3 = this;

            this.parentElement.addEventListener("mousedown", function (e) {
                return _this3.onBlur(e);
            });

            var view = document.createElement("div");
            view.className = "mfp-dtpicker";

            var table = document.createElement("table");
            table.cellSpacing = 0;
            table.cellPadding = 0;
            table.className = "mfp-dtpicker-content";

            var row = null;
            var currentval = this.value.toString(this.timeFormat, this.formatInfo);
            var start = new DateTime(new Date(0, 0, 0, 0, 0, 0, 0));
            var text = "",
                textVal = "";
            var a = null,
                cellClass = null;
            for (var i = 0; i < 8; i++) {
                row = document.createElement("tr");
                for (var k = 0; k < 3; k++) {
                    cellClass = '';
                    text = start.toString(this.formatInfo.dateFormats.shortTime, this.formatInfo).toLowerCase();
                    textVal = start.toString(this.timeFormat, this.formatInfo);
                    if (textVal === currentval) cellClass = "mfp-dtp-selected";
                    var cell = document.createElement("td");
                    cell.className = cellClass;
                    cell.title = textVal;
                    cell.innerHTML = text;
                    cell.addEventListener("click", function (e) {
                        return _this3.onTimeCellClick(e);
                    });
                    row.appendChild(cell);
                    start.addHours(1);
                }
                table.appendChild(row);
            }
            view.appendChild(table);
            return view;
        }
    }, {
        key: 'onTimeCellClick',
        value: function onTimeCellClick(e) {
            this._updateValue(DateTime.getDateToFormat(e.target.getAttribute("title"), this.timeFormat, this.formatInfo));
            this._closeDropDown();
        }

        // Date view

    }, {
        key: 'createDateView',
        value: function createDateView() {
            var _this4 = this;

            this.parentElement.addEventListener("mousedown", function (e) {
                return _this4.onBlur(e);
            });

            // Current view properties
            this.currentView = {};
            this.currentView.view = null;
            this.currentView.type = 0; // calendar single month view
            this.currentView.header = null;
            this.currentView.titleCell = null;
            this.currentView.content = null;
            this.currentView.DaysTable = null;
            this.currentView.MonthsTable = null;
            this.currentView.YearsTable = null;

            var start = new Date(this.value._date.getTime());
            start.setHours(12, 0, 0, 0);
            this.currentView.currentDate = new Date(start.getTime());
            this.currentView.selectedCell = null;

            var view = document.createElement("div");
            view.className = "mfp-dtpicker";
            this.currentView.view = view;

            var h = document.createElement("div");
            h.className = "mfp-dtpicker-header";
            this.currentView.view.appendChild(h);
            this.currentView.header = h;
            this.createCalendarHeader();

            var c = document.createElement("div");
            this.currentView.view.appendChild(c);
            this.currentView.content = c;
            this.createCalendarContent();

            var f = document.createElement("div");
            f.className = "mfp-dtpicker-footer";
            this.currentView.view.appendChild(f);
            this.currentView.footer = f;
            this.createTodayButton();

            return this.currentView.view;
        }
    }, {
        key: 'createCalendarHeader',
        value: function createCalendarHeader() {
            var _this5 = this;

            this.currentView.header.innerHTML = "";

            var h = this.currentView.header;

            var cell = document.createElement("div");
            DomUtils.addCssClass(cell, "button");
            cell.innerHTML = '&#x00ab;';
            if (this.currentView.type === 0) {
                h.appendChild(cell);
                cell.addEventListener("click", function (e) {
                    return _this5.onCalendarPreviousYearClick(e);
                });
            }
            cell = document.createElement("div");
            DomUtils.addCssClass(cell, "button");
            cell.innerHTML = '&#x2039;';
            h.appendChild(cell);
            cell.addEventListener("click", function (e) {
                return _this5.onCalendarPreviousMonthClick(e);
            });

            cell = document.createElement("div");
            DomUtils.addCssClass(cell, "button");
            DomUtils.addCssClass(cell, "title");
            this.currentView.titleCell = cell;
            this.setCalendarHeaderText();
            h.appendChild(cell);
            cell.addEventListener("click", function (e) {
                return _this5.onCalendarTitleClick(e);
            });

            cell = document.createElement("div");
            DomUtils.addCssClass(cell, "button");
            cell.innerHTML = '&#x203a;';
            h.appendChild(cell);
            cell.addEventListener("click", function (e) {
                return _this5.onCalendarNextMonthClick(e);
            });

            cell = document.createElement("div");
            DomUtils.addCssClass(cell, "button");
            cell.innerHTML = '&#x00bb;';
            if (this.currentView.type === 0) {
                h.appendChild(cell);
                cell.addEventListener("click", function (e) {
                    return _this5.onCalendarNextYearClick(e);
                });
            }
        }
    }, {
        key: 'setCalendarHeaderText',
        value: function setCalendarHeaderText() {
            if (this.currentView.titleCell) {
                var date = new Date(this.currentView.currentDate.getTime());
                switch (this.currentView.type) {
                    case 1:
                        this.currentView.titleCell.innerHTML = date.getFullYear();
                        break;
                    case 2:
                        this.currentView.titleCell.innerHTML = date.getFullYear() + ' - ' + (date.getFullYear() + 9);
                        break;
                    default:
                        this.currentView.titleCell.innerHTML = DateTime.formatDate(date, this.formatInfo.dateFormats.yearMonth, this.formatInfo);
                        break;
                }
            }
        }
    }, {
        key: 'createCalendarContent',
        value: function createCalendarContent() {
            var _this6 = this;

            // Remove Content of calendar
            if (this.currentView.DaysTable) {
                DomUtils.removeNode(this.currentView.DaysTable, this.currentView.content);
                this.currentView.DaysTable = null;
            }
            if (this.currentView.MonthsTable) {
                DomUtils.removeNode(this.currentView.MonthsTable, this.currentView.content);
                this.currentView.MonthsTable = null;
            }
            if (this.currentView.YearsTable) {
                DomUtils.removeNode(this.currentView.YearsTable, this.currentView.content);
                this.currentView.YearsTable = null;
            }

            var today = new Date();
            today.setHours(12, 0, 0, 0);
            var start = new Date(this.currentView.currentDate.getTime());

            // All Years View
            var table = document.createElement("table");
            table.cellSpacing = 0;
            table.cellPadding = 0;
            table.className = "mfp-dtpicker-content";

            this.currentView.content.appendChild(table);
            this.currentView.YearsTable = table;
            // tbody of the table
            var tbody = document.createElement("tbody");
            table.appendChild(tbody);

            var year = start.getFullYear() - 1;
            for (var rowIndex = 0; rowIndex < 3; rowIndex++) {
                var row = document.createElement("tr");
                for (var columnIndex = 0; columnIndex < 4; columnIndex++) {
                    var cell = document.createElement("td");
                    cell.className = "mfp-yearmonth";

                    if (rowIndex === 0 && columnIndex === 0 || rowIndex === 2 && columnIndex === 3) cell.className = 'mfp-dtp-padding';
                    if (start.getFullYear() === year) {
                        DomUtils.addCssClass(cell, 'mfp-dtp-selected');
                    }
                    row.appendChild(cell);
                    if (year >= 1970) {
                        cell.innerHTML = year;
                        cell.setAttribute('_dateValue', year);
                        cell.addEventListener("click", function (e) {
                            return _this6.onCalendarCellClick(e);
                        });
                    } else {
                        cell.innerHTML = ' ';
                        cell.setAttribute('_dateValue', -1);
                    }
                    year += 1;
                }
                tbody.appendChild(row);
            }
            table.style.display = 'none';

            // All Months View
            var table = document.createElement("table");
            table.cellPadding = 0;
            table.cellSpacing = 0;
            table.className = "mfp-dtpicker-content";
            this.currentView.content.appendChild(table);
            this.currentView.MonthsTable = table;
            // tbody of the table
            tbody = document.createElement("tbody");
            table.appendChild(tbody);

            var month = 0;
            for (var rowIndex = 0; rowIndex < 3; rowIndex++) {
                row = document.createElement("tr");
                for (var columnIndex = 0; columnIndex < 4; columnIndex++) {
                    cell = document.createElement("td");
                    cell.className = "mfp-yearmonth";
                    if (start.getMonth() === month) {
                        DomUtils.addCssClass(cell, 'mfp-dtp-selected');
                    }
                    cell.innerHTML = this.formatInfo.months.short[month];
                    cell.setAttribute('_dateValue', month);
                    row.appendChild(cell);
                    cell.addEventListener("click", function (e) {
                        return _this6.onCalendarCellClick(e);
                    });
                    cell.addEventListener("dbclick", function (e) {
                        return _this6.onCalendarCellClick(e);
                    });
                    month += 1;
                }
                tbody.appendChild(row);
            }

            table.style.display = 'none';

            // Month Days View
            table = document.createElement("table");
            table.cellPadding = 0;
            table.cellSpacing = 0;
            table.className = "mfp-dtpicker-content";
            this.currentView.content.appendChild(table);
            this.currentView.DaysTable = table;

            row = document.createElement("tr");

            this.currentView.selectedDate = this.value._date;
            var selectedDate = this.currentView.selectedDate;
            var start = this.currentView.selectedDate;
            var DAY_TICKS = 24 * 60 * 60 * 1000;
            var firstVisibleDate = new Date(start.getTime());
            firstVisibleDate.setDate(1);
            firstVisibleDate.setHours(12, 0, 0, 0);
            while (firstVisibleDate.getDay() !== +this.formatInfo.firstDayOfWeek) {
                firstVisibleDate.setTime(firstVisibleDate.getTime() - DAY_TICKS);
            }
            var tempDate = new Date(firstVisibleDate.getTime());
            tempDate.setHours(12, 0, 0, 0);
            // Create Week Day Names
            for (var i = +this.formatInfo.firstDayOfWeek, l = i + 7; i < l; i++) {
                //var cellClass = 'cell';
                var th = document.createElement("th");
                //th.className = cellClass;
                th.innerHTML = this.formatInfo.days.short[i % 7];
                row.appendChild(th);
                table.appendChild(row);
            }
            for (var rowIndex = 0; rowIndex < 6; rowIndex++) {
                var row = document.createElement("tr");
                for (var columnIndex = 0; columnIndex < 7; columnIndex++) {
                    var cellClass = '';

                    if (tempDate.getMonth() === start.getMonth()) {
                        if (tempDate.getFullYear() === today.getFullYear() && tempDate.getMonth() === today.getMonth() && tempDate.getDate() === today.getDate()) cellClass = 'mfp-dtp-today';else cellClass = ''; //'cell';
                        if (tempDate.getFullYear() === selectedDate.getFullYear() && tempDate.getMonth() === selectedDate.getMonth() && tempDate.getDate() === selectedDate.getDate()) {
                            cellClass = 'mfp-dtp-selected';
                        }
                    } else cellClass = 'mfp-dtp-padding';

                    if (tempDate.valueOf() >= 0) {
                        var cell = document.createElement("td");
                        cell.className = cellClass;
                        cell.innerHTML = tempDate.getDate();
                        cell.setAttribute('_dateValue', tempDate.valueOf());
                        cell.addEventListener("click", function (e) {
                            return _this6.onCalendarCellClick(e);
                        });
                        row.appendChild(cell);
                    } else {
                        var td = document.createElement("td");
                        td.className = cellClass;
                        row.appendChild(td);
                    }
                    tempDate.setTime(tempDate.getTime() + DAY_TICKS);
                }
                table.appendChild(row);
            }
        }
    }, {
        key: 'createTodayButton',
        value: function createTodayButton() {
            var _this7 = this;

            var d = document.createElement("div");
            d.className = "mfp-button";
            var today = new Date();
            today.setHours(12, 0, 0, 0);
            d.innerHTML = String.format('{0}: ', this.localInfo.todayCaption) + DateTime.formatDate(today, this.formatInfo.dateFormats.longDate, this.formatInfo);
            this.currentView.footer.appendChild(d);
            d.addEventListener("click", function (e) {
                return _this7.onCalendarTodayButtonClick(e);
            });
        }
    }, {
        key: 'changeCalendarView',
        value: function changeCalendarView() {
            if (this.currentView.content) {
                // change header text
                this.createCalendarHeader();
                switch (this.currentView.type) {
                    case 1:
                        this.currentView.DaysTable.style.display = 'none';
                        this.currentView.MonthsTable.style.display = 'table';
                        this.currentView.YearsTable.style.display = 'none';
                        break;
                    case 2:
                        this.currentView.DaysTable.style.display = 'none';
                        this.currentView.MonthsTable.style.display = 'none';
                        this.currentView.YearsTable.style.display = 'table';
                        break;
                    default:
                        this.currentView.DaysTable.style.display = '';
                        this.currentView.MonthsTable.style.display = 'none';
                        this.currentView.YearsTable.style.display = 'none';
                        break;
                }
            }
        }
    }, {
        key: 'onCalendarMouseDown',
        value: function onCalendarMouseDown(e) {
            this.calendarClicked = true;
        }
    }, {
        key: 'onCalendarTodayButtonClick',
        value: function onCalendarTodayButtonClick(e) {
            this.currentView.currentDate = new Date();
            this.currentView.currentDate.setHours(12, 0, 0, 0);
            this._updateValue(this.currentView.currentDate);

            this.currentView.type = 0;
            this.setCalendarHeaderText();
            this.createCalendarContent();
            this.changeCalendarView();
        }
    }, {
        key: 'onCalendarPreviousYearClick',
        value: function onCalendarPreviousYearClick(e) {
            if (this.currentView.currentDate.getFullYear() - 1 < 1970) {
                e.stopPropagation();
                return false;
            }
            this.currentView.currentDate.setFullYear(this.currentView.currentDate.getFullYear() - 1);
            this.value._date = this.currentView.currentDate;
            this.setCalendarHeaderText();
            this.createCalendarContent();
            this.changeCalendarView();
        }
    }, {
        key: 'onCalendarPreviousMonthClick',
        value: function onCalendarPreviousMonthClick(e) {
            switch (this.currentView.type) {
                case 1:
                    if (this.currentView.currentDate.getFullYear() - 1 < 1970) {
                        e.stopPropagation();
                        return false;
                    }
                    this.currentView.currentDate.setFullYear(this.currentView.currentDate.getFullYear() - 1);
                    break;
                case 2:
                    if (this.currentView.currentDate.getFullYear() - 10 < 1970) {
                        e.stopPropagation();
                        return false;
                    }
                    this.currentView.currentDate.setFullYear(this.currentView.currentDate.getFullYear() - 10);
                    break;
                default:
                    var tempDate = new Date(this.currentView.currentDate.getTime());
                    tempDate.setMonth(tempDate.getMonth() - 1);
                    if (tempDate.getFullYear() < 1970) {
                        e.stopPropagation();
                        return false;
                    }
                    this.currentView.currentDate.setMonth(this.currentView.currentDate.getMonth() - 1);
                    break;
            }
            this.value._date = this.currentView.currentDate;
            this.setCalendarHeaderText();
            this.createCalendarContent();
            this.changeCalendarView();
        }
    }, {
        key: 'onCalendarNextMonthClick',
        value: function onCalendarNextMonthClick(e) {

            switch (this.currentView.type) {
                case 1:
                    this.currentView.currentDate.setFullYear(this.currentView.currentDate.getFullYear() + 1);
                    break;
                case 2:
                    this.currentView.currentDate.setFullYear(this.currentView.currentDate.getFullYear() + 10);
                    break;
                default:
                    this.currentView.currentDate.setMonth(this.currentView.currentDate.getMonth() + 1);
                    break;
            }
            this.value._date = this.currentView.currentDate;
            this.setCalendarHeaderText();
            this.createCalendarContent();
            this.changeCalendarView();
        }
    }, {
        key: 'onCalendarNextYearClick',
        value: function onCalendarNextYearClick(e) {
            this.currentView.currentDate.setFullYear(this.currentView.currentDate.getFullYear() + 1);
            this.value._date = this.currentView.currentDate;
            this.setCalendarHeaderText();
            this.createCalendarContent();
            this.changeCalendarView();
        }
    }, {
        key: 'onCalendarTitleClick',
        value: function onCalendarTitleClick(e) {
            e.stopPropagation();
            // Sets to Months view
            if (this.currentView.type === 0) {
                this.currentView.type = 1;
                this.createCalendarContent();
                this.changeCalendarView();
            }
            // Sets to Years view
            else {
                    if (this.currentView.type === 1) {
                        this.currentView.type = 2;
                        this.createCalendarContent();
                        this.changeCalendarView();
                    }
                }
        }
    }, {
        key: 'onCalendarCellClick',
        value: function onCalendarCellClick(e) {
            e.stopPropagation();

            if (this.currentView.type === 0) {
                if (this.currentView.selectedCell !== null) {
                    DomUtils.removeCssClass(this.currentView.selectedCell, 'mfp-dtp-selected');
                    this.currentView.selectedCell = e.target;
                    DomUtils.addCssClass(this.currentView.selectedCell, 'mfp-dtp-selected');
                }
                var cellDate = +e.target.getAttribute('_dateValue');
                this._updateValue(cellDate);
                this._closeDropDown();
            }
            // Sets to Months view
            if (this.currentView.type === 1) {
                this.currentView.type = 0;
                this.currentView.currentDate.setMonth(e.target.getAttribute('_dateValue'));
                this._updateValue(this.currentView.currentDate);
                this.createCalendarContent();
                this.changeCalendarView();
            }
            // Sets to Years view
            else {
                    if (this.currentView.type === 2) {
                        this.currentView.type = 1;
                        if (e.target.getAttribute('_dateValue')) this.currentView.currentDate.setFullYear(e.target.getAttribute('_dateValue'));
                        this._updateValue(this.currentView.currentDate);
                        this.createCalendarContent();
                        this.changeCalendarView();
                    }
                }
        }
    }]);
    return EditBox;
}();

/**
* For internal use only.
* @private
*/
var CheckBoxList = function () {
    function CheckBoxList(options) {
        classCallCheck(this, CheckBoxList);

        if (options == null || options.id == null) return;else this.id = options.id;

        this.items = [];
        this.selectedValues = [];
        this.width = null;
        this.height = null;
        this.cssClass = "mfp-checkbox-list";
        this.groupName = this.id + "_GroupName1";
        this.element = null;

        if (options.width != null) this.width = options.width;
        if (options.height != null) this.height = options.height;
        if (options.cssClass != null) this.cssClass += " " + options.cssClass;
        if (options.groupName != null) this.groupName = options.groupName;
        if (options.items != null) this.items = options.items;
        if (options.selectedValues != null) this.selectedValues = options.selectedValues;

        this.drawControl();
    }

    /**
          * For internal use only.
          * @private
          */


    createClass(CheckBoxList, [{
        key: 'isChecked',
        value: function isChecked(val) {
            var vals = this.selectedValues;
            if (vals !== null && vals.length > 0) {
                for (var i = 0, l = vals.length; i < l; i++) {
                    if (val === vals[i]) return true;
                }
            }
            return false;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'drawControl',
        value: function drawControl() {
            var element = document.createElement("div");
            element.id = this.id;
            element.className = this.cssClass;

            var content = document.createElement("div");

            this.drawItems(content);
            element.appendChild(content);

            if (this.width !== undefined) element.style.width = this.width + "px";
            if (this.height !== undefined) element.style.height = this.height + "px";

            this.element = element;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'drawItems',
        value: function drawItems(content) {
            var items = this.items;
            if (items === null || items.length === 0) return;

            var item = null,
                itemId = "";
            var cb = null,
                row = null;

            for (var i = 0, l = items.length; i < l; i++) {
                item = items[i];
                itemId = this.id + "_item" + i;

                var row = document.createElement("div");
                row.className = "mfp-checkbox-item";

                //  var cb = document.createElement("input");
                // cb.id = itemId;
                //  cb.value = item.value; does not wok in IE11
                // cb.type = "checkbox";
                // cb.className = "check-box";
                //row.appendChild(cb);

                var html = '<input id="{0}" value="{1}" name="{2}" type="checkbox" class="mfp-check-box" />';
                row.innerHTML = String.format(html, itemId, item.value, this.groupName);
                var cb = row.childNodes[0];

                var label = document.createElement("label");
                label.for = this.groupName;
                label.innerHTML = item.text;
                row.appendChild(label);

                cb.checked = this.isChecked(cb.value);
                item.checked = cb.checked;
                content.appendChild(row);
            }
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getSelected',
        value: function getSelected() {
            var result = [];
            var c = this.element.querySelectorAll("input.mfp-check-box");

            if (c.length > 0) {
                var result = [];
                for (var i = 0, l = c.length; i < l; i++) {
                    if (c[i].checked) result.push(c[i].value);
                }
            }
            return result;
        }
    }]);
    return CheckBoxList;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
* @class The BaseForm class is the base class for all built-in forms.
* @property {String} id Gets the id of the form.
* @property {String} type Gets the type of the form.
* @property {String} headerText Gets or sets the text which is displayed in the header of the form.	
* @property {Object} formatInfo Gets the locale object used to format and display date and time information in the form.
* @property {Object} localInfo Gets the locale object used to format and display localizable strings in the form.
*/
var BaseForm = function () {
    /**
    * Initializes a new instance of the BaseForm class.
     * @param {Calendar} calendar The calendar parent object of this form.
     * @param {Item} item The item instance associated with this form.
     * @constructor
    */
    function BaseForm(calendar, item) {
        var _this = this;

        classCallCheck(this, BaseForm);

        this.calendar = calendar;

        this.item = item;
        this._id = "Base";
        this._headerText = "BasePopup";
        this.dragging = false;
        this.dragOffset = null;
        this.parentBounds = null;
        this.dimensions = null;

        this._controls = new Dictionary();
        this.elementId = IdGenerator.generate('popup');

        this.mouseMoveHandler = function (e) {
            return _this.onMouseMove(e);
        };
        this.mouseUpHandler = function (e) {
            return _this.onMouseUp(e);
        };
    }

    /**
    * For internal use only.
    * @private
    */


    createClass(BaseForm, [{
        key: 'willFitParentBounds',
        value: function willFitParentBounds(parent, child) {
            var c = DomUtils.getBounds(child);
            var p = DomUtils.getBounds(parent);
            return p.width >= c.width && p.height >= c.height;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'checkBounds',
        value: function checkBounds(parent, child, checkXY) {
            var left = child.x;
            var top = child.y;
            var offsetX = 0;
            var offsetY = 0;

            if (checkXY === true) {
                offsetX = parent.x;
                offsetY = parent.y;
            }

            if (left < offsetX) left = offsetX;
            if (left + child.width >= offsetX + parent.width) left = offsetX + parent.width - child.width;
            if (top < offsetY) top = offsetY;
            if (top + child.height >= offsetY + parent.height) top = offsetY + parent.height - child.height;
            return { x: left < 0 ? 0 : left, y: top < 0 ? 0 : top };
        }

        /**
        * Renders a row element.
        */

    }, {
        key: 'row',
        value: function row() {
            var r = document.createElement("div");
            r.className = "mfp-popup-row";
            return r;
        }

        /**
        * Renders a column element.
        */

    }, {
        key: 'col',
        value: function col() {
            var r = document.createElement("div");
            r.className = "mfp-popup-column";
            return r;
        }

        /**
        * Renders a horizontal line divider.
        */

    }, {
        key: 'divider',
        value: function divider() {
            var l = document.createElement("div");
            l.className = "mfp-hr-line";
            return l;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: '_getContacts',
        value: function _getContacts() {
            var result = [];
            this.calendar.schedule.contacts.forEach(function (l, i) {
                result.push({ value: i, text: l.toString() });
            }, this);
            return result;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: '_getLocations',
        value: function _getLocations() {
            var result = [];
            this.calendar.schedule.locations.forEach(function (l, i) {
                result.push({ value: i, text: l.toString() });
            }, this);
            return result;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getChanges',
        value: function getChanges() {
            return null;
        }

        /**
        * Returns the controls collection.
        * @returns {Dictionary} A dictionary, containing references to all controls present in the form.
        */

    }, {
        key: 'getControls',
        value: function getControls() {
            return this._controls;
        }

        /**
        * Adds the specified control to the collection of controls.
        * @param {Object} control The control to add.
        */

    }, {
        key: 'addControl',
        value: function addControl(control) {
            if (control == null || control.id == null) return;
            this._controls[control.id] = control;
        }

        /**
        * Removes the specified control from the collection of controls.
        * @param {Object} control The control to remove.
        */

    }, {
        key: 'removeControl',
        value: function removeControl(control) {
            if (control == null || control.id == null) return;
            //   if (control.element != null) $clearHandlers(control.element);
            this._controls[control.id] = null;
        }

        /**
        * Clears all items from the collection of controls.   
        */

    }, {
        key: 'clearControls',
        value: function clearControls() {
            var controls = this._controls;
            if (controls.count > 0) {
                var control = null;
                for (var c in controls) {
                    if (controls[c]) {
                        control = controls[c];
                        if (control.clearObject != null) control.clearObject();
                        this.removeControl(control);
                    }
                }
            }
        }

        /**
        * Gets the value of the control with the specified id.
        * @param {String} controlId The id of the control to check.
        * @returns {Object} The value of the control.
        */

    }, {
        key: 'getControlValue',
        value: function getControlValue(controlId) {
            var control = this._controls[controlId];
            if (control == null) return "";
            return control.getValue();
        }

        /**
        * Renders the form.
        */

    }, {
        key: 'showForm',
        value: function showForm() {

            var parentElement = this.calendar.getElement().children[0];
            if (parentElement == null) return;
            this.parentElement = parentElement;

            this.closeForm(this.id);

            var element = this.drawPopup();

            var r = this.calendar.onFormShow(new FormEventArgs(this));
            if (!r) {
                return;
            }

            parentElement.appendChild(element);

            this.fits = this.willFitParentBounds(parentElement, element);

            if (this.fits !== true || this.calendar.popups.count > 0) {
                parentElement.removeChild(element);
                parentElement = document.body;
                parentElement.appendChild(element);
                var scXY = DomUtils.getScrollXY();
                this.parentBounds = DomUtils.getBodySize();
                this.parentBounds.x = scXY.scrollLeft;
                this.parentBounds.y = scXY.scrollTop;
                this.parentElement = parentElement;
            } else {
                this.parentBounds = DomUtils.getBounds(parentElement);
            }

            this.setLocation();
            this.calendar.popups.set(this.id, this);

            var b = DomUtils.getBounds(element);
            this.dimensions = { width: b.width, height: b.height };
            if (this.id !== 'ItemsCueForm') this.calendar.view._selectionPaused = true;

            // set focus on the subject textbox (smallnew & edit forms)
            if (this._controls['subject'] != null) {
                this._controls['subject'].element.focus();
            }
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'setLocation',
        value: function setLocation() {
            var bodyBounds = DomUtils.getBodySize();
            var scrollXY = DomUtils.getScrollXY();
            var parent = this.parentBounds;
            var element = this.element;
            var b = DomUtils.getBounds(element);
            var width = b.width;
            var height = b.height;

            var left = 0;
            if (parent.width > bodyBounds.width) {
                left = (bodyBounds.width - width) / 2 - parent.x;
            } else {
                left = (parent.width - width) / 2;
            }
            if (bodyBounds.width <= parent.width) {
                left += scrollXY.scrollLeft;
            }
            var top = 0;
            if (parent.height > bodyBounds.height) {
                top = (bodyBounds.height - height) / 2 - parent.y;
            } else {
                top = (parent.height - height) / 2;
            }
            if (bodyBounds.height <= parent.height) {
                top += scrollXY.scrollTop;
            }
            var pos = this.checkBounds(parent, { x: left, y: top, width: width, height: height }, !this.fits);

            element.style.left = pos.x + "px";
            element.style.top = pos.y + "px";
        }

        /**
        * Closes the form.
        * @param {String} [formId] The Id of the form to be closed.
        */

    }, {
        key: 'closeForm',
        value: function closeForm(formId) {

            var r = this.calendar.onFormClose(new FormEventArgs(this));
            if (!r) {
                return;
            }

            var popups = this.calendar.popups;
            if (formId != null) {
                var checkPop = popups.get(formId);
                if (checkPop == null) return;
                checkPop.clearObject();
                DomUtils.removeNode(checkPop.element, checkPop.parentElement);
                popups.remove(formId);
            } else {
                this.clearObject();
                DomUtils.removeNode(this.element, this.parentElement);
                popups.remove(this.id);
            }
            if (this.calendar.popups.count === 0 || this.calendar.popups.count === 1 && this.calendar.popups.get("ItemsCueForm")) {
                this.calendar.view._selectionPaused = false;
            }
        }

        /**
        * Returns a reference to the form DOM element.
        */

    }, {
        key: 'getElement',
        value: function getElement() {
            return this.element;
        }

        /**
        * Returns a reference to the DOM element of the form content.
        */

    }, {
        key: 'getContent',
        value: function getContent() {
            return this.content;
        }

        /**
        * Returns a reference to the DOM element of the form header.
        */

    }, {
        key: 'getHeader',
        value: function getHeader() {
            return this._header;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'drawPopup',
        value: function drawPopup() {
            var d = document.createElement("div");
            DomUtils.addCssClass(d, "mfp-popup");
            if (this.cssClass) DomUtils.addCssClass(d, this.cssClass);
            if (this.calendar.theme) DomUtils.addCssClass(d, this.calendar.theme);

            d.id = this.elementId;

            this.element = d;

            var h = this.drawHeader();
            d.appendChild(h);

            var c = this.drawContent();
            d.appendChild(c);

            if (c != null) {
                var b = this.drawButtons();
                if (b != null) c.appendChild(b);
            }

            return d;
        }

        /**
        * Renders the form header.
        * @remarks Override this method in a derived class to render custom form header.
        */

    }, {
        key: 'drawHeader',
        value: function drawHeader() {
            var _this2 = this;

            var h = document.createElement("div");
            h.className = "mfp-popup-header";
            h.addEventListener("mousedown", function (e) {
                return _this2.onHeaderMouseDown(e);
            });

            var s = document.createElement("a");
            s.text = this.headerText;
            h.appendChild(s);

            var a = document.createElement("a");
            a.className = "mfp-close-button";
            //  a.text = "x";
            a.addEventListener("click", function (e) {
                return _this2.onCloseButtonClick(e);
            });
            h.appendChild(a);

            this.addControl({ id: "headerElement", element: h });
            this.addControl({ id: "headerClose", element: a });

            this._header = h;

            return h;
        }

        /**
        * Renders the form content.
        * @remarks Override this method in a derived class to render custom form content.
        */

    }, {
        key: 'drawContent',
        value: function drawContent() {
            var c = document.createElement("div");
            c.className = "mfp-popup-content";
            this.content = c;
            return c;
        }

        /**
        * Renders the form buttons.
        * @remarks Override this method in a derived class to render custom form buttons.
        */

    }, {
        key: 'drawButtons',
        value: function drawButtons() {
            this._buttons = null;
        }

        /**
        * Creates a button with the specified options.
        * @param {Object} options Object, containing data for the new control.
        * @returns {Object} The newly created button.
        * @remarks The options parameter should match the following pattern: { id: id, text: text, events: {"name": handler} }
        */

    }, {
        key: 'createButton',
        value: function createButton(options) {
            if (options == null || options == {}) return;
            if (options.id == null) options.id = "button" + this.controls.count() + 1;
            if (options.text === "") options.text = options.id;

            var button = { id: options.id, text: options.text, element: null };

            var a = document.createElement("a");
            a.className = "mfp-button";
            a.innerHTML = button.text;
            button.element = a;

            if (options.events != null) {
                for (var key in options.events) {
                    if (options.events.hasOwnProperty(key)) {
                        button.element.addEventListener(key, options.events[key]);
                    }
                }
            }

            return button;
        }

        /**
        * Creates a text area with the specified options.
        * @param {Object} options Object, containing data for the new control.
        * @returns {Object} The newly created text area.
        * @remarks The options parameter should match the following pattern: { id: id, text: text, events: {"name": handler} }
        */

    }, {
        key: 'createTextArea',
        value: function createTextArea(options) {
            var _this3 = this;

            if (options == null) return;
            if (options.id == null) options.id = "textArea" + this.controls.count() + 1;

            var t = document.createElement("textarea");
            t.className = "mfp-text-area";
            var initValue = typeof options.initValue !== "undefined" && options.initValue !== null ? options.initValue : "";
            t.id = options.id;
            t.value = initValue;
            options.element = t;
            var c = new BaseControl(options, this);
            c.keyUp.addEventListener(function (sender, args) {
                _this3.onControlKeyUp(sender, args);
            });
            return c;
        }

        /**
        * Creates a text box with the specified options.
        * @param {Object} options Object, containing data for the new control.
        * @returns {Object} The newly created text box.
        * @remarks The options parameter should match the following pattern: { id: id, text: text, events: {"name": handler} }
        */

    }, {
        key: 'createTextBox',
        value: function createTextBox(options) {
            var _this4 = this;

            if (options == null) return;
            if (options.id == null) options.id = "textBox" + this.controls.count() + 1;
            var t = document.createElement("input");
            t.type = "text";
            t.className = "mfp-text-box";
            t.id = options.id;
            t.value = options.initValue;
            options.element = t;
            var c = new BaseControl(options, this);
            c.keyUp.addEventListener(function (sender, args) {
                _this4.onControlKeyUp(sender, args);
            });
            return c;
        }

        /**
        * Creates a drop-down list with the specified options.
        * @param {Object} options Object, containing data for the new control.
        * @returns {Object} The newly created drop-down list.
        * @remarks The options parameter should match the following pattern: { id: id, text: text, events: {"name": handler} }
        */

    }, {
        key: 'createDropDownList',
        value: function createDropDownList(options) {
            var _this5 = this;

            if (options == null) return;
            if (options.id == null) options.id = "dropDownList" + this.controls.count() + 1;

            var list = document.createElement("select");
            list.className = "mfp-dropDown-list";
            list.id = options.id;

            var items = options.items;

            if (options.addEmptyValue !== false) {
                var option = document.createElement("option");
                list.appendChild(option);
            }

            for (var i = 0; i < items.length; i++) {
                var option = document.createElement("option");
                option.value = items[i].value.toString();
                option.innerHTML = items[i].text;
                list.appendChild(option);
            }

            options.element = list;
            if (options.initValue != null) options.element.value = options.initValue;

            var newOptions = {
                id: options.id,
                element: options.element,
                initValue: options.initValue,
                events: options.events
            };

            var c = new BaseControl(newOptions, this);
            c.keyUp.addEventListener(function (sender, args) {
                _this5.onControlKeyUp(sender, args);
            });
            return c;
        }

        /**
        * Creates a check-box with the specified options.
        * @param {Object} options Object, containing data for the new control.
        * @returns {Object} The newly created check-box
        * @remarks The options parameter should match the following pattern: { id: id, text: text, events: {"name": handler} }
        */

    }, {
        key: 'createCheckBox',
        value: function createCheckBox(options) {
            if (options == null) return;
            if (options.id == null) options.id = "checkBox" + this.controls.count() + 1;
            if (options.name == null) options.name = options.id;
            if (options.text == null) options.text = options.id;

            var newControl = { id: options.id, element: null, text: options.text };

            var list = document.createElement("input");
            list.type = "checkbox";
            list.className = "mfp-check-box";
            list.id = options.id;

            var label = document.createElement("label");
            label.for = options.id;
            label.innerHTML = options.text;

            options.element = list;
            if (options.initValue === true) options.element.checked = true;
            delete options.text;
            return { control: new BaseControl(options, this), label: label };
        }

        /**
        * Creates a check box list with the specified options.
        * @param {Object} options Object, containing data for the new control.
        * @returns {Object} The newly created check-box list.
        * @remarks The options parameter should match the following pattern: { id: id, text: text, events: {"name": handler} }
        */

    }, {
        key: 'createCheckBoxList',
        value: function createCheckBoxList(options) {
            if (options == null || options === {}) return;
            if (options.id == null) options.id = "checkBoxList" + this.controls.count() + 1;
            return new CheckBoxList(options);
        }

        /**
        * Creates an edit box with the specified options.
        * @param {Object} options Object, containing data for the new control.
        * @returns {Object} The newly created edit box.
        * @remarks The options parameter should match the following pattern: { id: id, text: text, events: {"name": handler} }
        */

    }, {
        key: 'createEditBox',
        value: function createEditBox(options) {
            if (options == null || options === {}) return;
            if (options.id == null) options.id = "editBox" + this.controls.count() + 1;

            options.parent = this.element;
            options.formatInfo = this.formatInfo;
            options.localInfo = this.localInfo;
            return new EditBox(options);
        }

        /**
        * Creates a radio button with the specified options.
        * @param {Object} options Object, containing data for the new control.
        * @returns {Object} The newly created radio button.
        * @remarks The options parameter should match the following pattern: { id: id, text: text, events: {"name": handler} }
        */

    }, {
        key: 'createRadioButton',
        value: function createRadioButton(options) {
            if (options === null || options === {}) return;
            if (options.id === null) options.id = "radioButton" + this.controls.count() + 1;
            if (options.text === null) options.text = options.id;
            if (options.name === null) options.name = options.id;

            var newControl = { id: options.id, element: null, text: options.text, name: options.name };

            var list = document.createElement("input");
            list.type = "radio";
            list.className = "mfp-check-box";
            list.id = options.id;
            list.name = newControl.name;
            newControl.element = list;

            var label = document.createElement("label");
            label.for = options.id;
            label.innerHTML = options.text;
            list.appendChild(label);

            if (options.checked === true) newControl.element.checked = true;
            newControl.getValue = function () {
                return this.element.checked;
            };

            if (options.events != null) {
                for (var key in options.events) {
                    if (options.events.hasOwnProperty(key)) {
                        newControl.element.addEventListener(key, options.events[key]);
                    }
                }
            }

            return { control: newControl, label: label };
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'clearObject',
        value: function clearObject() {
            this.clearControls();
            //  if (this.element != null)
            //      $clearHandlers(this.element);
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onCloseButtonClick',
        value: function onCloseButtonClick(e) {
            this.closeForm();
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onCancelButtonClick',
        value: function onCancelButtonClick(e) {
            this.closeForm();
        }
    }, {
        key: 'onSaveButtonClick',
        value: function onSaveButtonClick(e) {}

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onPopupMouseDown',
        value: function onPopupMouseDown(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onHeaderMouseDown',
        value: function onHeaderMouseDown(evt) {
            if (evt.button == 0) {
                this.dragging = true;
                var loc = DomUtils.getLocation(this.element);
                this.dragOffset = { x: evt.clientX - loc.x, y: evt.clientY - loc.y };

                document.addEventListener('mousemove', this.mouseMoveHandler);
                document.addEventListener('mouseup', this.mouseUpHandler);
            }
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onMouseMove',
        value: function onMouseMove(evt) {
            if (this.dragging === true) {
                if (!this.fits) {
                    this.parentBounds = DomUtils.getBodySize();
                    var sc = DomUtils.getScrollXY();
                    this.parentBounds.x = sc.scrollLeft;
                    this.parentBounds.y = sc.scrollTop;
                }
                var element = this.element;
                var loc = DomUtils.getLocation(element.parentNode);
                var drag = this.dragOffset;
                var pb = { x: this.fits ? 0 : this.parentBounds.x, y: this.fits ? 0 : this.parentBounds.y, width: this.parentBounds.width, height: this.parentBounds.height };
                var d = this.dimensions;
                var r = this.checkBounds(pb, { x: evt.clientX - loc.x - drag.x, y: evt.clientY - loc.y - drag.y, width: d.width, height: d.height }, true);
                element.style.left = r.x + "px";
                element.style.top = r.y + "px";
            }
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onMouseUp',
        value: function onMouseUp(evt) {
            if (this.dragging === true) {
                this.dragging = false;
                this.dragOffset = null;

                document.removeEventListener('mousemove', this.mouseMoveHandler);
                document.removeEventListener('mouseup', this.mouseUpHandler);
            }
        }
    }, {
        key: 'onKeyUp',
        value: function onKeyUp(e) {
            this.onControlKeyUp(this, e);
        }
    }, {
        key: 'onControlKeyUp',
        value: function onControlKeyUp(sender, e) {
            if (e.keyCode == 13) {
                this.onSaveButtonClick(e);
                e.preventDefault();
                return false;
            }
            if (e.keyCode == 27) {
                this.onCancelButtonClick(e);
                e.preventDefault();
                return false;
            }
        }

        /**
        * Gets the locale object used to format and display date and time information in the form.
        * @returns {Object} The format info object.
        */

    }, {
        key: 'formatInfo',
        get: function get$$1() {
            return this.calendar.formatInfo;
        }

        /**
        * Gets the locale object used to format and display localizable strings in the form.
        * @returns {Object} The local info object.
        */

    }, {
        key: 'localInfo',
        get: function get$$1() {
            return this.calendar.localInfo;
        }

        /**
        * Gets a value indicating the type of the form.
        * @returns {String} "edit" if an existing item or recurrence object is being modified through the form, otherwise "new".
        */

    }, {
        key: 'type',
        get: function get$$1() {
            return this._type;
        }

        /**
        * Gets a value indicating the id of the form.
        * @returns {String} The id of the form.
        * @remarks For the default forms possible return values are NewForm, EditForm, RecurrenceForm or ItemsCueForm.
        */

    }, {
        key: 'id',
        get: function get$$1() {
            return this._id;
        }

        /**
        * Gets the text which is displayed in the header of the form.	
        * @returns {String} The header text.
        */

    }, {
        key: 'headerText',
        get: function get$$1() {
            return this._headerText;
        }

        /**
        * Sets the text which is displayed in the header of the form.	
        * @param {String} value The header text.
        */
        ,
        set: function set$$1(value) {
            this._headerText = value;
        }
    }]);
    return BaseForm;
}();

var RecurrenceForm = function (_BaseForm) {
        inherits(RecurrenceForm, _BaseForm);

        function RecurrenceForm(calendar, item) {
                classCallCheck(this, RecurrenceForm);

                var _this = possibleConstructorReturn(this, (RecurrenceForm.__proto__ || Object.getPrototypeOf(RecurrenceForm)).call(this, calendar, item));

                _this._id = "RecurrenceForm";
                _this.cssClass = "mfp-popup-recurrence";

                _this.item = item;

                if (item != null && item.currentRecurrence != null) {
                        if (item.recurrence != null) {
                                _this._type = 'edit';
                                _this._headerText = _this.localInfo.editRecurrenceFormHeader;
                        } else {
                                _this._type = 'new';
                                _this._headerText = _this.localInfo.newRecurrenceFormHeader;
                        }

                        _this.recurrence = item.currentRecurrence.clone();
                } else if (item != null && item.recurrence != null) {
                        _this._type = 'edit';
                        _this.recurrence = item.recurrence;
                        _this._headerText = _this.localInfo.editRecurrenceFormHeader;
                } else {
                        _this._type = 'new';
                        _this.recurrence = new Recurrence();
                        _this.recurrence.startDate = item.startTime;
                        _this.recurrence.endDate = item.endTime;
                        _this.recurrence.daysOfWeek = item.startTime.getDay();
                        _this.recurrence.dayOfMonth = item.startTime._date.getDate();
                        _this.recurrence.day = item.startTime._date.getDay() + 3;
                        _this.recurrence.monthOfYear = item.startTime._date.getMonth() + 1;
                        _this.recurrence.occurrence = item.startTime.getMonthlyOccurrenceIndex();

                        _this._headerText = _this.localInfo.newRecurrenceFormHeader;
                }

                _this.firstLastList = [{ value: 0, text: _this.localInfo.firstValue }, { value: 1, text: _this.localInfo.secondValue }, { value: 2, text: _this.localInfo.thirdValue }, { value: 3, text: _this.localInfo.fourthValue }, { value: 4, text: _this.localInfo.lastValue }];

                var items = [];
                items = _this.formatInfo.days.long.slice(0);
                items.splice(0, 0, _this.localInfo.weekendValue);
                items.splice(0, 0, _this.localInfo.weekdayValue);
                items.splice(0, 0, _this.localInfo.dayValue);

                _this.dayNames = [];
                for (var i = 0, l = items.length; i < l; i++) {
                        _this.dayNames.push({ value: i, text: items[i] });
                }

                var items = [];
                items = _this.formatInfo.months.long.slice(0);
                _this.monthNames = [];
                for (var i = 0, l = items.length; i < l; i++) {
                        _this.monthNames.push({ value: i, text: items[i] });
                }
                return _this;
        }

        /**
        * For internal use only.
        * @private
        */


        createClass(RecurrenceForm, [{
                key: 'drawContent',
                value: function drawContent() {
                        var _this2 = this;

                        get(RecurrenceForm.prototype.__proto__ || Object.getPrototypeOf(RecurrenceForm.prototype), 'drawContent', this).call(this);
                        var content = this.getContent();

                        var item = this.item;if (item == null) item = {};
                        var recurrence = this.recurrence;

                        // Create Location
                        var patternItems = [];
                        patternItems.push({ value: 0, text: this.localInfo.dailyValue });
                        patternItems.push({ value: 1, text: this.localInfo.weeklyValue });
                        patternItems.push({ value: 2, text: this.localInfo.monthlyValue });
                        patternItems.push({ value: 3, text: this.localInfo.yearlyValue });
                        patternItems.push({ value: 4, text: this.localInfo.intervalValue });

                        var newControl = this.createDropDownList({ id: "pattern", items: patternItems, initValue: recurrence.pattern, addEmptyValue: false, events: { change: function change(e) {
                                                return _this2.onPatternChange(e);
                                        } } });
                        newControl.element.style.width = "45%";
                        var s = document.createElement("span");
                        s.className = "mfp-text-label";
                        s.innerHTML = this.localInfo.patternCaption;

                        var newRow = this.row();
                        DomUtils.addCssClass(newRow, "pattern");
                        newRow.appendChild(s);
                        newRow.appendChild(newControl.element);

                        content.appendChild(newRow);
                        this.addControl(newControl);

                        var td2 = content;
                        // var table = document.createElement("table");
                        // table.style.width = "100%";
                        // table.cellSpacing = 0;
                        // table.cellPadding = 0;

                        // var tr = document.createElement("tr");
                        // table.appendChild(tr);

                        // var td1 = document.createElement("td");
                        // tr.appendChild(td1);

                        // var td2 = document.createElement("td");
                        // tr.appendChild(td2);

                        // //var table = $mindfusion('<table cellpadding="0" cellspacing="0"><tr><td valign="top"></td><td valign="top"></td></tr></table>')[0];

                        // //Create Daily
                        // newControl = this.createRadioButton({ id: "daily", text: this._localInfo.dailyValue, name: "pattern", checked: (recurrence.pattern == 0) });
                        // var newRow = this.row();
                        // newRow.appendChild(newControl.control.element);
                        // newRow.appendChild(newControl.label);
                        // this.addControl(newControl.control);
                        // td1.appendChild(newRow);

                        // //Create Weekly
                        // newControl = this.createRadioButton({ id: "weekly", text: this._localInfo.weeklyValue, name: "pattern", checked: (recurrence.pattern == 1) });
                        // newRow = this.row();
                        // newRow.appendChild(newControl.control.element);
                        // newRow.appendChild(newControl.label);
                        // this.addControl(newControl.control);
                        // td1.appendChild(newRow);

                        // //Create Monthly
                        // newControl = this.createRadioButton({ id: "monthly", text: this._localInfo.monthlyValue, name: "pattern", checked: (recurrence.pattern == 2) });
                        // newRow = this.row();
                        // newRow.appendChild(newControl.control.element);
                        // newRow.appendChild(newControl.label);
                        // this.addControl(newControl.control);
                        // td1.appendChild(newRow);

                        // //Create Yearly
                        // newControl = this.createRadioButton({ id: "yearly", text: this._localInfo.yearlyValue, name: "pattern", checked: (recurrence.pattern == 3) });
                        // newRow = this.row();
                        // newRow.appendChild(newControl.control.element);
                        // newRow.appendChild(newControl.label);
                        // this.addControl(newControl.control);
                        // td1.appendChild(newRow);

                        // //Create interval
                        // newControl = this.createRadioButton({ id: "interval", text: this._localInfo.intervalValue, name: "pattern", checked: (recurrence.pattern == 4) });
                        // newRow = this.row();
                        // newRow.appendChild(newControl.control.element);
                        // newRow.appendChild(newControl.label);
                        // this.addControl(newControl.control);
                        // td1.appendChild(newRow);

                        //Create day div
                        var dayDiv = this.row();
                        DomUtils.addCssClass(dayDiv, "mfp-pattern-details");
                        dayDiv.id = 'DayDiv';
                        dayDiv.style.display = recurrence.pattern == 0 ? 'block' : 'none';
                        this.addControl(dayDiv);

                        // Every day radio btn & up/down
                        var newControl = this.createRadioButton({ id: "dailyEvery", text: this.localInfo.everyCaption, name: "daily", checked: recurrence.dailyRecurrence == 0 });
                        newRow = this.row();
                        newRow.appendChild(newControl.control.element);
                        newRow.appendChild(newControl.label);
                        this.addControl(newControl.control);
                        var newControl = this.createEditBox({ id: "dailyEveryDay", type: "numeric", initValue: recurrence.days, minValue: 1 });
                        newRow.appendChild(newControl.element);

                        var s = document.createElement("span");
                        s.className = "mfp-text-label";
                        s.innerHTML = "&nbsp;" + this.localInfo.dayValue;
                        newRow.appendChild(s);
                        this.addControl(newControl);

                        dayDiv.appendChild(newRow);

                        // Every weekday radio btn
                        var newControl = this.createRadioButton({ id: "dailyWeekday", text: this.localInfo.everyCaption + " " + this.localInfo.weekdayValue, name: "daily", checked: recurrence.dailyRecurrence == 1 });
                        newRow = this.row();
                        newRow.appendChild(newControl.control.element);
                        newRow.appendChild(newControl.label);
                        this.addControl(newControl.control);
                        dayDiv.appendChild(newRow);

                        //Every weekend day radio btn
                        var newControl = this.createRadioButton({ id: "dailyWeekend", text: this.localInfo.everyCaption + " " + this.localInfo.weekendValue, name: "daily", checked: recurrence.dailyRecurrence == 2 });
                        newRow = this.row();
                        newRow.appendChild(newControl.control.element);
                        newRow.appendChild(newControl.label);
                        this.addControl(newControl.control);
                        dayDiv.appendChild(newRow);

                        td2.appendChild(dayDiv);

                        //Create week div
                        var weekDiv = this.row();
                        DomUtils.addCssClass(weekDiv, "mfp-pattern-details");
                        weekDiv.id = 'WeekDiv';
                        weekDiv.style.display = recurrence.pattern == 1 ? 'block' : 'none';
                        this.addControl(weekDiv);

                        var newControl = this.createEditBox({ id: "weekEvery", type: "numeric", initValue: recurrence.weeks, minValue: 1 });
                        newRow = this.row();

                        var s = document.createElement("span");
                        s.className = "mfp-text-label";
                        s.innerHTML = "&nbsp;" + this.localInfo.everyCaption;
                        newRow.appendChild(s);

                        newRow.appendChild(newControl.element);

                        var s = document.createElement("span");
                        s.className = "mfp-text-label";
                        s.innerHTML = "&nbsp;" + this.localInfo.weeksValue;
                        newRow.appendChild(s);

                        this.addControl(newControl);
                        weekDiv.appendChild(newRow);

                        //Create day checkboxes
                        var dayItems = this.formatInfo.days.short;

                        newRow = this.row();
                        weekDiv.appendChild(newRow);

                        for (var i = 0, l = dayItems.length; i < l; i++) {
                                newControl = this.createCheckBox({ id: "dayOfWeek" + i, text: dayItems[i], name: "weekDay", initValue: (Math.pow(2, i) & recurrence.daysOfWeek) == Math.pow(2, i) });

                                newRow.appendChild(newControl.control.element);
                                newRow.appendChild(newControl.label);
                                this.addControl(newControl.control);
                        }

                        weekDiv.appendChild(newRow);
                        td2.appendChild(weekDiv);

                        //Create month div
                        var monthDiv = this.row();
                        DomUtils.addCssClass(monthDiv, "mfp-pattern-details");
                        monthDiv.id = "MonthDiv";
                        monthDiv.style.display = recurrence.pattern == 2 ? 'block' : 'none';
                        this.addControl(monthDiv);

                        // n-th day every k-th month radio and up/downs
                        var newControl = this.createRadioButton({ id: "monthDate", text: this.localInfo.dayValue, name: "monthly", checked: recurrence.monthlyRecurrence == 0 });
                        newRow = this.row();
                        newRow.appendChild(newControl.control.element);
                        newRow.appendChild(newControl.label);
                        this.addControl(newControl.control);

                        var newControl = this.createEditBox({ id: "monthDateEdit", type: "numeric", initValue: recurrence.dayOfMonth, minValue: 1, maxValue: 31 });
                        newRow.appendChild(newControl.element);

                        var s = document.createElement("span");
                        s.className = "mfp-text-label";
                        s.innerHTML = "&nbsp;" + this.localInfo.ofEveryCaption;
                        newRow.appendChild(s);
                        this.addControl(newControl);

                        var newControl = this.createEditBox({ id: "monthDateMonth", type: "numeric", initValue: recurrence.months, minValue: 1 });
                        newRow.appendChild(newControl.element); //

                        var s = document.createElement("span");
                        s.className = "mfp-text-label";
                        s.innerHTML = "&nbsp;" + this.localInfo.monthValue;
                        newRow.appendChild(s);

                        this.addControl(newControl);
                        monthDiv.appendChild(newRow);

                        // n-th weekday every k-th month radio, dropdowns and up/down
                        var newControl = this.createRadioButton({ id: "monthWeekDay", text: "", name: "monthly", checked: recurrence.monthlyRecurrence == 1 });
                        newRow = this.row();
                        newRow.appendChild(newControl.control.element);
                        newRow.appendChild(newControl.label);
                        this.addControl(newControl.control);

                        // First DDL
                        var options = {
                                id: "monthWeekDayOptions",
                                items: this.firstLastList,
                                initValue: recurrence.occurrence,
                                addEmptyValue: false
                        };

                        newControl = this.createDropDownList(options);
                        newRow.appendChild(newControl.element);
                        this.addControl(newControl.element);

                        // Second DDL TODO checkitems
                        options = {
                                id: "monthWeekDayExactOptions",
                                items: this.dayNames,
                                initValue: recurrence.day,
                                addEmptyValue: false
                        };
                        newControl = this.createDropDownList(options);
                        newRow.appendChild(newControl.element);
                        var s = document.createElement("span");
                        s.className = "mfp-text-label";
                        s.innerHTML = "&nbsp;" + this.localInfo.ofEveryCaption;
                        newRow.appendChild(s);

                        this.addControl(newControl.element);

                        // up/down
                        var newControl = this.createEditBox({ id: "monthWeekDayMonth", type: "numeric", initValue: recurrence.months, minValue: 1 });
                        newRow.appendChild(newControl.element);

                        var s = document.createElement("span");
                        s.className = "mfp-text-label";
                        s.innerHTML = "&nbsp;" + this.localInfo.monthValue;
                        newRow.appendChild(s);
                        this.addControl(newControl);

                        monthDiv.appendChild(newRow);

                        td2.appendChild(monthDiv);

                        //Create year div
                        var yearDiv = this.row();
                        DomUtils.addCssClass(yearDiv, "mfp-pattern-details");
                        yearDiv.id = "YearDiv";
                        yearDiv.style.display = recurrence.pattern == 3 ? 'block' : 'none';
                        this.addControl(yearDiv);

                        // Every dd/MM radio btn
                        var newControl = this.createRadioButton({ id: "yearExact", text: this.localInfo.everyCaption, name: "yearly", checked: recurrence.yearlyRecurrence == 0 });
                        newRow = this.row();
                        newRow.appendChild(newControl.control.element);
                        newRow.appendChild(newControl.label);
                        this.addControl(newControl.control);

                        // First DDL
                        options = {
                                id: "yearExactOption",
                                items: this.monthNames,
                                initValue: recurrence.monthOfYear - 1,
                                addEmptyValue: false

                                // Every dd/MM option & up/down
                        };newControl = this.createDropDownList(options);
                        newRow.appendChild(newControl.element);
                        this.addControl(newControl.element);

                        var newControl = this.createEditBox({ id: "yearExactEdit", type: "numeric", initValue: recurrence.dayOfMonth, minValue: 1, maxValue: 31 });
                        newRow.appendChild(newControl.element);
                        this.addControl(newControl);
                        yearDiv.appendChild(newRow);

                        // n-th weekday every year radio, dropdowns and up/down (todo: temp textbox)
                        var newControl = this.createRadioButton({ id: "yearWeekDay", text: "", name: "yearly", checked: recurrence.yearlyRecurrence == 1 });
                        newRow = this.row();
                        newRow.appendChild(newControl.control.element);
                        newRow.appendChild(newControl.label);
                        this.addControl(newControl.control);

                        // First DDL
                        options = {
                                id: "yearWeekDayPosOptions",
                                items: this.firstLastList,
                                initValue: recurrence.occurrence,
                                addEmptyValue: false
                        };
                        newControl = this.createDropDownList(options);
                        newRow.appendChild(newControl.element);
                        this.addControl(newControl.element);

                        // Second DDL
                        options = {
                                id: "yearWeekDayExactOptions",
                                items: this.dayNames,
                                initValue: recurrence.day,
                                addEmptyValue: false
                        };
                        newControl = this.createDropDownList(options);
                        newRow.appendChild(newControl.element);
                        var s = document.createElement("span");
                        s.className = "mfp-text-label";
                        s.innerHTML = "&nbsp;" + this.localInfo.ofEveryCaption;
                        newRow.appendChild(s);
                        this.addControl(newControl.element);

                        // Third DDL
                        options = {
                                id: "yearMonthExactOptions",
                                items: this.monthNames,
                                initValue: recurrence.monthOfYear - 1,
                                addEmptyValue: false
                        };

                        newControl = this.createDropDownList(options);
                        newRow.appendChild(newControl.element);
                        this.addControl(newControl.element);

                        yearDiv.appendChild(newRow);

                        td2.appendChild(yearDiv);

                        //Create interval div
                        var intervalDiv = this.row();
                        DomUtils.addCssClass(intervalDiv, "mfp-pattern-details");
                        intervalDiv.id = "IntervalDiv";
                        intervalDiv.style.display = recurrence.pattern == 4 ? 'block' : 'none';
                        this.addControl(intervalDiv);

                        var interval = recurrence.interval / DateTime.MillisPerHour;
                        var days = Math.floor(interval / 24.0);
                        var hours = Math.floor(interval % 24);
                        var minutes = Math.floor(interval * 60) % 60;
                        var seconds = Math.round(interval * 60 % 60 * 60 % 60);
                        if (seconds >= 60) {
                                minutes += seconds / 60;
                                seconds -= 60 * (seconds / 60);
                        }

                        //Days up/down
                        var newControl = this.createEditBox({ id: "intervalDays", type: "numeric", initValue: days });
                        newRow = this.row();

                        var s = document.createElement("span");
                        s.className = "mfp-text-label";
                        s.innerHTML = "&nbsp;" + this.localInfo.daysValue;
                        newRow.appendChild(s);

                        newRow.appendChild(newControl.element);

                        this.addControl(newControl);

                        //Hours up/down
                        newControl = this.createEditBox({ id: "intervalHours", type: "numeric", initValue: hours });

                        var s = document.createElement("span");
                        s.className = "mfp-text-label";
                        s.innerHTML = "&nbsp;" + this.localInfo.hoursValue;
                        newRow.appendChild(s);

                        newRow.appendChild(newControl.element);
                        this.addControl(newControl);
                        intervalDiv.appendChild(newRow);

                        //Minutes up/down
                        newControl = this.createEditBox({ id: "intervalMinutes", type: "numeric", initValue: minutes });
                        //  newRow = this.row();//

                        var s = document.createElement("span");
                        s.className = "mfp-text-label";
                        s.innerHTML = "&nbsp;" + this.localInfo.minutesValue;
                        newRow.appendChild(s);

                        newRow.appendChild(newControl.element);
                        this.addControl(newControl);
                        intervalDiv.appendChild(newRow);

                        //Seconds up/down
                        newControl = this.createEditBox({ id: "intervalSeconds", type: "numeric", initValue: seconds });

                        var s = document.createElement("span");
                        s.className = "mfp-text-label";
                        s.innerHTML = "&nbsp;" + this.localInfo.secondsValue;
                        newRow.appendChild(s);

                        newRow.appendChild(newControl.element);
                        this.addControl(newControl);
                        intervalDiv.appendChild(newRow);

                        td2.appendChild(intervalDiv);

                        //Bottom part
                        // Create Horizontal Line
                        content.appendChild(this.divider());

                        // var s = document.createElement("span");
                        // s.innerHTML = "&nbsp;" + this.localInfo.rangeCaption;
                        // content.appendChild(s);
                        var table = document.createElement("table");
                        table.cellSpacing = 0;
                        table.cellPadding = 0;

                        var tr = document.createElement("tr");
                        table.appendChild(tr);

                        var td1 = document.createElement("td");
                        tr.appendChild(td1);

                        var td2 = document.createElement("td");
                        tr.appendChild(td2);

                        // Create Start Date EditBox
                        var options = {
                                id: "startDate",
                                type: "date",
                                initValue: recurrence.startDate.clone()
                        };
                        newControl = this.createEditBox(options);
                        newRow = this.row();

                        var s = document.createElement("span");
                        s.className = "mfp-text-label";
                        s.innerHTML = "&nbsp;" + this.localInfo.startCaption;
                        newRow.appendChild(s);

                        newRow.appendChild(newControl.element);
                        this.addControl(newControl);
                        td1.appendChild(newRow);
                        //Create NoEnd
                        newControl = this.createRadioButton({ id: "noEnd", text: this.localInfo.noEndCaption, name: "recEnd", checked: recurrence.recurrenceEnd == 0 });
                        newRow = this.row();
                        newRow.appendChild(newControl.control.element);
                        newRow.appendChild(newControl.label);
                        this.addControl(newControl.control);
                        td2.appendChild(newRow);

                        // Create EndAfter
                        newControl = this.createRadioButton({ id: "endAfter", text: this.localInfo.endAfterCaption, name: "recEnd", checked: recurrence.recurrenceEnd == 1 });
                        newRow = this.row();
                        newRow.appendChild(newControl.control.element);
                        newRow.appendChild(newControl.label);
                        this.addControl(newControl.control);

                        var newControl = this.createEditBox({ id: "numOccurences", type: "numeric", initValue: recurrence.numOccurrences, minValue: 1 });
                        newRow.appendChild(newControl.element);
                        this.addControl(newControl);
                        td2.appendChild(newRow);

                        // Create EndBy
                        newControl = this.createRadioButton({ id: "endBy", text: this.localInfo.endDateCaption, name: "recEnd", checked: recurrence.recurrenceEnd == 2 });
                        newRow = this.row();
                        newRow.appendChild(newControl.control.element);
                        newRow.appendChild(newControl.label);
                        this.addControl(newControl.control);

                        var options = {
                                id: "endDate",
                                type: "date",
                                initValue: recurrence.endDate.clone(),
                                culture: this.culture,
                                localInfo: this._localInfo
                        };
                        newControl = this.createEditBox(options);
                        newRow.appendChild(newControl.element);
                        this.addControl(newControl);

                        td2.appendChild(newRow);

                        newRow = this.row();
                        DomUtils.addCssClass(newRow, "range");
                        newRow.appendChild(table);
                        content.appendChild(newRow);
                        content.appendChild(this.divider());

                        return content;
                }

                /**
                * For internal use only.
                * @private
                */

        }, {
                key: 'drawButtons',
                value: function drawButtons() {
                        var _this3 = this;

                        // Add Save Button
                        var newButton = this.createButton({ id: "btnSave", text: this.localInfo.saveButtonCaption, events: { click: function click(e) {
                                                return _this3.onSaveButtonClick(e);
                                        } } });
                        var buttons = this.row();
                        DomUtils.addCssClass(buttons, "mfp-buttons-row");

                        buttons.appendChild(newButton.element);
                        this.addControl(newButton);

                        // Add Cancel Button
                        newButton = this.createButton({ id: "btnCancel", text: this.localInfo.cancelButtonCaption, events: { click: function click(e) {
                                                return _this3.onCancelButtonClick(e);
                                        } } });
                        buttons.appendChild(newButton.element);
                        this.addControl(newButton);

                        // Add Delete Button
                        if (this._type == 'edit') {
                                newButton = this.createButton({ id: "btnDelete", text: this.localInfo.deleteButtonCaption, events: { click: function click(e) {
                                                        return _this3.onDeleteButtonClick(e);
                                                } } });
                                buttons.appendChild(newButton.element);
                                this.addControl(newButton);
                        }

                        // Add Buttons To Form
                        this._buttons = buttons;
                        return buttons;
                }

                /**
                  * For internal use only.
                  * @private
                  */

        }, {
                key: 'getChanges',
                value: function getChanges() {
                        var recurrence = new Recurrence();

                        recurrence._pattern = +this._controls["pattern"].getValue();
                        recurrence._end = this.getRadioGroupValue("recEnd");
                        recurrence._startDate = this._controls["startDate"].getValue().clone();

                        switch (recurrence._end) {
                                case 1:
                                        {
                                                if (this._controls["numOccurences"].getValue() != '') recurrence._numOccurrences = +this._controls["numOccurences"].getValue();else recurrence._numOccurrences = 1;
                                                break;
                                        }
                                case 2:
                                        {
                                                recurrence._endDate = this._controls["endDate"].value;
                                                break;
                                        }
                        }

                        switch (recurrence._pattern) {
                                //daily                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
                                case 0:
                                        {
                                                recurrence._daily = this.getRadioGroupValue("daily");
                                                if (recurrence._daily == 0) recurrence._days = +this._controls["dailyEveryDay"].getValue();
                                                break;
                                        }
                                //weekly
                                case 1:
                                        {
                                                if (this._controls["weekEvery"].getValue() != '') recurrence._weeks = +this._controls["weekEvery"].getValue();else recurrence._weeks = 1;

                                                var days = 0;
                                                for (var i = 0, l = 6; i <= l; i++) {
                                                        if (this._controls["dayOfWeek" + i].getValue() == true) {
                                                                days |= Math.pow(2, i);
                                                        }
                                                }
                                                if (days === 0) {
                                                        days = 1;
                                                }
                                                recurrence._daysOfWeek = days;
                                                break;
                                        }
                                //monthly
                                case 2:
                                        {
                                                recurrence._monthly = this.getRadioGroupValue("monthly");
                                                if (recurrence._monthly == 0) {
                                                        recurrence._dayOfMonth = +this._controls["monthDateEdit"].getValue();
                                                        recurrence._months = +this._controls["monthDateMonth"].getValue();
                                                } else if (recurrence._monthly == 1) {
                                                        recurrence._occurrence = +this._controls["monthWeekDayOptions"].selectedIndex;
                                                        recurrence._day = +this._controls["monthWeekDayExactOptions"].selectedIndex;
                                                        recurrence._months = +this._controls["monthWeekDayMonth"].getValue();
                                                }
                                                break;
                                        }
                                //yearly
                                case 3:
                                        {
                                                recurrence._yearly = this.getRadioGroupValue("yearly");
                                                if (recurrence._yearly == 0) {
                                                        recurrence._monthOfYear = +this._controls["yearExactOption"].selectedIndex + 1;
                                                        recurrence._dayOfMonth = +this._controls["yearExactEdit"].getValue();
                                                } else if (recurrence._yearly == 1) {
                                                        recurrence._occurrence = +this._controls["yearWeekDayPosOptions"].selectedIndex;
                                                        recurrence._day = +this._controls["yearWeekDayExactOptions"].selectedIndex;
                                                        recurrence._monthOfYear = +this._controls["yearMonthExactOptions"].selectedIndex + 1;
                                                }
                                                break;
                                        }
                                //interval
                                case 4:
                                        {
                                                var days = +this._controls["intervalDays"].getValue();
                                                var hours = +this._controls["intervalHours"].getValue();
                                                var minutes = +this._controls["intervalMinutes"].getValue();
                                                var seconds = +this._controls["intervalSeconds"].getValue();
                                                recurrence._interval = (days * 24 + hours + minutes / 60 + seconds / 3600) * DateTime.MillisPerHour;
                                                if (recurrence._interval === 0) {
                                                        recurrence._interval = 1;
                                                }
                                                break;
                                        }
                        }
                        return recurrence;
                }
        }, {
                key: 'getRadioGroupValue',
                value: function getRadioGroupValue(radioGroup) {
                        var items = this.getContent().querySelectorAll("input[name=" + radioGroup + "]");

                        for (var i = 0, l = items.length; i < l; i++) {
                                if (items[i].checked) return i;
                        }
                }

                /**
                * For internal use only.
                * @private
                */

        }, {
                key: 'onSaveButtonClick',
                value: function onSaveButtonClick(e) {
                        this.item.currentRecurrence = this.getChanges();
                        this.closeForm();
                        if (this.calendar && this.calendar.popups.get("EditForm")) {
                                this.calendar.popups.get("EditForm").updateRecurrenceInfo();
                        }
                }

                /**
                * For internal use only.
                * @private
                */

        }, {
                key: 'onDeleteButtonClick',
                value: function onDeleteButtonClick(e) {
                        this.item.currentRecurrence = null;
                        this.closeForm();
                        if (this.calendar && this.calendar.popups.get("EditForm")) {
                                this.calendar.popups.get("EditForm").updateRecurrenceInfo();
                        }
                }
        }, {
                key: 'onPatternChange',
                value: function onPatternChange(e) {
                        var pattern = e.target.selectedIndex;
                        this._controls["DayDiv"].style.display = pattern == 0 ? 'block' : 'none';
                        this._controls["WeekDiv"].style.display = pattern == 1 ? 'block' : 'none';
                        this._controls["MonthDiv"].style.display = pattern == 2 ? 'block' : 'none';
                        this._controls["YearDiv"].style.display = pattern == 3 ? 'block' : 'none';
                        this._controls["IntervalDiv"].style.display = pattern == 4 ? 'block' : 'none';

                        e.stopPropagation();
                }
        }]);
        return RecurrenceForm;
}(BaseForm);

var EditForm = function (_BaseForm) {
    inherits(EditForm, _BaseForm);

    function EditForm(calendar, item, type) {
        classCallCheck(this, EditForm);

        var _this = possibleConstructorReturn(this, (EditForm.__proto__ || Object.getPrototypeOf(EditForm)).call(this, calendar, item));

        _this._id = "EditForm";

        _this._type = type || 'edit';

        if (_this._type == "edit") _this._headerText = _this.localInfo.editFormHeader;else _this._headerText = _this.localInfo.newFormHeader;

        _this.cssClass = "mfp-popup-edit";

        var ticksPerMinute = DateTime.TicksPerMinute;
        var ticksPerHour = DateTime.TicksPerHour;
        var ticksPerDay = DateTime.TicksPerDay;

        // Reminder DropDown List Items
        _this.reminderTexts = [{ value: 0, text: String.format('0 {0}', _this.localInfo.minutesValue) }, { value: 5 * ticksPerMinute, text: String.format('5 {0}', _this.localInfo.minutesValue) }, { value: 10 * ticksPerMinute, text: String.format('10 {0}', _this.localInfo.minutesValue) }, { value: 15 * ticksPerMinute, text: String.format('15 {0}', _this.localInfo.minutesValue) }, { value: 30 * ticksPerMinute, text: String.format('30 {0}', _this.localInfo.minutesValue) }, { value: ticksPerHour, text: String.format('1 {0}', _this.localInfo.hourValue) }, { value: 2 * ticksPerHour, text: String.format('2 {0}', _this.localInfo.hoursValue) }, { value: 3 * ticksPerHour, text: String.format('3 {0}', _this.localInfo.hoursValue) }, { value: 4 * ticksPerHour, text: String.format('4 {0}', _this.localInfo.hoursValue) }, { value: 5 * ticksPerHour, text: String.format('5 {0}', _this.localInfo.hoursValue) }, { value: 6 * ticksPerHour, text: String.format('6 {0}', _this.localInfo.hoursValue) }, { value: 7 * ticksPerHour, text: String.format('7 {0}', _this.localInfo.hoursValue) }, { value: 8 * ticksPerHour, text: String.format('8 {0}', _this.localInfo.hoursValue) }, { value: 9 * ticksPerHour, text: String.format('9 {0}', _this.localInfo.hoursValue) }, { value: 10 * ticksPerHour, text: String.format('10 {0}', _this.localInfo.hoursValue) }, { value: 11 * ticksPerHour, text: String.format('11 {0}', _this.localInfo.hoursValue) }, { value: 12 * ticksPerHour, text: String.format('12 {0}', _this.localInfo.hoursValue) }, { value: ticksPerDay, text: String.format('1 {0}', _this.localInfo.dayValue) }, { value: 2 * ticksPerDay, text: String.format('2 {0}', _this.localInfo.daysValue) }];
        return _this;
    }

    /**
    * For internal use only.
    * @private
    */


    createClass(EditForm, [{
        key: '_getItemContacts',
        value: function _getItemContacts() {
            if (this.item != null) {

                var contacts = this.item.contacts;

                if (contacts != null) {

                    var result = [];

                    for (var i = 0, l = contacts.count(); i < l; i++) {
                        for (var j = 0, m = this.calendar._schedule.contacts.count(); j < m; j++) {
                            if (contacts.items()[i].equals(this.calendar._schedule.contacts.items()[j])) {
                                result.push(j.toString());
                                break;
                            }
                        }
                    }
                    return result;
                }
            }
            return null;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: '_getItemLocationIndex',
        value: function _getItemLocationIndex() {
            if (this.item != null && this.item.location != null) {
                return this.calendar._schedule.locations.items().indexOf(this.item.location);
            }
            return -1;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'drawContent',
        value: function drawContent() {
            var _this2 = this;

            get(EditForm.prototype.__proto__ || Object.getPrototypeOf(EditForm.prototype), 'drawContent', this).call(this);

            var content = this.getContent();

            var item = this.item;if (item == null) item = {};

            // Create Subject
            var initValue = item.subject;
            // if (this._type == "edit") {
            //     if (this.calendar.itemSettings.enableTags) {
            //         initValue = item.subject;
            //     }
            //     else
            //         initValue = item.subject;
            // }
            var newControl = this.createTextBox({ id: "subject", events: { keydown: this._areaKeyDown }, initValue: initValue });
            newControl.element.style.width = "355px";
            var s = document.createElement("span");
            s.className = "mfp-text-label-fixed";
            s.innerHTML = this.localInfo.subjectCaption;

            var newRow = this.row();
            DomUtils.addCssClass(newRow, "mfp-subject");
            newRow.appendChild(s);
            newRow.appendChild(newControl.element);
            content.appendChild(newRow);
            this.addControl(newControl);

            // Create Location
            var locationId = item.location != null ? item.location.id : "";
            newControl = this.createDropDownList({ id: "location", items: this._getLocations(), initValue: this._getItemLocationIndex() });
            newControl.element.style.width = "45%";
            var s = document.createElement("span");
            s.className = "mfp-text-label-fixed";
            s.innerHTML = this.localInfo.locationCaption;

            newRow = this.row();
            DomUtils.addCssClass(newRow, "mfp-location");
            newRow.appendChild(s);
            newRow.appendChild(newControl.element);

            content.appendChild(newRow);
            this.addControl(newControl);
            // Create Horizontal Line
            content.appendChild(this.divider());
            var isAllDayItem = item.allDayEvent === true;

            //Create time div
            // var timeDiv = new this.row();
            // timeDiv.id = 'TimeDiv';
            // timeDiv.style.display = 'block';
            // this.addControl(timeDiv);

            // start date
            var sDate = new DateTime(item.startTime.getDate());
            var options = {
                id: "startDate",
                type: "date",
                initValue: sDate,
                localInfo: this.localInfo
            };
            newControl = this.createEditBox(options);
            var s = document.createElement("span");
            s.className = "mfp-text-label-fixed";
            s.innerHTML = this.localInfo.startTimeCaption;

            newRow = this.row();
            DomUtils.addCssClass(newRow, "mfp-startTime");
            newRow.appendChild(s);
            newRow.appendChild(newControl.element);

            this.addControl(newControl);

            // start time
            var options = {
                id: "startTime",
                type: "time",
                initValue: item.startTime.clone(),
                localInfo: this.localInfo
            };
            if (isAllDayItem === true) options.visible = false;
            newControl = this.createEditBox(options);
            newRow.appendChild(newControl.element);
            this.addControl(newControl);

            // all day
            var res = this.createCheckBox({ id: "allDayEvent", text: this.localInfo.allDayEventCaption, initValue: isAllDayItem });
            newControl = res.control;
            newControl.element.addEventListener("change", function (e) {
                return _this2.onAllDayChange(e);
            });
            newRow.appendChild(newControl.element);
            newRow.appendChild(res.label);
            this.addControl(newControl);
            content.appendChild(newRow);
            //timeDiv.appendChild(newRow);

            // end date
            var eDate = new DateTime(item.endTime.getDate());
            if (isAllDayItem == true) {
                var tZoneDiff = eDate.__getTimezoneOffset() - sDate.__getTimezoneOffset();
                var dayLen = DateTime.MillisPerDay + tZoneDiff * 60 * 1000;
                if (eDate._date.valueOf() - sDate._date.valueOf() >= dayLen) {
                    eDate.addDays(-1);
                    this.subtractedEndDate = true;
                }
            }
            var options = {
                id: "endDate",
                type: "date",
                initValue: eDate,
                localInfo: this.localInfo
            };
            newControl = this.createEditBox(options);
            var s = document.createElement("span");
            s.className = "mfp-text-label-fixed";
            s.innerHTML = this.localInfo.endTimeCaption;

            newRow = this.row();
            DomUtils.addCssClass(newRow, "mfp-endTime");
            newRow.appendChild(s);
            newRow.appendChild(newControl.element);

            this.addControl(newControl);

            // end time
            var options = {
                id: "endTime",
                type: "time",
                initValue: item.endTime.clone(),
                localInfo: this.localInfo
            };
            if (isAllDayItem === true) options.visible = false;
            newControl = this.createEditBox(options);
            newRow.appendChild(newControl.element);
            this.addControl(newControl);
            content.appendChild(newRow);
            // timeDiv.appendChild(newRow);
            // content.appendChild(timeDiv);

            // recurrence info
            newRow = this.row();
            DomUtils.addCssClass(newRow, "mfp-recurrence-info");
            //newRow.id = 'recurrence-info';
            //this.addControl(newRow);

            var info = document.createElement("span");
            info.className = "mfp-text-label";
            newRow.appendChild(info);
            content.appendChild(newRow);

            this.updateRecurrenceInfo();

            content.appendChild(this.divider());

            var hasReminder = item.reminder != null && item.reminder.type == 1;
            var res = this.createCheckBox({ id: "reminderCheck", text: this.localInfo.reminderCaption, initValue: hasReminder });
            newControl = res.control;
            newControl.element.addEventListener("change", function (e) {
                return _this2.onReminderChange(e);
            });
            newControl.element.style["line-height"] = "32px";
            var s = document.createElement("span");
            s.className = "mfp-reminder-img";

            var newRow = this.row();
            DomUtils.addCssClass(newRow, "mfp-reminder");
            newRow.appendChild(s);
            newRow.appendChild(newControl.element);
            newRow.appendChild(res.label);

            this.addControl(newControl);

            // reminder 
            var iValue = hasReminder ? item.reminder.timeInterval.ticks : 15 * DateTime.TicksPerMinute;
            var match = false;
            for (var i = 0, l = this.reminderTexts.length; i < l; i++) {
                if (iValue == this.reminderTexts[i].value) {
                    match = true;
                    break;
                }
            }

            options = {
                id: "reminder",
                items: this.reminderTexts,
                initValue: hasReminder && match ? iValue : 15 * DateTime.TicksPerMinute,
                addEmptyValue: false
            };

            newControl = this.createDropDownList(options);
            newControl.element.style.width = "100px";
            newControl.element.disabled = !hasReminder;
            newRow.appendChild(newControl.element);
            this.addControl(newControl);
            content.appendChild(newRow);

            content.appendChild(this.divider());

            var newRow = this.row();

            var newCol = this.col();
            DomUtils.addCssClass(newCol, "details");
            newRow.appendChild(newCol);

            initValue = "";
            if (this._type == "edit") {
                if (this.calendar.itemSettings.enableTags) {
                    initValue = item.details;
                } else {
                    initValue = item.details;
                }
            }
            newControl = this.createTextArea({ id: "details", initValue: initValue });
            var style = newControl.element.style;
            style.height = "100px";
            style.width = "206px";

            var s = document.createElement("span");
            s.className = "mfp-text-label-fixed";
            s.innerHTML = this.localInfo.detailsCaption;
            newCol.appendChild(s);

            newCol.appendChild(newControl.element);
            this.addControl(newControl);

            var newCol = this.col();
            DomUtils.addCssClass(newCol, "contacts");
            newRow.appendChild(newCol);

            //contacts
            var options = { id: "contacts", items: this._getContacts(), selectedValues: this._getItemContacts() };
            newControl = this.createCheckBoxList(options);

            var s = document.createElement("span");
            s.className = "mfp-text-label-fixed";
            s.innerHTML = this.localInfo.contactsCaption;
            newCol.appendChild(s);

            newCol.appendChild(newControl.element);
            this.addControl(newControl);
            content.appendChild(newRow);

            content.appendChild(this.divider());

            return content;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'drawButtons',
        value: function drawButtons() {
            var _this3 = this;

            // super.drawButtons();
            // Add Save Button
            var newButton = this.createButton({ id: "btnSave", text: this.localInfo.saveButtonCaption, events: { click: function click(e) {
                        return _this3.onSaveButtonClick(e);
                    } } });
            var buttons = this.row();
            DomUtils.addCssClass(buttons, "mfp-buttons-row");
            buttons.appendChild(newButton.element);

            this.addControl(newButton);
            // Add Delete Button
            if (this._type == 'edit') {
                newButton = this.createButton({ id: "btnDelete", text: this.localInfo.deleteButtonCaption, events: { click: function click(e) {
                            return _this3.onDeleteButtonClick(e);
                        } } });
                buttons.appendChild(newButton.element);
                this.addControl(newButton);
            }
            // Add Cancel Button
            newButton = this.createButton({ id: "btnCancel", text: this.localInfo.cancelButtonCaption, events: { click: function click(e) {
                        return _this3.onCancelButtonClick(e);
                    } } });
            buttons.appendChild(newButton.element);
            this.addControl(newButton);
            // Add Recurrence Button
            newButton = this.createButton({ id: "btnRecurrence", text: this.localInfo.recurrenceButtonCaption, events: { click: function click(e) {
                        return _this3.onRecurrenceButtonClick(e);
                    } } });
            buttons.appendChild(newButton.element);
            this.addControl(newButton);
            // Add Buttons To Form
            this._buttons = buttons;
            return buttons;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getChanges',
        value: function getChanges(type) {
            var appItem = {};
            var currentItem = this.item;

            var changed = false;
            if (type == 'new') changed = true;

            var appItemSubject = this._controls["subject"].getValue();
            if (appItemSubject != currentItem.subject || type == 'new') {
                changed = true;
                appItem.subject = appItemSubject;
            }

            // Get appointment details
            var appItemDetails = this._controls["details"].getValue();
            if (appItemDetails != currentItem.details) {
                changed = true;
                appItem.details = appItemDetails;
            }

            var appItemAllDayEvent = this._controls["allDayEvent"].getValue();
            if (appItemAllDayEvent != currentItem.allDayEvent || type == 'new') {
                changed = true;
                appItem.allDayEvent = appItemAllDayEvent;
            }

            //start and endtime
            var datebox = this._controls["startDate"].value;
            var timebox = this._controls["startTime"].value;
            if (appItemAllDayEvent === true) {
                var start = datebox.getDate();
            } else {
                var start = DateTime.combine(datebox, timebox)._date;
            }

            datebox = this._controls["endDate"].value;
            timebox = this._controls["endTime"].value;
            if (appItemAllDayEvent === true) {
                var end = datebox.addDays(1).getDate();
            } else {
                var end = DateTime.combine(datebox, timebox)._date;
            }

            if (start.valueOf() > end.valueOf()) start = end;

            if (type == 'new') {
                appItem.startTime = new DateTime(start);
            } else if (currentItem.startTime._date.valueOf() != start.valueOf()) {
                appItem.startTime = new DateTime(start);
                changed = true;
            }

            if (type == 'new') {
                appItem.endTime = new DateTime(end);
            } else if (currentItem.endTime._date.valueOf() != end.valueOf()) {
                appItem.endTime = new DateTime(end);
                changed = true;
            }

            //reminder
            var hasReminder = this._controls["reminderCheck"].getValue();
            if (hasReminder) {
                var ticks = +this._controls["reminder"].getValue();

                if (currentItem.reminder != null) {
                    //existing reminder changed
                    if (currentItem.reminder.timeInterval != ticks) {
                        appItem.reminder = new Reminder({ timeInterval: new TimeSpan(ticks) }, 0);
                        changed = true;
                    }
                } else {
                    //new reminder added
                    appItem.reminder = new Reminder({ timeInterval: new TimeSpan(ticks) }, 0);
                    changed = true;
                }
            } else {
                if (currentItem.reminder != null) {
                    //reminder deleted
                    appItem.reminder = null;
                    changed = true;
                }
            }

            //location
            var index = this._controls["location"].getValue();
            if (index.length > 0) {
                //location changed
                var appItemLocation = this.calendar._schedule.locations.items()[index];
            } else {
                //location cleared
                var appItemLocation = null;
            }
            if (appItemLocation != currentItem.location) {
                changed = true;
                appItem.location = appItemLocation;
            }
            if (type == 'new' && appItemLocation) {
                appItem.location = appItemLocation;
            }

            //contacts
            var ctrl = this._controls["contacts"];
            var contacts = [];
            var c = ctrl.getSelected();
            for (var i = 0, l = c.length; i < l; i++) {
                contacts.push(this.calendar._schedule.contacts.items()[c[i]]);
            }

            var getContacts = false;
            if (type == 'new') {
                getContacts = true;
                if (currentItem.resources != undefined) {
                    appItem.resources = currentItem.resources;
                }
                if (currentItem.task != undefined) {
                    appItem.task = currentItem.task;
                }
            }

            if (currentItem.contacts == null && contacts.length > 0) {
                //new contacts collection
                appItem.contacts = contacts;
                changed = true;
            } else if (currentItem.contacts && contacts.length != currentItem.contacts.count()) {
                //contacts collection changed
                appItem.contacts = contacts;
                changed = true;
            } else if (currentItem.contacts && contacts.length == currentItem.contacts.count()) {
                for (var i = 0, l = contacts.length; i < l; i++) {
                    if (!contacts[i].equals(currentItem.contacts.items()[i])) {
                        getContacts = true;
                        changed = true;
                        break;
                    }
                }
                //contacts collection changed
                if (getContacts) appItem.contacts = contacts;
            }

            //recurrence
            if (currentItem.currentRecurrence) {

                if (currentItem.recurrence) {
                    if (!currentItem.recurrence.samePatternAs(currentItem.currentRecurrence)) {
                        //existing recurrence modified
                        // appItem.recurrence = new Recurrence();
                        // appItem.recurrence.extend(currentItem.currentRecurrence);//, this.culture.dateTimeFormat);
                        appItem.recurrence = currentItem.currentRecurrence;
                        currentItem.currentRecurrence = undefined;
                        appItem.recurrenceChanged = true;
                        changed = true;
                    }
                } else {
                    //new recurrence created
                    appItem.recurrence = new Recurrence();
                    appItem.recurrence.extend(currentItem.currentRecurrence); //, this.culture.dateTimeFormat);
                    currentItem.currentRecurrence = undefined;
                    //TEMP!!!
                    appItem.recurrenceState = RecurrenceState.Master;
                    changed = true;
                }
            } else if (currentItem.currentRecurrence === null) {
                if (currentItem.recurrence) {
                    //existing recurrence removed
                    appItem.recurrence = null;
                    changed = true;
                }
            }

            if (changed) {
                // appItem.id = currentItem.id;
                // appItem.occurrenceIndex = currentItem.occurrenceIndex;
                return appItem;
            } else return null;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'setRecurrence',
        value: function setRecurrence(value) {
            this.recurrence = value;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onSaveButtonClick',
        value: function onSaveButtonClick(e) {
            var args = this.getChanges(this._type);
            if (args != null) {
                if (this._type === 'new') {
                    this.calendar.createItem(args, "EditForm");
                } else {
                    var changes = DomUtils.extend({}, args);
                    this.calendar.editItem(this.item, changes);
                }
            }
            if (this.calendar.popups.get("RecurrenceForm")) {
                this.closeForm("RecurrenceForm");
            }
            if (this.calendar.popups.get("ItemsCueForm")) {
                this.closeForm("ItemsCueForm");
            }
            this.closeForm();
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onDeleteButtonClick',
        value: function onDeleteButtonClick(e) {
            this.calendar.deleteItem(this.item);

            if (this.calendar.popups.get("ItemsCueForm")) {
                this.closeForm("ItemsCueForm");
            }
            this.closeForm();
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onCancelButtonClick',
        value: function onCancelButtonClick(e) {
            this.item.currentRecurrence = undefined;
            if (this.calendar.popups.get("RecurrenceForm")) {
                this.closeForm("RecurrenceForm");
            }
            if (this.calendar.popups.get("ItemsCueForm")) {
                this.closeForm("ItemsCueForm");
            }
            this.closeForm();
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onRecurrenceButtonClick',
        value: function onRecurrenceButtonClick(e) {
            if (!this.calendar.popups.get("RecurrenceForm")) {
                var p = new RecurrenceForm(this.calendar, this.item, null);
                p.showForm();
            }
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onCloseButtonClick',
        value: function onCloseButtonClick(e) {
            if (this.calendar.popups.get("RecurrenceForm")) {
                this.closeForm("RecurrenceForm");
            }
            if (this.calendar.popups.get("ItemsCueForm")) {
                this.closeForm("ItemsCueForm");
            }
            this.closeForm();
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'setTimeControls',
        value: function setTimeControls(allDay) {
            if (allDay == true) {
                this._controls["startTime"].element.style.display = "none";
                this._controls["endTime"].element.style.display = "none";
            } else {
                this._controls["startTime"].element.style.display = "";
                this._controls["endTime"].element.style.display = "";
            }

            var cStart = this._controls['startDate'].value;
            var endDateBox = this._controls['endDate'];
            var cEnd = endDateBox.value;
            var newValue = cEnd.clone();

            var tZoneDiff = cEnd.__getTimezoneOffset() - cStart.__getTimezoneOffset();
            var dayLen = DateTime.MillisPerDay + tZoneDiff * 60 * 1000;

            if (allDay) {
                if (cEnd._date.valueOf() - cStart._date.valueOf() >= dayLen) {
                    this.subtractedEndDate = true;
                    newValue.addDays(-1);
                    endDateBox.oldValue = endDateBox._textBox.value;
                    endDateBox._updateValue(newValue._date.valueOf());
                } else {
                    this.subtractedEndDate = false;
                }
            } else {
                if (this.subtractedEndDate === true) {
                    newValue.addDays(1);
                    endDateBox.oldValue = endDateBox._textBox.value;
                    endDateBox._updateValue(newValue._date.valueOf());
                }
            }
        }

        /**
        * @private
        */

    }, {
        key: 'updateRecurrenceInfo',
        value: function updateRecurrenceInfo() {
            if (this.item.currentRecurrence) {
                this.showRecurrenceInfo(this.item.currentRecurrence);
            } else if (this.item.recurrence && this.item.currentRecurrence !== null) {
                this.showRecurrenceInfo(this.item.recurrence);
            } else {
                // this._controls["recurrence-info"].style.display = 'none';
                this.content.querySelector(".mfp-recurrence-info").style.display = 'none';
            }
        }
    }, {
        key: 'showRecurrenceInfo',
        value: function showRecurrenceInfo(recurrence) {
            //var d = this._controls["recurrence-info"];
            //var recText = d.childNodes[0];
            // infoDiv.querySelectorAll("span")[1];
            //var recImg = infoDiv.querySelectorAll("span")[0];
            var s = this.content.querySelector(".mfp-recurrence-info").childNodes[0];
            var recInfo = '';

            var r = recurrence.clone();

            if (r) {
                recInfo = r.toLocalizedString(this.formatInfo, this.localInfo);
                // var validationArgs = new RecurrenceStringValidationEventArgs({ recurrence: dummy, resultString: recInfo });
                // this.calendar.raiseEvent("onRecurrenceStringValidation", validationArgs);
                // recInfo = validationArgs.get_resultString();
                s.innerHTML = recInfo;
                DomUtils.addCssClass(s, this.item.recurrenceState == 2 ? "mfp-exception" : "mfp-recurrence");
                // recImg.className = (this.item.recurrenceState == 2) ? "exception-img" : "recurrence-img";
                s.parentNode.style.display = 'block';
            }
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onAllDayChange',
        value: function onAllDayChange(e) {
            this.setTimeControls(e.target.checked);
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onReminderChange',
        value: function onReminderChange(e) {
            this._controls["reminder"].element.disabled = !this._controls["reminderCheck"].getValue();
        }

        /**
        * Gets the item currently modified through the form
        * @returns {Item} The item.
        */

    }, {
        key: 'getItem',
        value: function getItem() {
            return this.item;
        }

        /**
        * Sets the item currently modified through the form
        * @param {Item} value The item.
        */

    }, {
        key: 'setItem',
        value: function setItem(value) {
            this.item = value;
        }
    }]);
    return EditForm;
}(BaseForm);

/**
* For internal use only.
* @private
*/

var InplaceEdit = function () {
    function InplaceEdit(view, appointment) {
        var _this = this;

        classCallCheck(this, InplaceEdit);


        this.view = view;
        this.calendar = view.calendar;
        this.appointment = appointment;
        this.item = appointment.item;
        this.element = appointment.element;
        this.stopped = true;

        this.containerClickHandler = function (e) {
            return _this.onContainerClick(e);
        };
        this.view.getElement().addEventListener('mouseup', this.containerClickHandler);

        this.clickHandler = function (e) {
            return _this.onClick(e);
        };
        this.element.addEventListener('click', this.clickHandler);

        this.doubleClickHandler = function (e) {
            return _this.onDoubleClick(e);
        };
        this.element.addEventListener('dblclick', this.doubleClickHandler);
    }

    createClass(InplaceEdit, [{
        key: 'dispose',
        value: function dispose() {
            this.view.getElement().removeEventListener('mouseup', this.containerClickHandler);
            this.element.removeEventListener('click', this.clickHandler);
            this.element.removeEventListener('dblclick', this.doubleClickHandler);
        }
    }, {
        key: 'onContainerClick',
        value: function onContainerClick(e) {
            if (!this.view.inplaceEditing) return;
            if (e.target.className === 'mfp-inplace') {
                return;
            }
            this.onInplaceInputBlur(e, true);
        }
    }, {
        key: 'onClick',
        value: function onClick(e) {
            var _this2 = this;

            if (this.view._selectionPaused) return;
            if (this.stopped) return;

            if (this.calendar.itemCloneKeyPressed(e)) {
                return;
            } else if (e.ctrlKey) return;

            this.popupMode = this.calendar.popups.get("ItemsCueForm");

            if (this.calendar.allowInplaceEdit && !this.item.locked && !this.popupMode) {

                if (this.calendar.onItemInplaceEditStart(new ItemEventArgs(this.item))) {

                    if (this.clickTimer) clearTimeout(this.clickTimer);

                    this.clickTimer = setTimeout(function () {
                        _this2.inplaceEdit();
                    }, 500);
                }
            }
        }
    }, {
        key: 'onDoubleClick',
        value: function onDoubleClick(e) {
            clearTimeout(this.clickTimer);
        }
    }, {
        key: 'inplaceEdit',
        value: function inplaceEdit() {
            var _this3 = this;

            if (this.view.inplaceEditing || this.appointment.Dom.inplaceInput || this.stopped) {
                return;
            }
            this.view.inplaceEditing = true;
            this.view._selectionPaused = true;

            var container = this.appointment.Dom.header.parentNode;
            if (container) {
                var input = document.createElement("input");
                input.type = "text";
                input.className = "mfp-inplace";
                input.value = this.appointment.item.subject;

                this.inplaceInputFocusHandler = function (e) {
                    return _this3.onInplaceInputFocus(e);
                };
                input.addEventListener('focus', this.inplaceInputFocusHandler);

                this.inplaceInputBlurHandler = function (e) {
                    return _this3.onInplaceInputBlur(e);
                };
                input.addEventListener('blur', this.inplaceInputBlurHandler);

                this.inplaceInputKeyUpHandler = function (e) {
                    return _this3.onInplaceInputKeyUp(e);
                };
                input.addEventListener('keyup', this.inplaceInputKeyUpHandler);

                Array.prototype.forEach.call(container.childNodes, function (c) {
                    c.style.display = "none";
                });

                container.appendChild(input);
                this.appointment.Dom.inplaceInput = input;

                setTimeout(function () {
                    _this3.focusInput();
                }, 100);
            }
            return true;
        }
    }, {
        key: 'onInplaceInputFocus',
        value: function onInplaceInputFocus(e) {
            e.target.value = e.target.value;
            e.target.select();
        }
    }, {
        key: 'onInplaceInputBlur',
        value: function onInplaceInputBlur(e, allowed) {
            if (this.view.inplaceEditing == false || this.appointment.Dom.inplaceInput == null) return;

            this.view._selectionPaused = false;

            var result = this.calendar.onItemInplaceEditEnd(new ItemEventArgs(this.item));
            if (result === false) allowed = result;

            if (allowed !== false) {
                if (this.item.subject != this.appointment.Dom.inplaceInput.value) {
                    var args = { subject: this.appointment.Dom.inplaceInput.value };
                    this.clearInput();
                    this.calendar.editItem(this.item, args, true);
                } else {
                    this.clearInput();
                }
            } else {
                this.clearInput();
            }

            delete this.appointment.Dom.inplaceInput;
            this.view.inplaceEditing = false;
        }
    }, {
        key: 'onInplaceInputKeyUp',
        value: function onInplaceInputKeyUp(e) {
            if (e.keyCode === 13) {
                this.onInplaceInputBlur(e, true);
                return true;
            }
            if (e.keyCode === 27) {
                this.onInplaceInputBlur(e, false);
                return true;
            }
        }
    }, {
        key: 'clearInput',
        value: function clearInput() {
            Array.prototype.forEach.call(this.appointment.Dom.header.parentNode.childNodes, function (c) {
                c.style.display = "";
            });

            if (this.appointment.Dom.inplaceInput !== null) {
                this.appointment.Dom.inplaceInput.removeEventListener('focus', this.inplaceInputFocusHandler);
                this.appointment.Dom.inplaceInput.removeEventListener('blur', this.inplaceInputBlurHandler);

                DomUtils.removeNode(this.appointment.Dom.inplaceInput);
            }
        }
    }, {
        key: 'focusInput',
        value: function focusInput() {
            if (this.appointment) {
                if (this.appointment.Dom.inplaceInput) {
                    try {
                        this.appointment.Dom.inplaceInput.focus();
                        this.appointment.Dom.inplaceInput.select();
                    } catch (ex) {}
                }
            }
        }
    }]);
    return InplaceEdit;
}();

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/** 
* Provides a visual representation for a calendar item.
* @private
*/

var Appointment = function () {
    function Appointment(args) {
        classCallCheck(this, Appointment);

        if (args.prototype) {
            this.createPart(args);
        } else if (args.create) {
            this.create(args);
        } else if (args.edit) {
            return this.edit(args);
        } else if (args.occurrence) {
            this.createOccurrence(args);
        }

        if (!this.calendar.itemSettings.showItems || this.item.visible == false) {
            this.Dom.element.style.display = 'none';
        }

        this.attachHandlers();

        this.inplaceEdit = new InplaceEdit(this.view, this);

        return this;
    }

    createClass(Appointment, [{
        key: 'dispose',
        value: function dispose() {
            this.inplaceEdit.dispose();
            this.clearHandlers();

            DomUtils.removeNode(this.Dom.wrapper, this.view.getElement());
        }
    }, {
        key: 'clearHandlers',
        value: function clearHandlers() {
            this.element.removeEventListener('mousedown', this.mouseDownHandler);
            this.element.removeEventListener('mouseup', this.mouseUpHandler);
            this.element.removeEventListener('click', this.clickHandler);
            this.element.removeEventListener('dblclick', this.doubleClickHandler);
        }
    }, {
        key: 'attachHandlers',
        value: function attachHandlers() {
            var _this = this;

            this.clearHandlers();

            this.mouseDownHandler = function (e) {
                return _this.onMouseDown(e);
            };
            this.element.addEventListener('mousedown', this.mouseDownHandler);

            this.mouseUpHandler = function (e) {
                return _this.onMouseUp(e);
            };
            this.element.addEventListener('mouseup', this.mouseUpHandler);

            this.clickHandler = function (e) {
                return _this.onClick(e);
            };
            this.element.addEventListener('click', this.clickHandler);

            this.doubleClickHandler = function (e) {
                return _this.onDoubleClick(e);
            };
            this.element.addEventListener('dblclick', this.doubleClickHandler);
        }
    }, {
        key: 'create',


        /** 
        * For internal use only.
        * @private
        * Creates a new appointment.
        */
        value: function create(data) {
            this.view = data.view;
            this.calendar = this.view.calendar;

            this.item = data.item;
            this.orientation = this.view.orientation || 0;
            this.isHeader = data.isHeader || false;
            this.length = this.getLength(this.item);

            var wrapper = this.createVisual();
        }

        /** 
        * For internal use only.
        * @private
        * Creates a new appointment as a part.
        */

    }, {
        key: 'createPart',
        value: function createPart(data) {
            this.view = data.prototype.view;
            this.calendar = data.prototype.calendar;
            this.item = data.prototype.item;

            var wrapper = data.prototype.Dom.wrapper.cloneNode(true);
            var element = DomUtils.firstRealChild(wrapper);
            var content = DomUtils.firstRealChild(element);
            var header = element.querySelector('.mfp-subject');
            var details = element.querySelector('.mfp-details');
            this.Dom = { element: element, wrapper: wrapper, content: content, header: header, details: details };
            if (data.prototype.Dom.post) this.Dom.post = element.querySelector('.mfp-time-indicator');

            this.orientation = data.prototype.view.orientation || 0;
            this.length = this.getLength(this.item);
            this.isPartial = data.isPartial;
            this.partIndex = data.partIndex;
            this.isHeader = data.isHeader || false;
            this.cellIndex = data.cellIndex;
            this.cellsLength = data.cellsLength;
            if (this.cellsLength < 1) {
                this.cellsLength = 1;
            }
            this.startCellIndex = data.startCellIndex;
            this.lastCellIndex = data.lastCellIndex;
            this.monthCellIndex = data.monthCellIndex;
            this.groupColumnIndex = data.groupColumnIndex;
        }

        /** 
        * For internal use only.
        * @private
        * Creates a new appointment as an occurrence.
        */

    }, {
        key: 'createOccurrence',
        value: function createOccurrence(data) {
            this.view = data.view;
            this.calendar = this.view.calendar;
            this.isHeader = data.isHeader;

            this.item = data.item;

            this.orientation = this.view.orientation || 0;
            this.length = this.getLength(this.item);

            // edited occurrence.
            var prototype = this.calendar.getAppointmentById(data.item.id, data.item.occurrenceIndex);
            if (prototype !== null && (typeof prototype === 'undefined' ? 'undefined' : _typeof(prototype)) !== undefined) {
                this.Dom = prototype.Dom;
            }
            // new occurrences
            else {
                    var masterAsOccurrence = this.calendar.getAppointmentById(data.item.id, -1);
                    if (masterAsOccurrence !== null && (typeof masterAsOccurrence === 'undefined' ? 'undefined' : _typeof(masterAsOccurrence)) !== undefined) {
                        var wrapper = this.createVisual(masterAsOccurrence);
                    } else {
                        var wrapper = this.createVisual();
                    }
                }
        }

        /** 
        * For internal use only.
        * @private
        * Modifies the appointment.
        */

    }, {
        key: 'edit',
        value: function edit(data) {
            this.view = data.view;
            this.calendar = this.view.calendar;

            var prototype = this.view.getItemAppointment(data.item.item);
            prototype.removeParts();

            prototype.isHeader = data.isHeader;
            prototype.length = this.getLength(prototype.item);
            prototype.orientation = prototype.view.orientation || 0;
            if (this.calendar.showTooltips === true) {
                prototype.element.title = this.calendar.formatTooltip(prototype.item, this.calendar.itemSettings.tooltipFormat);
            }
            if (prototype.item.visible == false || !this.calendar.itemSettings.showItems) {
                prototype.element.style.display = 'none';
            }
            return prototype;
        }

        /** 
        * For internal use only.
        * @private
        * Creates the appointment's visual.
        */

    }, {
        key: 'createVisual',
        value: function createVisual(prototype) {
            if (prototype) {
                var wrapper = prototype.Dom.wrapper.cloneNode(true);

                var element = DomUtils.firstRealChild(wrapper);
                var header = element.querySelector('.mfp-subject');
                var details = element.querySelector('.mfp-details');
                var post = element.querySelector('.mfp-time-indicator');

                this.Dom = { element: element, wrapper: wrapper, header: header, details: details, post: post };

                return wrapper;
            }

            var itemSettings = this.calendar.itemSettings;

            if (this.calendar._currentView == CalendarView.Timetable && !this.isHeader) {

                var wrapper = document.createElement("div");
                wrapper.className = "mfp-item-wrap";

                if (this.view.orientation == Orientation.Horizontal) {
                    wrapper.style.position = 'absolute';
                    wrapper.style.height = '100%';
                    wrapper.style.float = 'left';
                } else wrapper.style.position = 'relative';

                var element = document.createElement("div");
                DomUtils.addCssClass(element, "mfp-item-container");

                var id = IdGenerator.generate('APP');
                element.id = id;

                if (this.view.orientation == Orientation.Horizontal) {
                    DomUtils.addCssClass(element, "mfp-item-horizontal-detail");
                    element.style.height = '100%';
                } else {
                    DomUtils.addCssClass(element, "mfp-item-vertical-detail");
                    element.style.width = '100%';
                }
                DomUtils.addCssClass(element, this.calendar.itemSettings.cssClass);
                DomUtils.addCssClass(element, this.item.cssClass);

                if (this.calendar.showTooltips) {
                    element.title = this.calendar.formatTooltip(this.item, this.calendar.itemSettings.tooltipFormat);
                }

                wrapper.appendChild(element);

                var content = document.createElement("div");
                DomUtils.addCssClass(content, "mfp-item");
                element.appendChild(content);

                var wrap = document.createElement("div");
                wrap.className = "mfp-time-indicator-wrapper";
                content.appendChild(wrap);

                var time = document.createElement("div");
                time.className = "mfp-time-indicator";
                wrap.appendChild(time);

                var inwrap = document.createElement("div");
                DomUtils.addCssClass(inwrap, "mfp-item-inwrap");
                content.appendChild(inwrap);

                var header = document.createElement("div");
                header.className = "mfp-subject";
                inwrap.appendChild(header);

                var details = document.createElement("div");
                details.className = "mfp-details";
                inwrap.appendChild(details);

                this.Dom = { element: element, content: content, wrapper: wrapper, header: header, details: details, post: time };
                return wrapper;
            } else if (this.calendar.currentView == CalendarView.List && this.view.orientation == Orientation.Vertical || this.calendar.currentView == CalendarView.Timetable && this.view.orientation == Orientation.Horizontal && this.isHeader) {

                var wrapper = document.createElement("div");
                wrapper.className = "mfp-item-wrap";

                var element = document.createElement("div");
                DomUtils.addCssClass(element, "mfp-item-container");
                DomUtils.addCssClass(element, "mfp-item-vertical");
                var id = IdGenerator.generate('APP');
                element.id = id;
                element.style.width = itemSettings.size + 'px';

                DomUtils.addCssClass(element, itemSettings.cssClass);
                DomUtils.addCssClass(element, this.item.cssClass);

                if (this.calendar.showTooltips) {
                    element.title = this.calendar.formatTooltip(this.item, this.calendar.itemSettings.tooltipFormat);
                }

                wrapper.appendChild(element);

                var content = document.createElement("div");
                DomUtils.addCssClass(content, "mfp-item");
                element.appendChild(content);

                var header = document.createElement("div");
                header.className = "mfp-subject";
                content.appendChild(header);

                this.Dom = { element: element, content: content, wrapper: wrapper, header: header };
                return wrapper;
            } else {
                var wrapper = document.createElement("div");
                wrapper.className = "mfp-item-wrap";

                var element = document.createElement("div");
                DomUtils.addCssClass(element, "mfp-item-container");
                DomUtils.addCssClass(element, "mfp-item-horizontal");

                var id = IdGenerator.generate('APP');
                element.id = id;
                element.style.height = itemSettings.size + 'px';

                DomUtils.addCssClass(element, itemSettings.cssClass);
                DomUtils.addCssClass(element, this.item.cssClass);

                if (this.calendar.showTooltips) {
                    element.title = this.calendar.formatTooltip(this.item, this.calendar.itemSettings.tooltipFormat);
                }

                wrapper.appendChild(element);

                var content = document.createElement("div");
                DomUtils.addCssClass(content, "mfp-item");
                element.appendChild(content);

                var header = document.createElement("div");
                header.className = "mfp-subject";
                content.appendChild(header);

                this.Dom = { element: element, content: content, wrapper: wrapper, header: header };
                return wrapper;
            }
        }

        /** 
        * For internal use only.
        * @private
        * Recreates the appointment's visual.
        * Used when dragging appointments between header and schedule areas in Timetable view.
        */

    }, {
        key: 'recreateVisual',
        value: function recreateVisual() {
            this.view.getContent().appendChild(this.Dom.wrapper);
            DomUtils.removeNode(this.Dom.wrapper, this.view.getContent());

            var wrapper = this.createVisual();

            this.attachHandlers();
        }
    }, {
        key: 'updateVisual',
        value: function updateVisual() {
            if (!this.item.visible) return;

            this.Dom.header.innerHTML = this.calendar.formatTooltip(this.item, this.calendar.itemSettings.titleFormat) || "&nbsp;";
            // this.item.subject || "&nbsp;";
            if (this.Dom.details) this.Dom.details.innerHTML = this.item.details || "&nbsp;";

            var el = this.Dom.element.querySelectorAll(".mfp-arrow, .mfp-icons");
            DomUtils.removeNodes(el, this.Dom.element);

            DomUtils.removeCssClass(this.Dom.element, "mfp-recurrence");
            DomUtils.removeCssClass(this.Dom.element, "mfp-exception");
            DomUtils.removeCssClass(this.Dom.element, "mfp-reminder");

            // prev arrow
            if (this.calendar.itemSettings.showContinuationArrows != false) {
                if (this.isPartial && this.partIndex >= 0) {

                    var d = document.createElement("div");
                    DomUtils.addCssClass(d, "mfp-arrow");
                    DomUtils.addCssClass(d, "mfp-prev");
                    d.style.lineHeight = this.calendar.itemSettings.size + "px";
                    var s = document.createElement("span");
                    d.appendChild(s);
                    this.Dom.content.appendChild(d);
                }
            }
            // Recurrence
            if (this.item.recurrence) {
                if (this.item.recurrenceState != 2) {
                    DomUtils.addCssClass(this.Dom.element, "mfp-recurrence");
                    /* if (this.calendar.itemSettings.showRecurrenceIcons != false) {
                         
                             var d = document.createElement("div");
                             DomUtils.addCssClass(d, "icon");
                             DomUtils.addCssClass(d, "recurrence");
                             if (this.calendar.itemSettings.recurrenceIcon)
                                 d.appendChild(this.calendar.itemSettings.recurrenceIcon);
                             this.Dom.content.appendChild(d);
                         }*/
                }

                if (this.item.recurrenceState == 2) {
                    DomUtils.addCssClass(this.Dom.element, "mfp-exception");
                    /*  if (this.calendar.itemSettings.showRecurrenceExceptionIcons != false) {
                          var d = document.createElement("div");
                          DomUtils.addCssClass(d, "icon");
                          DomUtils.addCssClass(d, "recurrence");
                          DomUtils.addCssClass(d, "exception");
                          if (this.calendar.itemSettings.recurrenceExceptionIcon)
                              d.appendChild(this.calendar.itemSettings.recurrenceExceptionIcon);
                          this.Dom.content.appendChild(d);
                      }*/
                }
            }
            // Reminder
            if (this.item.reminder) {
                DomUtils.addCssClass(this.Dom.element, "mfp-reminder");
                /*if (this.calendar.itemSettings.showReminderIcons != false) {
                    var d = document.createElement("div");
                    DomUtils.addCssClass(d, "icon");
                    DomUtils.addCssClass(d, "reminder");
                    if (this.calendar.itemSettings.reminderIcon)
                        d.appendChild(this.calendar.itemSettings.reminderIcon);
                    this.Dom.content.appendChild(d);
                }*/
            }

            var d = document.createElement("div");
            DomUtils.addCssClass(d, "mfp-icons");
            var s = document.createElement("span");
            d.appendChild(s);
            this.Dom.content.appendChild(d);

            // next arrow
            if (this.calendar.itemSettings.showContinuationArrows != false) {
                if (this.isPartial && this.partIndex <= 0) {
                    var d = document.createElement("div");
                    d.style.lineHeight = this.calendar.itemSettings.size + "px";
                    DomUtils.addCssClass(d, "mfp-arrow");
                    DomUtils.addCssClass(d, "mfp-next");
                    var s = document.createElement("span");
                    d.appendChild(s);
                    this.Dom.content.appendChild(d);
                }
            }
            // }

            this.updateResizeHandles();
        }

        /**
        * For internal use only.
        * @private
        * Updates appointments' resize handles.
        */

    }, {
        key: 'updateResizeHandles',
        value: function updateResizeHandles(inCueForm) {
            var container = this.element.querySelector('div.mfp-item-inwrap') || this.Dom.content;

            var resizeBandSizeWidth = this.calendar.itemSettings.resizeBandSize + 'px';
            var larrow = this.isPartial && this.partIndex >= 0;
            var rarrow = this.isPartial && this.partIndex <= 0;
            var lresize = this.element.querySelector('div.mfp-resize-start');
            var rresize = this.element.querySelector('div.mfp-resize-end');

            // resize-start if there is no arrow.prev and the item's not locked and allowChangeStart;
            if (inCueForm || larrow && lresize || lresize && (this.item.locked || !this.item.allowChangeStart)) {
                DomUtils.removeNode(lresize);
                // $mindfusion(lresize).remove();
            } else if (!larrow && !lresize && !this.item.locked && this.item.allowChangeStart) {
                // lresize = $mindfusion('<div class="resize-start"></div>"')[0];

                lresize = document.createElement('div');
                DomUtils.addCssClass(lresize, 'mfp-resize-start');

                // if (this.orientation == Orientation.Horizontal && this.calendar._currentView == CalendarView.Timetable && this.isHeader)
                //     lresize.style.height = resizeBandSizeWidth;
                // else if (this.orientation == Orientation.Vertical && !this.isHeader)
                //     lresize.style.height = resizeBandSizeWidth;
                // else
                //     lresize.style.width = resizeBandSizeWidth;
                container.appendChild(lresize);
            }

            // resize-end if there is no arrow.next and the item's not locked and allowChangeEnd;
            if (inCueForm || rarrow && rresize || lresize && (this.item.locked || !this.item.allowChangeEnd)) {
                DomUtils.removeNode(rresize);
                // $mindfusion(rresize).remove();
            } else if (!rarrow && !rresize && !this.item.locked && this.item.allowChangeEnd) {
                //rresize = $mindfusion('<div class="resize-end"></div>"')[0];

                rresize = document.createElement('div');
                DomUtils.addCssClass(rresize, 'mfp-resize-end');

                // if (this.orientation == Orientation.Horizontal && this.calendar._currentView == CalendarView.Timetable && this.isHeader)
                //     rresize.style.height = resizeBandSizeWidth;
                // else if (this.orientation == Orientation.Vertical && !this.isHeader)
                //     rresize.style.height = resizeBandSizeWidth;
                // else
                //     rresize.style.width = resizeBandSizeWidth;
                container.appendChild(rresize);
            }
        }

        /** 
        * For internal use only.
        * @private
        * Updates appointments' visual for display in items cue form.
        */

    }, {
        key: 'updateCueVisual',
        value: function updateCueVisual(cell) {
            // if (this.orientation == Orientation.Vertical ||
            //     (this.orientation == Orientation.Horizontal && this.calendar._currentView == CalendarView.Timetable && this.isHeader)) {
            //     DomUtils.removeCssClass(this.element, 'mfp-item-vertical');
            //     this.element.style.width = '';
            //     this.element.parentNode.style.cssText = '';
            //     this.element.parentNode.style.visibility = 'visible';
            // }
            // else {
            this.element.style.margin = this.calendar.itemSettings.spacing + 'px';
            if (this.calendar.itemSettings.spacing > 0) {
                //   this.element.style.marginBottom = '0px';
            }
            this.element.parentNode.style.cssText = '';
            this.element.parentNode.style.visibility = 'visible';
        }

        /** 
        * For internal use only.
        * @private
        * Updates appointments' time indicator.
        * Used for Timetable day items.
        */

    }, {
        key: 'updateTimeIndicator',
        value: function updateTimeIndicator() {
            if (this.calendar.currentView === CalendarView.Timetable && !this.isHeader) {
                var dim1 = "top";
                var dim2 = "bottom";
                var cdim = this.view.cellHeight;
                if (this.orientation == Orientation.Horizontal) {
                    dim1 = "left";
                    dim2 = "right";
                    var cdim = this.view.cellWidth;
                }

                var parts = this.getParts();

                if (parts.length > 0) {
                    var startOffset = 0;
                    var endOffset = 0;

                    for (var i = 0, l = parts.length; i < l; i++) {
                        this.Dom.post.style[dim1] = -1 + "px";
                        this.Dom.post.style[dim2] = -1 + "px";
                    }

                    if (parts[0].cellIndex == undefined) {
                        return;
                    }

                    var columnIndex = this.view.cells.items()[parts[0].cellIndex].columnIndex;
                    var diff = Math.max(0, this.item.startTime.__getTime() - this.view._columns.items()[columnIndex].startTime._date.getTime());
                    var c = diff / this.view.settings.cellTime.milliseconds;
                    var coef = c - Math.floor(c);
                    startOffset = parseInt(cdim * coef);
                    if (startOffset == cdim || startOffset == 0) startOffset = -1;

                    var columnIndex = this.view.cells.items()[parts[parts.length - 1].cellIndex].columnIndex;
                    var diff = Math.max(0, this.item.endTime.__getTime() - this.view._columns.items()[columnIndex].startTime.__getTime());
                    var c = diff / this.view.settings.cellTime.milliseconds;
                    var coef = c - Math.floor(c);
                    var endOffset = parseInt(cdim - cdim * coef);
                    if (this.item.startTime.__getTime() != this.item.endTime.__getTime() && endOffset == cdim || endOffset == 0) endOffset = -1;

                    var groups = this.getGroupParts();
                    if (groups.length > 0) {
                        for (var i = 0, l = groups.length; i < l; i++) {
                            var aprev = this.Dom.element.querySelector(".mfp-arrow.mfp-prev");
                            if (!aprev) this.Dom.post.style[dim1] = startOffset + "px";

                            var anext = this.Dom.element.querySelector(".mfp-arrow.mfp-next");
                            if (!anext) this.Dom.post.style[dim2] = endOffset + "px";
                        }
                    }
                }
            }
        }

        /** 
        * For internal use only.
        * @private
        * Updates appointments' visual for drag/resize interaction.
        */

    }, {
        key: 'updateDragVisual',
        value: function updateDragVisual(data) {

            this.removeParts();
            var element = this.element.parentNode;

            if (this.calendar.currentView == CalendarView.List && this.view.orientation == Orientation.Vertical) {
                var width = element.style.width;
                element.style.cssText = '';
                element.style.height = data.height + 'px';
                element.style.width = width;
                this.element.style.margin = '';
            } else if (this.calendar.currentView != CalendarView.Timetable || this.isHeader) {
                var height = element.style.height;
                element.style.cssText = '';
                element.style.width = data.width + 'px';
                element.style.height = height;
            }

            // if (data.inCueForm) {
            //     if (this.calendar.currentView == CalendarView.List && this.view.orientation == Orientation.Vertical) {
            //         this.view.toVertical(this);
            //     }
            // }

            if (this.calendar.currentView != CalendarView.Timetable) {
                element.style.zIndex = 10000;
                element.style.display = 'none';
                element.style.position = 'absolute';
            }

            if (this.calendar.currentView == CalendarView.Timetable && this.view.orientation == Orientation.Horizontal && this.isHeader) {
                element.style.float = 'left';
            }
        }

        /** 
        * For internal use only.
        * @private
        * Returns the data needed for interactions.
        */

    }, {
        key: 'getData',
        value: function getData(e) {

            var vert = this.calendar.currentView === CalendarView.List && this.view.orientation === Orientation.Vertical;
            var vResize = vert || this.calendar.currentView === CalendarView.Timetable && this.view.orientation === Orientation.Vertical && !this.isHeader;

            var data = {
                element: this.Dom.wrapper,
                appointment: this,
                item: this.item,
                length: this.length,
                dragHeight: !vert ? this.element.offsetHeight : this.view.dragHeight, // - this.view.headerHeight - this.view.daySpacing - this.view.padding,
                startCellIndex: this.startCellIndex,
                lastCellIndex: this.lastCellIndex,
                isHeader: this.isHeader,
                startTime: this.item.startTime,
                endTime: this.item.endTime,
                handle: e.target.className.indexOf('mfp-resize') > -1 ? e.target.className.split('mfp-resize-')[1] : null,
                verticalResize: vResize
            };

            data.itemStartCell = this.getItemStartCell();
            data.itemLastCell = this.getItemEndCell();

            if (this.calendar._currentView == CalendarView.Timetable) {
                data.startTimeOffset = this.item.startTime._date.valueOf() - data.itemStartCell.startTime._date.valueOf();
                data.endTimeOffset = this.item.endTime._date.valueOf() - data.itemLastCell.endTime._date.valueOf();
                data.resource = data.itemStartCell.startTime.resource;
                data.startTimeOffset2 = this.item.startTime._date.valueOf() - data.itemStartCell.startTime._date.valueOf();
                data.endTimeOffset2 = this.item.endTime._date.valueOf() - data.itemLastCell.endTime._date.valueOf();
            }
            return data;
        }

        /** 
        * For internal use only.
        * @private
        * Returns the time increased by the item's length.
        */

    }, {
        key: 'getEndTime',
        value: function getEndTime(startTime) {
            return DateTime.addTicksToDate(startTime, this.length);
        }

        /** 
        * For internal use only.
        * @private
        * Returns the items' length in milliseconds.
        */

    }, {
        key: 'getLength',
        value: function getLength(item) {
            // var r;
            // if (item.allDayEvent) {
            //     r = DateTime.millisecondsBetween(item.endTime, item.startTime);
            // }
            // else {
            //     r = item.endTime._date.valueOf() - item.startTime._date.valueOf() || 1;
            // }

            var result = DateTime.millisecondsBetween(item.endTime, item.startTime) || 1;
            // if (r != undefined && r != result)
            //     alert("length diff:"+ r + " - " + result  );
            return result;
        }

        // /** 
        // * For internal use only.
        // * @private
        // * Returns the height of the title.
        // * Used in vertical views arrangement.
        // */
        // getTitleHeight() {
        //     var result = +this.element.parentNode.clientHeight;
        //     //var result = $mindfusion(this.element.parentNode).height();
        //     if (this.item.reminder)
        //         result -= 15;
        //     if (this.item.recurrence)
        //         result -= 15;
        //     if (this.isPartial && (this.partIndex == 0 || this.partIndex == -1))
        //         result -= 15;
        //     if (this.isPartial && (this.partIndex == 0 || this.partIndex == 1))
        //         result -= 15;
        //     return Math.max(result, 0);
        // }

        /** 
        * For internal use only.
        * @private
        * Returns the first cell occuppied by this item's visuals.
        * Used in drag and resize.
        */

    }, {
        key: 'getItemStartCell',
        value: function getItemStartCell() {
            var parts = this.getParts();
            if (this.calendar._currentView == CalendarView.Timetable) {
                if (this.isHeader) {
                    return this.view.headerCells.items()[parts[0].startCellIndex];
                } else {
                    return this.view.cells.items()[parts[0].startCellIndex];
                }
            } else {
                var cell = this.view.getTimeCell(this.item.startTime, false, this.groupColumnIndex);
                if (cell == null) {
                    if (this.view.grouped) cell = this.view.groupCols[this.groupColumnIndex].cells.items()[0];else cell = this.view.cells.items()[0];
                }
                return cell;
            }
        }

        /** 
        * For internal use only.
        * @private
        * Returns the last cell occuppied by this item's visuals.
        * Used in drag and resize.
        */

    }, {
        key: 'getItemEndCell',
        value: function getItemEndCell() {
            var parts = this.getParts();
            if (this.calendar._currentView == CalendarView.Timetable) {
                if (this.isHeader) return this.view.headerCells.items()[parts[parts.length - 1].lastCellIndex];
                return this.view.cells.items()[parts[parts.length - 1].lastCellIndex];
            } else {
                var cell = this.view.getTimeCell(this.item.endTime, true, this.groupColumnIndex);
                if (cell == null) {
                    if (this.view.grouped) cell = this.view.groupCols[this.groupColumnIndex].cells.items()[this.view.groupCols[this.groupColumnIndex].cells.count() - 1];else cell = this.view.cells.items()[this.view.cells.count() - 1];
                }
                return cell;
            }
        }

        /** 
        * For internal use only.
        * @private
        * Returns an array of all appointments, which are parts of the current appointment's item.
        */

    }, {
        key: 'getParts',
        value: function getParts() {
            return this.view.getItemElements(this.item);
        }

        /** 
        * For internal use only.
        * @private
        * Returns an array of all appointments, which are parts of the current appointment's item.
        * The returned array is grouped by resource.
        */

    }, {
        key: 'getGroupParts',
        value: function getGroupParts() {
            var parts = this.getParts();
            var result = [];
            if (parts.length == 0) {
                return result;
            }

            var resourceParts = [];
            resourceParts.push(parts[0]);
            var resource = parts[0].resource;
            for (var i = 1, l = parts.length; i < l; i++) {
                var partResource = this.view.cells.items()[parts[i].startCellIndex].resource;
                if (partResource != resource) {
                    result.push(resourceParts);
                    resourceParts = [];
                }
                resourceParts.push(parts[i]);
                resource = partResource;
            }

            result.push(resourceParts);
            return result;
        }
        /** 
        * For internal use only.
        * @private
        * Removes all other appointments, which are parts of the appointment's item.
        */

    }, {
        key: 'removeParts',
        value: function removeParts() {
            if (this.isPartial) {
                var parts = this.view.getItemElements(this.item);
                for (var i = 0, l = parts.length; i < l; i++) {
                    if (parts[i] != this) {
                        this.view.removeAppointment(parts[i]);
                        // parts[i].dispose();
                    }
                }
                if (this.view.unit == TimeUnit.Day) {
                    this.cellsLength = DateTime.daysBetween(this.item.startTime, this.item.endTime);
                }
                this.isPartial = false;
            }
        }
    }, {
        key: 'onMouseUp',


        //Events
        /** 
        * For internal use only.
        * @private
        */
        value: function onMouseUp(e) {
            //  this.calendar._raiseEvent('onItemMouseUp', new MindFusion.Scheduling.ItemLocationEventArgs({ item: this.item, e: e }));
            var resource = this.calendar.selectManager.resource;
            if (this.view._selecting) {
                this.calendar.selectManager.stopSelect();
                this.view._selecting = false;
                e.stopPropagation();
            }
            if (this.view._dragging) {
                this.calendar.selectManager.stopSelect();
                this.view.endItemDrag(e, resource);
                this.inplaceEdit.stopped = true;
                e.stopPropagation();
            } else {
                if (this.view.drag) {
                    this.view.drag.dispose();
                }
            }
            if (this.view._resizing) {
                this.calendar.selectManager.stopSelect();
                this.view.endItemResize(e, resource);
                this.inplaceEdit.stopped = true;
                e.stopPropagation();
            } else {
                if (this.view.resize) {
                    this.view.resize.dispose();
                }
            }
        }

        /** 
        * For internal use only.
        * @private
        */

    }, {
        key: 'onMouseDown',
        value: function onMouseDown(e) {
            if (!this.calendar.enabled) {
                return;
            }
            // this.calendar._raiseEvent('onItemMouseDown', new MindFusion.Scheduling.ItemLocationEventArgs({ item: this.item, e: e }));
            if (e.button == 0) {
                this.inplaceEdit.stopped = false;
                // this.calendar.selectManager.resource = this.view.resources ? this.view.resources[this.groupColumnIndex] : null;
                this.view.selectItem(e, this.getData(e));
            }
            e.stopPropagation();
        }

        /** 
        * For internal use only.
        * @private
        */

    }, {
        key: 'onClick',
        value: function onClick(e) {
            if (e.button == 0) {
                this.calendar.onItemClick(new ItemEventArgs(this.item));

                if (this.calendar.itemCloneKeyPressed(e)) this.calendar.cloneItem(this.item);

                e.stopPropagation();
            }
        }

        /** 
        * For internal use only.
        * @private
        */

    }, {
        key: 'onDoubleClick',
        value: function onDoubleClick(e) {
            if (e.button == 0) {
                if (this.calendar.onItemDoubleClick(new ItemEventArgs(this.item))) {
                    if (this.calendar.useForms && this.calendar.enabled) {
                        if (!this.view._selectionPaused) {
                            var p = new EditForm(this.view.calendar, this.item, 'edit');
                            p.showForm();
                        }
                    }
                }
                e.stopPropagation();
            }
        }
    }, {
        key: 'element',
        get: function get$$1() {
            return this.Dom.element;
        }
    }, {
        key: 'isMilestone',
        get: function get$$1() {
            return this.item.startTime._date.valueOf() == this.item.endTime._date.valueOf();
        }
    }, {
        key: 'isSelected',
        get: function get$$1() {
            return this.calendar._itemSelection.items.contains(this.item);
        }
    }]);
    return Appointment;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* @class Represents a date-time range.
* @property {DateTime} start Gets or sets the beginning of the range.
* @property {DateTime} end Gets or sets the end of the range.
* @property {Boolean} isEmpty Gets a value indicating whether the range is empty.
*/
var TimeRange = function () {
    /** 
    * Initializes a new instance of the TimeRange class.
    * @constructor
    * @param {DateTime} start The beginning of the range.
    * @param {DateTime} end The end of the range.
    */
    function TimeRange(start, end) {
        classCallCheck(this, TimeRange);

        this._start = start;
        this._end = end;
    }

    /**
    * Gets the beginning of the range.
    * @returns {DateTime} A DateTime instance representing the beginning of the range.
    */


    createClass(TimeRange, [{
        key: "equals",


        /**
        * Checks if the specified range contains the same date-time as the current instance.
        * @returns {Boolean} true if the ranges are equal; otherwise false.
        */
        value: function equals(range) {
            return this.start.equals(range.start) && this.end.equals(range.end);
        }

        /**
        * Checks if the current range contains the specified range.
        * @returns {Boolean} true if the current range contains the specified range; otherwise false.
        */

    }, {
        key: "contains",
        value: function contains(range) {

            if (this.start.valueOf() <= range.start.valueOf() && this.end.valueOf() >= range.end.valueOf()) return true;

            return false;
        }

        /**
        * Checks if the current range intersects with the specified range.
        * @returns {Boolean} true if the current range intersects with the specified range; otherwise false.
        */

    }, {
        key: "intersects",
        value: function intersects(range) {

            if (range.start.valueOf() < this.end.valueOf() && range.start.valueOf() > this.start.valueOf()) return true;

            if (range.end.valueOf() < this.end.valueOf() && range.end.valueOf() > this.start.valueOf()) return true;

            return false;
        }

        /**
        * Checks if the current range starts at the same time as the specified range.
        * @returns {Boolean} true if the current range starts at the same time with the specified range; otherwise false.
        */

    }, {
        key: "sameStart",
        value: function sameStart(range) {

            if (this.start.valueOf() === range.start.valueOf()) return true;

            return false;
        }

        /**
        * Checks if the current range ends at the same time as the specified range.
        * @returns {Boolean} true if the current range ends at the same time with the specified range; otherwise false.
        */

    }, {
        key: "sameEnd",
        value: function sameEnd(range) {

            if (this.end.valueOf() === range.end.valueOf()) return true;

            return false;
        }
    }, {
        key: "start",
        get: function get$$1() {
            return this._start;
        }

        /**
        * Sets the beginning of the range.
        * @param {DateTime} value A DateTime instance representing the beginning of the range.
        */
        ,
        set: function set$$1(value) {
            this._start = value;
        }

        /**
        * Gets the end of the range.
        * @returns {DateTime} A DateTime instance representing the end of the range.
        */

    }, {
        key: "end",
        get: function get$$1() {
            return this._end;
        }

        /**
        * Sets the end of the range.
        * @param {DateTime} value A DateTime instance representing the end of the range.
        */
        ,
        set: function set$$1(value) {
            this._end = value;
        }

        /**
        * Checks if the range is empty.
        * @returns {Boolean} true if the range is empty; otherwise false.
        */

    }, {
        key: "isEmpty",
        get: function get$$1() {
            return this.start == null;
        }
    }]);
    return TimeRange;
}();

/**
* For internal use only.
* @private
*/

var DragContainer = function () {
    function DragContainer(view, data) {
        var _this = this;

        classCallCheck(this, DragContainer);

        this.draggable = data.element;
        this.data = data;
        this.view = view;
        this.offsetLeft = this.view.offsetLeft;

        this.calendar = view.calendar;
        this._element = view.getContainer();
        this.resource = this.view.groupResources ? this.view.groupResources[this.data.appointment.groupColumnIndex] : null;

        this.mouseMoveHandler = function (e) {
            return _this.onMouseMove(e);
        };
        document.addEventListener('mousemove', this.mouseMoveHandler);
        this.mouseUpHandler = function (e) {
            return _this.onMouseUp(e);
        };
        document.addEventListener('mouseup', this.mouseUpHandler);

        // this.calendar.changeCursor('move');
    }

    createClass(DragContainer, [{
        key: 'dispose',
        value: function dispose() {
            if (this.mouseMoveHandler) {
                document.removeEventListener('mousemove', this.mouseMoveHandler);
                delete this.mouseMoveHandler;
            }
            if (this.mouseUpHandler) {
                document.removeEventListener('mouseup', this.mouseUpHandler);
                delete this.mouseUpHandler;
            }
            this.view.dragContainer = null;

            this.calendar.changeCursor();
        }
    }, {
        key: 'onMouseMove',
        value: function onMouseMove(e) {
            if (!this.view._dragging) return;
            this.doDrag(e);
            e.stopPropagation();
            return true;
        }
    }, {
        key: 'onMouseUp',
        value: function onMouseUp(e) {
            if (!this.view._dragging) return;
            this.calendar.selectManager.stopSelect();
            this.view.endItemDrag(e, this.resource);
        }
    }, {
        key: 'doDrag',
        value: function doDrag(e) {
            this.resource = this.calendar.checkResource(e, this.resource);

            var cellIndex = this.view.getCellIndexAt(e.clientX, e.clientY, this.resource);
            var c;

            var changes = {};

            if (cellIndex != null) {
                var start = this.view.cells.items()[cellIndex].startTime;
                changes = {
                    startTime: start,
                    endTime: DateTime.addMilliseconds(start, this.data.appointment.getLength(this.data.item))
                };
            }

            if (this.calendar.onItemModifying(new ItemModifyingEventArgs(this.data.item, changes, ItemModifyAction.Drag))) {

                if (cellIndex == null) {
                    return;
                }
                if (this.calendar._currentView === CalendarView.MonthRange) {
                    var fv = this.view.firstVisibleCellOfMonth(cellIndex);
                    var lv = this.view.lastVisibleCellOfMonth(cellIndex);

                    if (cellIndex < fv || cellIndex > lv) {
                        e.stopPropagation();
                        return;
                    }
                } else if (cellIndex < this.view.firstVisibleCell || cellIndex > this.view.lastVisibleCell) {
                    e.stopPropagation();
                    return;
                }
                c = this.view.getCellAt(e.clientX, e.clientY, this.resource);

                if (this.calendar._currentView === CalendarView.Timetable) this.view.updateDrag(this.data.appointment, c, e);else this.getCell(c);

                this.calendar.changeCursor('move');
                // this.draggable.style.cursor = 'pointer';
                //this.view.getContent().style.cursor = 'default';
            } else {
                c = this.view.cells.items()[this.data.startCellIndex];
                this.getCell(c);
                this.calendar.changeCursor('not-allowed');
                // this.draggable.style.cursor = 'not-allowed';
                // this.view.getContent().style.cursor = 'not-allowed';
            }
        }
    }, {
        key: 'getCell',
        value: function getCell(c) {
            if (c) {
                var cell = c.title;

                if (cell) {
                    var bounds = DomUtils.getRelativeBounds(cell, this._element);

                    if (this.calendar._currentView === CalendarView.ResourceView) this.draggable.style.top = this.getY(c, bounds.x, bounds.y) + 'px';else this.draggable.style.top = this.getY(c, bounds.x, bounds.y + bounds.height) + 'px';
                    if (this.calendar.view.orientation === Orientation.Vertical) this.draggable.style.left = this.getX(c, bounds.x, bounds.y + bounds.height) + 'px';else this.draggable.style.left = bounds.x + 'px';

                    this.draggable.style.display = 'block';
                }
            }
        }
    }, {
        key: 'getX',
        value: function getX(cell, x, y) {
            var leftOffset = 0;
            var w = this.calendar.itemSettings.size;
            var n = 0;
            if (this.calendar.view.orientation === Orientation.Vertical) {
                n = this.view.getDragOffset(cell, this.data.appointment);
            }

            if (n > leftOffset) {
                leftOffset = n;
            }
            if (leftOffset < this.view.itemsCount) {
                this.draggable.style.visibility = 'visible';
            } else {
                this.draggable.style.visibility = 'hidden';
            }
            leftOffset *= w;
            x += leftOffset;
            x += this.calendar.itemSettings.spacing * n + this.calendar.itemSettings.spacing;

            return x;
        }
    }, {
        key: 'getY',
        value: function getY(cell, x, y) {
            var topOffset = 0;
            var h = this.data.dragHeight;
            var n = 0;
            if (this.calendar._currentView !== CalendarView.List || this.calendar.view.orientation === Orientation.Horizontal) {
                n = this.view.getDragOffset(cell, this.data.appointment);
            }
            if (n > topOffset) topOffset = n;
            if (topOffset < this.view.getItemsCount(cell)) this.draggable.style.visibility = 'visible';else this.draggable.style.visibility = 'hidden';

            topOffset = topOffset * h;
            y = y + topOffset;
            y = y + this.calendar.itemSettings.spacing * n;
            return y;
        }
    }]);
    return DragContainer;
}();

/**
* For internal use only.
* @private
*/

var DragItem = function () {
    function DragItem(view, data) {
        var _this = this;

        classCallCheck(this, DragItem);

        if (view.dragWidth === undefined) {
            view.getDimensions();
        }
        this._dragWidth = view.dragWidth;
        this.data = data;
        this.item = data.item;
        this.view = view;

        this.appointment = data.appointment;

        this.calendar = data.appointment.calendar;

        this._element = data.appointment.Dom.wrapper;
        this._container = this.view.getContainer();

        this.mouseMoveHandler = function (e) {
            return _this.onMouseMove(e);
        };
        this._container.addEventListener('mousemove', this.mouseMoveHandler);

        this.view.inplaceEditing = false;
        // this.popupMode = (DomUtils.getParent(this._element, "mfp-popup") != null);

        this._dragmode = 'move';
    }

    createClass(DragItem, [{
        key: 'dispose',
        value: function dispose() {

            if (this.mouseMoveHandler) {
                this._container.removeEventListener('mousemove', this.mouseMoveHandler);
                delete this.mouseMoveHandler;
            }
            this.view.drag = null;
        }
    }, {
        key: 'onMouseMove',
        value: function onMouseMove(e) {
            if (this.mouseMoved(e)) {
                if (this._dragmode != null && this.view._dragging === false && this.view._selecting) return this.doDrag(e);
            }
        }
    }, {
        key: 'mouseMoved',
        value: function mouseMoved(e) {
            var curPos = DomUtils.getCursorPosition(e, this._container);
            var startPos = this.data.startPos;
            if (Math.abs(curPos.x - startPos.x) > 0) return true;
            if (Math.abs(curPos.y - startPos.y) > 0) return true;
            return false;
        }
    }, {
        key: 'doDrag',
        value: function doDrag(e) {
            if (this.view.inplaceEditing) return;

            var cursor = DomUtils.getCursorPosition(e, this._container);

            if (this._dragmode === 'move' && this.view._dragging === false) {
                //  if (this.calendar.onItemDragStart(new ItemEventArgs(this.item))) {
                if (this.calendar.onItemModifying(new ItemModifyingEventArgs(this.item, {}, ItemModifyAction.Drag))) {
                    this.addDraggable(e, true);
                }
                //  }
                return true;
            }
        }
    }, {
        key: 'addDraggable',
        value: function addDraggable(e) {
            if (!this.item) return;
            if (!this.item.allowMove || this.item.locked) return true;

            var cursor = DomUtils.getCursorPosition(e, this._container, this._scroller);

            this.appointment.updateDragVisual({ width: this._dragWidth, height: this.data.dragHeight });

            if (this.data.popupMode) {
                this.calendar.popups.get('ItemsCueForm').closeForm();
            }

            var cell = this._element.parentNode;

            //  DomUtils.firstRealChild(this._element).style.cursor = 'move';
            //  this._container.style.cursor = 'move';

            if (this.calendar._currentView != CalendarView.Timetable) {
                this._container.appendChild(this._element);
            }
            if (this.calendar._currentView === CalendarView.ResourceView) {
                cell.innerHTML = '&nbsp;';
            }

            this.view._dragging = true;
            this.view.dragContainer = new DragContainer(this.view, this.data);
        }
    }]);
    return DragItem;
}();

/**
* For internal use only.
* @private
*/

var ResizePart = function () {
    function ResizePart(view, data) {
        classCallCheck(this, ResizePart);


        this.view = view;
        this._container = this.view.getContainer();

        this.element = data.element;
        this.startCell = data.startCell;
        this.endCell = data.endCell;

        var start = this.startCell.startTime;
        var end = this.startCell.endTime;

        this.index = data.index;
        if (this.index === 1 && start.compareTo(data.item.startTime) === 1 && data.handle !== 'start') {
            this.index = 0;
        }
        if (this.index === -1 && end.compareTo(data.item.endTime) === 1 && data.handle !== 'end') {
            this.index = 0;
        }

        this.updateVisual();
    }

    createClass(ResizePart, [{
        key: 'dispose',
        value: function dispose() {
            DomUtils.removeNode(this.element, this._container);
        }
    }, {
        key: 'updateVisual',
        value: function updateVisual() {
            // index: -1:resize start, 1:resize end, 0:middle part, -2:non-composite

            var content = this.element.querySelector(".mfp-item");

            var el;
            if (this.index === -1) el = content.querySelectorAll(".mfp-resize-start");else if (this.index === 1) el = content.querySelectorAll(".mfp-resize-end");else if (this.index === 0) el = content.querySelectorAll(".mfp-resize-start, .mfp-resize-end");

            DomUtils.removeNodes(el, content);

            if (this.view.calendar.itemSettings.showContinuationArrows) {
                el = this.element.querySelectorAll(".mfp-arrow");
                DomUtils.removeNodes(el, content);

                var d, s;

                if (this.index === -1 || this.index === 0) {
                    d = document.createElement("div");
                    DomUtils.addCssClass(d, "mfp-arrow");
                    DomUtils.addCssClass(d, "mfp-prev");
                    d.style.lineHeight = this.view.calendar.itemSettings.size + "px";
                    s = document.createElement("span");
                    d.appendChild(s);
                    content.appendChild(d);
                }

                if (this.index === 0 || this.index === 1) {
                    d = document.createElement("div");
                    d.style.lineHeight = this.view.calendar.itemSettings.size + "px";
                    DomUtils.addCssClass(d, "mfp-arrow");
                    DomUtils.addCssClass(d, "mfp-next");
                    s = document.createElement("span");
                    d.appendChild(s);
                    content.appendChild(d);
                }
            }
        }
    }]);
    return ResizePart;
}();

/**
* For internal use only.
* @private
*/

var ResizeContainer = function () {
    function ResizeContainer(view, data) {
        var _this = this;

        classCallCheck(this, ResizeContainer);

        this.data = data;
        this.view = view;
        this.calendar = view.calendar;
        this._element = view.getContainer();
        this.resource = this.view.resources ? this.view.resources[this.data.appointment.groupColumnIndex] : null;

        this.parts = [];
        this.startCell = this.data.itemStartCell;
        this.endCell = this.data.itemLastCell;

        this.mouseMoveHandler = function (e) {
            return _this.onMouseMove(e);
        };
        document.addEventListener('mousemove', this.mouseMoveHandler);
        this.mouseUpHandler = function (e) {
            return _this.onMouseUp(e);
        };
        document.addEventListener('mouseup', this.mouseUpHandler);

        this.cursor = data.verticalResize ? 'n-resize' : 'w-resize';
        this.calendar.changeCursor(this.cursor);
    }

    createClass(ResizeContainer, [{
        key: 'dispose',
        value: function dispose() {

            if (this.mouseMoveHandler) {
                document.removeEventListener('mousemove', this.mouseMoveHandler);
                delete this.mouseMoveHandler;
            }
            if (this.mouseUpHandler) {
                document.removeEventListener('mouseup', this.mouseUpHandler);
                delete this.mouseUpHandler;
            }
            this.view.resizeContainer = null;

            this.calendar.changeCursor();
        }
    }, {
        key: 'onMouseMove',
        value: function onMouseMove(e) {
            if (!this.view._resizing) return;

            this.doResize(e);
            e.stopPropagation();
            return true;
        }
    }, {
        key: 'onMouseUp',
        value: function onMouseUp(e) {
            if (!this.view._resizing) return;

            this.calendar.selectManager.stopSelect();
            this.view.endItemResize(e, this.resource);
        }
    }, {
        key: 'doResize',
        value: function doResize(e) {
            this.resource = this.calendar.checkResource(e, this.resource);

            var cellIndex = this.view.getCellIndexAt(e.clientX, e.clientY, this.resource);

            var changes = {};

            if (cellIndex !== null) {
                var start = this.view.cells.items()[cellIndex].startTime;
                changes = {
                    startTime: start,
                    endTime: DateTime.addMilliseconds(start, this.data.appointment.getLength(this.data.item))
                };
            }

            if (this.calendar.onItemModifying(new ItemModifyingEventArgs(this.data.item, changes, ItemModifyAction.Resize))) {
                if (cellIndex === null) {
                    return;
                }
                if (this.calendar._currentView === CalendarView.MonthRange) {
                    var fv = this.view.firstVisibleCellOfMonth(cellIndex);
                    var lv = this.view.lastVisibleCellOfMonth(cellIndex);

                    if (cellIndex < fv || cellIndex > lv) {
                        e.stopPropagation();
                        return;
                    }
                } else if (cellIndex < this.view.firstVisibleCell || cellIndex > this.view.lastVisibleCell) {
                    e.stopPropagation();
                    return;
                }
                var cell = this.view.getCellAt(e.clientX, e.clientY, this.resource);
                if (this.calendar.currentView === CalendarView.Timetable) {
                    this.view.updateResize(this.data.appointment, cell, e);
                } else {
                    this.getCell(cell);
                    this.calendar.changeCursor(this.cursor);
                    // this.draggable.element.style.cursor = 'pointer';
                    // this.view.getContent().style.cursor = 'default';
                }
            } else {
                if (this.calendar.currentView != CalendarView.Timetable) {
                    var c = this.view.cells.items()[this.data.startCellIndex];
                    this.getCell(c);
                    this.calendar.changeCursor('not-allowed');
                    //this.draggable.element.style.cursor = 'not-allowed';
                    //this.view.getContent().style.cursor = 'not-allowed';
                }
            }
        }
    }, {
        key: 'getCell',
        value: function getCell(cell) {
            if (this.calendar.currentView === CalendarView.ResourceView || this.calendar.currentView === CalendarView.List) {
                this.createVPart(cell);
            } else {
                this.clearParts();
                this.createParts(cell);
            }
        }
    }, {
        key: 'clearParts',
        value: function clearParts() {
            for (var i = 0, l = this.parts.length; i < l; i++) {
                this.parts[i].dispose();
            }
            this.parts = [];
        }
    }, {
        key: 'createParts',
        value: function createParts(cell) {
            var mr = this.calendar._currentView === CalendarView.MonthRange;
            var ci = mr ? cell.globalIndex : cell.index;
            var si = mr ? this.startCell.globalIndex : this.startCell.index;
            var ei = mr ? this.endCell.globalIndex : this.endCell.index;

            if (this.data.handle === 'start') {
                if (ci < si) {
                    var s = cell;
                    var e = this.endCell;
                } else {
                    if (ci < ei) {
                        var s = cell;
                        var e = this.endCell;
                    } else {
                        var s = this.endCell;
                        var e = cell;
                    }
                }
            }

            if (this.data.handle === 'end') {
                if (ci > ei) {
                    var s = this.startCell;
                    var e = cell;
                } else {
                    if (ci > si) {
                        var s = this.startCell;
                        var e = cell;
                    } else {
                        var s = cell;
                        var e = this.startCell;
                    }
                }
            }

            if (this.data.handle === 'start' || this.data.handle === 'end' && ci < si) this.view.itemData.itemStartCell = s;else this.view.itemData.itemStartCell = null;

            if (this.data.handle === 'end' || this.data.handle === 'start' && ci > ei) this.view.itemData.itemLastCell = e;else this.view.itemData.itemLastCell = null;

            if (mr) {
                var srow = this.view.rows.items().indexOf(this.view.monthCells.items()[s.monthCellIndex]._rows.items()[s.rowIndex]);
                var erow = this.view.rows.items().indexOf(this.view.monthCells.items()[e.monthCellIndex]._rows.items()[e.rowIndex]);
            } else {
                var srow = s.rowIndex;
                var erow = e.rowIndex;
            }
            for (var i = srow, l = erow; i <= l; i++) {

                var sr = i === srow ? s : this.view.getFirstRowCell(i);
                var er = i === erow ? e : this.view.getLastRowCell(i);
                var index = i === srow ? 1 : i === erow ? -1 : 0;
                if (srow === erow) index = -2;
                if (sr && er) {
                    this.createPart(sr, er, index);
                }
            }
        }
    }, {
        key: 'createPart',
        value: function createPart(cell, lcell, index) {

            var element = this.data.element.cloneNode(true);
            this._element.appendChild(element);

            var data = { element: element, startCell: cell, endCell: lcell, item: this.data.item, index: index, handle: this.data.handle };
            var part = new ResizePart(this.view, data);

            var bounds = DomUtils.getRelativeBounds(cell.title, this._element);
            if (this.view.getScroller()) {
                bounds.y -= this.view.getScroller().scrollTop;
                bounds.x -= this.view.getScroller().scrollLeft;
            }

            var lbounds = DomUtils.getRelativeBounds(lcell.title, this._element);
            if (this.view.getScroller()) {
                lbounds.y -= this.view.getScroller().scrollTop;
                lbounds.x -= this.view.getScroller().scrollLeft;
            }

            this.draggable = part;
            element.style.visibility = 'visible';
            element.style.left = bounds.x + 'px';
            element.style.top = this.getRY(part.startCell, part.endCell, lbounds.x, lbounds.y + lbounds.height, element) + 'px';
            element.style.width = Math.max(lbounds.x + lbounds.width - bounds.x, bounds.width) + 'px';

            element.style.display = 'block';
            this.parts.push(part);
        }
    }, {
        key: 'createVPart',
        value: function createVPart(cell) {
            if (this.data.handle === 'start') {
                if (cell.index < this.startCell.index) {
                    var s = cell;
                    var e = this.endCell;
                } else {
                    if (cell.index < this.endCell.index) {
                        var s = cell;
                        var e = this.endCell;
                    } else {
                        var s = this.endCell;
                        var e = cell;
                    }
                }
            }

            if (this.data.handle === 'end') {
                if (cell.index > this.endCell.index) {
                    var s = this.startCell;
                    var e = cell;
                } else {
                    if (cell.index > this.startCell.index) {
                        var s = this.startCell;
                        var e = cell;
                    } else {
                        var s = cell;
                        var e = this.startCell;
                    }
                }
            }

            if (this.view.grouped && s.groupColIndex !== e.groupColIndex) return;

            if (this.data.handle === 'start' || this.data.handle === 'end' && cell.index < this.startCell.index) this.view.itemData.itemStartCell = s;else this.view.itemData.itemStartCell = null;

            if (this.data.handle === 'end' || this.data.handle === 'start' && cell.index > this.endCell.index) this.view.itemData.itemLastCell = e;else this.view.itemData.itemLastCell = null;

            var cell = s;
            var lcell = e;

            var bounds = DomUtils.getRelativeBounds(cell.bgCell, this._element);
            if (this.view.Dom.scroller) {
                bounds.y -= this.view.Dom.scroller.scrollTop;
                bounds.x -= this.view.Dom.scroller.scrollLeft;
            }

            var lbounds = DomUtils.getRelativeBounds(lcell.bgCell, this._element);
            if (this.view.Dom.scroller) {
                lbounds.y -= this.view.Dom.scroller.scrollTop;
                lbounds.x -= this.view.Dom.scroller.scrollLeft;
            }
            var headerHeight = 0;
            if (this.calendar._currentView === CalendarView.List) headerHeight = DomUtils.getRelativeBounds(cell.title, this._element).height;

            if (!this.draggable) {
                var element = this.data.element;
                this._element.appendChild(element);

                var data = { element: element, startCell: this.startCell, endCell: this.endCell, item: this.data.item, index: 2, handle: this.data.handle };
                this.draggable = new ResizePart(this.view, data);
            } else {
                this.draggable.startCell = s;
                this.draggable.endCell = e;
                var element = this.draggable.element;
                element.style.visibility = 'visible';

                if (this.calendar.view.orientation === Orientation.Vertical) {
                    element.style.left = this.getRX(this.draggable.startCell, this.draggable.endCell, lbounds.x, lbounds.y + lbounds.height, element) + 'px';
                    element.style.height = Math.max(lbounds.y + lbounds.height - bounds.y - headerHeight, bounds.height - headerHeight) + 'px';
                    element.style.top = this.getY(this.draggable.startCell, bounds.x, bounds.y + headerHeight) + 'px';
                    // this.data.appointment.Dom.header.style.height = this.data.appointment.getTitleHeight() + "px";
                } else {
                    element.style.top = this.getRY(this.draggable.startCell, this.draggable.endCell, bounds.x, bounds.y + headerHeight, element) + 'px';
                    element.style.left = bounds.x + 'px';
                    element.style.width = Math.max(lbounds.x + lbounds.width - bounds.x, bounds.width) + 'px';
                }
                element.style.display = 'block';
            }
        }
    }, {
        key: 'getX',
        value: function getX(cell, x, y, element) {
            var leftOffset = 0;
            var w = this.calendar.itemSettings.size;
            var n = 0;
            if (this.calendar.view.orientation === Orientation.Vertical) {
                n = this.view.getDragOffset(cell, this.data.appointment);
            }

            if (n > leftOffset) {
                leftOffset = n;
            }
            if (leftOffset >= this.view.itemsCount) {
                element.style.visibility = 'hidden';
            }
            leftOffset *= w;
            x += leftOffset;
            //yarn st x += this.view.dayBorderLeft;
            x += this.calendar.itemSettings.spacing * n + this.calendar.itemSettings.spacing;

            return x;
        }
    }, {
        key: 'getY',
        value: function getY(cell, x, y, element) {
            var topOffset = 0;
            var h = this.data.dragHeight;
            var n = 0;
            if (this.calendar._currentView !== CalendarView.List || this.calendar.view.orientation === Orientation.Horizontal) {
                n = this.view.getDragOffset(cell, this.data.appointment);
            }
            if (n > topOffset) topOffset = n;
            if (topOffset >= this.view.getItemsCount(cell)) {
                element.style.visibility = 'hidden';
            }

            topOffset = topOffset * h;
            y = y + topOffset;
            //   y = y + this.view.dayBorderTop;
            y = y + this.calendar.itemSettings.spacing * n;
            return y;
        }
    }, {
        key: 'getRX',
        value: function getRX(start, end, x, y, element) {
            var rx = 0;
            for (var i = start.cellIndex, l = end.cellIndex; i <= l; i++) {
                var fx = this.getX(this.view.cells.items()[i], x, y, element);
                if (fx > rx) rx = fx;
            }
            return rx;
        }
    }, {
        key: 'getRY',
        value: function getRY(start, end, x, y, element) {
            var ry = 0;
            var si = this.calendar._currentView === CalendarView.MonthRange ? start.globalIndex : start.index;
            var li = this.calendar._currentView === CalendarView.MonthRange ? end.globalIndex : end.index;

            if (this.view.grouped) {
                si = start.cellIndex;
                li = end.cellIndex;
            }

            for (var i = si, l = li; i <= l; i++) {
                var fy = this.getY(this.view.cells.items()[i], x, y, element);
                if (fy > ry) ry = fy;
            }
            return ry;
        }
    }]);
    return ResizeContainer;
}();

/**
* For internal use only.
* @private
*/

var ResizeItem = function () {
    function ResizeItem(view, data) {
        var _this = this;

        classCallCheck(this, ResizeItem);

        if (view.dragWidth === undefined) {
            view.getDimensions();
        }
        this._dragWidth = view.dragWidth;
        this.data = data;
        this.item = data.item;
        this.view = view;

        this.appointment = data.appointment;
        this.calendar = data.appointment.calendar;
        this._element = data.appointment.Dom.wrapper;
        this._container = this.view.getContainer();

        this.mouseMoveHandler = function (e) {
            return _this.onMouseMove(e);
        };
        this._container.addEventListener('mousemove', this.mouseMoveHandler);

        this.view.inplaceEditing = false;

        // this.popupMode = (DomUtils.getParent(this._element, "mfp-popup") != null);

        this._mode = this.data.handle;
    }

    createClass(ResizeItem, [{
        key: 'dispose',
        value: function dispose() {
            if (this.mouseMoveHandler) {
                this._container.removeEventListener('mousemove', this.mouseMoveHandler);
                delete this.mouseMoveHandler;
            }
            this.view.resize = null;
        }
    }, {
        key: 'onMouseMove',
        value: function onMouseMove(e) {
            //if (this.data.popupMode) return;

            if (this.mouseMoved(e)) {
                if (this._mode != null && this.view._resizing === false && this.view._selecting) return this.doResize(e);
            }
        }
    }, {
        key: 'mouseMoved',
        value: function mouseMoved(e) {
            var curPos = DomUtils.getCursorPosition(e, this._container);
            var startPos = this.data.startPos;
            if (Math.abs(curPos.x - startPos.x) > 0) return true;
            if (Math.abs(curPos.y - startPos.y) > 0) return true;
            return false;
        }
    }, {
        key: 'doResize',
        value: function doResize(e) {
            if (this.view.inplaceEditing) return;

            var cursor = DomUtils.getCursorPosition(e, this._container);

            if (this._mode && this.view._resizing === false) {
                // if (this.calendar._raiseEvent('onItemResizeStart', new MindFusion.Scheduling.ItemLocationEventArgs({ item: this.item, e: e }))) {
                //    if (this.calendar._raiseEvent('onItemModifying', new MindFusion.Scheduling.ItemChangedEventArgs({ item: this.item, changes: {}, action: ItemModifyAction.Resize }))) {
                if (this.calendar.onItemModifying(new ItemModifyingEventArgs(this.item, {}, ItemModifyAction.Resize))) {
                    this.addResizable(e, true);
                }
                //   }
                return true;
            }
        }
    }, {
        key: 'addResizable',
        value: function addResizable(e) {
            if (!this.item) return;
            if (!this.item.allowMove || this.item.locked) return true;

            var cursor = DomUtils.getCursorPosition(e, this._container, this._scroller);
            this.appointment.updateDragVisual({ width: this._dragWidth, height: this.data.dragHeight });
            // if (this.popupMode) {
            //     this.calendar.popups.get('ItemsCueForm').closeForm();
            // }
            var cell = this._element.parentNode;
            if (this.calendar._currentView !== CalendarView.Timetable) {
                this._container.appendChild(this._element);
            }
            if (this.calendar._currentView === CalendarView.ResourceView) {
                cell.innerHTML = '&nbsp;';
            }
            this.view._resizing = true;
            this.view.resizeContainer = new ResizeContainer(this.view, this.data);
        }
    }]);
    return ResizeItem;
}();

var NewForm = function (_BaseForm) {
    inherits(NewForm, _BaseForm);

    function NewForm(calendar, item) {
        classCallCheck(this, NewForm);

        var _this = possibleConstructorReturn(this, (NewForm.__proto__ || Object.getPrototypeOf(NewForm)).call(this, calendar, item));

        _this._id = "NewForm";
        _this._type = 'new';
        _this.cssClass = "mfp-popup-new";

        _this._headerText = _this.localInfo.newFormHeader;
        return _this;
    }

    /**
    * For internal use only.
    * @private
    */


    createClass(NewForm, [{
        key: 'drawContent',
        value: function drawContent() {
            get(NewForm.prototype.__proto__ || Object.getPrototypeOf(NewForm.prototype), 'drawContent', this).call(this);
            var content = this.getContent();

            //var dateFormat = this.formatInfo.dateFormats.longDate;//this.culture.dateTimeFormat.longDatePattern;
            // var dateTimeFormat = this.formatInfo.dateFormats.full; //this.culture.dateTimeFormat.fullDateTimePattern;

            var startClone = this.item.startTime.clone();
            var endClone = this.item.endTime.clone();
            var tZoneDiff = this.item.endTime.__getTimezoneOffset() - this.item.startTime.__getTimezoneOffset();
            var difference = this.item.endTime._date.valueOf() - this.item.startTime._date.valueOf();
            var dayLength = 86400000 + tZoneDiff * 60 * 1000;

            var caption;
            // if (difference < dayLength) {
            //     var str = '&nbsp;{0}:<br><div class="dates-text">{1}: {2}<br>{3}: {4}</div>';
            //     caption = String.format(str,
            //         this._localInfo.datesCaption,
            //         this._localInfo.startTimeCaption,
            //         startClone.toString(dateTimeFormat, this.formatInfo),
            //         this._localInfo.endTimeCaption,
            //         endClone.toString(dateTimeFormat, this.formatInfo));
            // }
            // else if (difference == dayLength) {
            //     if (this.item.allDayEvent) {
            //         var str = '&nbsp;{0}:<br><div class="dates-text">{1}: {2}</div>';
            //         caption = String.format(str,
            //             this._localInfo.dateCaption,
            //             this._localInfo.startTimeCaption,
            //             startClone.toString(dateFormat, this.formatInfo));
            //     }
            //     else {
            //         var str = '&nbsp;{0}:<br><div class="dates-text">{1}: {2}<br>{3}: {4}</div>';
            //         caption = String.format(str,
            //             this._localInfo.datesCaption,
            //             this._localInfo.startTimeCaption,
            //             startClone.toString(dateFormat, this.formatInfo),
            //             this._localInfo.endTimeCaption,
            //             endClone.toString(dateFormat, this.formatInfo));
            //     }
            // }
            // else {
            //     if (this.item.allDayEvent) { endClone = endClone.addDays(-1); }
            //     var str = '&nbsp;{0}:<br><div class="dates-text">{1}: {2}<br>{3}: {4}</div>';
            //     caption = String.format(str,
            //         this._localInfo.datesCaption,
            //         this._localInfo.startTimeCaption,
            //         startClone.toString(dateFormat, this.formatInfo),
            //         this._localInfo.endTimeCaption,
            //         endClone.toString(dateFormat, this.formatInfo));
            // }

            var str = "";

            if (difference < dayLength) {
                str = '{0}<br>{1} - {2}';
                caption = String.format(str, startClone.toString(this.formatInfo.dateFormats.longDate, this.formatInfo), startClone.toString(this.formatInfo.dateFormats.longTime, this.formatInfo), endClone.toString(this.formatInfo.dateFormats.longTime, this.formatInfo));
            } else if (difference === dayLength) {
                if (this.item.allDayEvent) {
                    str = '{0}';
                    caption = String.format(str, startClone.toString(this.formatInfo.dateFormats.longDate, this.formatInfo));
                } else {
                    str = '{0}<br>{1} - {2}';
                    caption = String.format(str, startClone.toString(this.formatInfo.dateFormats.longDate, this.formatInfo), startClone.toString(this.formatInfo.dateFormats.longTime, this.formatInfo), endClone.toString(this.formatInfo.dateFormats.longTime, this.formatInfo));
                }
            } else {
                if (this.item.allDayEvent) {
                    endClone = endClone.addDays(-1);
                }
                str = '{0} - {1}';
                caption = String.format(str, startClone.toString(this.formatInfo.dateFormats.longDate, this.formatInfo), endClone.toString(this.formatInfo.dateFormats.longDate, this.formatInfo));
            }

            var h = this.row();
            h.className = "mfp-popup-title";
            h.innerHTML = caption;
            content.appendChild(h);

            // Add Subject
            var newControl = this.createTextArea({ id: "subject", events: { keydown: this._areaKeyDown } });
            this.addControl(newControl);
            newControl.element.placeholder = "appointment text";
            var style = newControl.element.style;
            style.height = "80px";
            style.width = "98%";

            var row = this.row();
            // row.style.marginTop = "8px";
            // row.innerHTML + "&nbsp";
            // row.innerHTML += this._localInfo.subjectCaption;
            // row.innerHTML += ":<br>";
            row.appendChild(newControl.element);
            content.appendChild(row);

            content.appendChild(this.divider());

            return content;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'drawButtons',
        value: function drawButtons() {
            var _this2 = this;

            var btnSave = this.createButton({ id: "btnSave", text: this.localInfo.saveButtonCaption, events: { click: function click(e) {
                        return _this2.onSaveButtonClick(e);
                    } } });
            var btnOptions = this.createButton({ id: "btnOptions", text: this.localInfo.optionsButtonCaption, events: { click: function click(e) {
                        return _this2.onOptionsButtonClick(e);
                    } } });

            var buttons = this.row();
            DomUtils.addCssClass(buttons, "mfp-buttons-row");
            buttons.appendChild(btnSave.element);
            buttons.appendChild(btnOptions.element);
            this.addControl(btnSave);
            this.addControl(btnOptions);
            this._buttons = buttons;
            return buttons;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onSaveButtonClick',
        value: function onSaveButtonClick(evt) {
            this.item.subject = this.getControlValue("subject");
            this.calendar.createItem(this.item, "NewForm");
            this.closeForm();
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'onOptionsButtonClick',
        value: function onOptionsButtonClick(evt) {
            this.item.subject = this.getControlValue("subject");
            var f = new EditForm(this.calendar, this.item, 'new');
            f.showForm();
            this.closeForm();
        }
    }]);
    return NewForm;
}(BaseForm);

var CueForm = function (_BaseForm) {
    inherits(CueForm, _BaseForm);

    function CueForm(calendar, items, cell) {
        classCallCheck(this, CueForm);

        var _this = possibleConstructorReturn(this, (CueForm.__proto__ || Object.getPrototypeOf(CueForm)).call(this, calendar, items));

        _this._id = "ItemsCueForm";
        _this._type = 'cue';
        _this.items = items;
        _this._headerText = _this.localInfo.cueFormHeader + " - " + cell.startTime.toString(_this.formatInfo.dateFormats.shortDate, _this.formatInfo);
        _this.cell = cell;
        return _this;
    }

    /**
    * For internal use only.
    * @private
    */


    createClass(CueForm, [{
        key: 'drawContent',
        value: function drawContent() {
            get(CueForm.prototype.__proto__ || Object.getPrototypeOf(CueForm.prototype), 'drawContent', this).call(this);

            DomUtils.addCssClass(this.getElement(), "mfp-cue-popup");

            var content = this.getContent();

            for (var i = 0, l = this.items.length; i < l; i++) {
                this.items[i].updateCueVisual(this.cell);
                var newRow = this.row().appendChild(this.items[i].element.parentNode);
                content.appendChild(newRow);
            }

            return content;
        }
    }]);
    return CueForm;
}(BaseForm);

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
  * Base class for calendar views.
  * For internal use only.
  * @private
  */

var Cell = function () {
  function Cell(calendar) {
    var _this = this;

    classCallCheck(this, Cell);

    this.calendar = calendar;

    this.Dom = {};
    this.items = [];

    this.cueClickHandler = function (e) {
      return _this.onCueClick(e);
    };

    this.buttonClickHandler = function (e) {
      return _this.onNavButtonClick(e);
    };
    this.headerClickHandler = function (e) {
      return _this.onHeaderClick(e);
    };
  }

  createClass(Cell, [{
    key: 'getElement',
    value: function getElement() {
      return this.calendar.getElement();
    }
  }, {
    key: 'getContent',
    value: function getContent() {
      if (!this.Dom.content) {
        this.Dom.content = this.getElement().querySelector("div.mfp-content");
      }
      return this.Dom.content;
    }
  }, {
    key: 'getScroller',
    value: function getScroller() {
      return this.getContent();
    }
  }, {
    key: 'getContainer',
    value: function getContainer() {
      return this.getContent();
    }
  }, {
    key: 'getHeader',
    value: function getHeader() {
      if (!this.Dom.header) {
        this.Dom.header = this.getElement().querySelector("div.mfp-header");
      }
      return this.Dom.header;
    }
  }, {
    key: 'getGroupHeader',
    value: function getGroupHeader() {
      return null;
    }
  }, {
    key: 'getTimelineHeader',
    value: function getTimelineHeader() {
      return null;
    }

    /* Render */

  }, {
    key: 'draw',
    value: function draw() {
      this._element = document.createElement("div");

      var header = this.drawHeader();
      this._element.appendChild(header);

      var content = this.drawContent();
      this._element.appendChild(content);

      return this._element;
    }
  }, {
    key: 'getItemAppointment',
    value: function getItemAppointment(item) {
      for (var i = 0, l = this.items.length; i < l; i++) {
        if (this.items[i].item.id === item.id && this.items[i].item.occurrenceIndex === item.occurrenceIndex) {
          return this.items[i];
        }
      }
      return null;
    }
  }, {
    key: 'removeAppointment',
    value: function removeAppointment(appointment) {
      this.items.splice(this.items.indexOf(appointment), 1);
      appointment.dispose();
    }
  }, {
    key: 'clearAppointments',
    value: function clearAppointments() {
      for (var i = 0, l = this.items.length; i < l; i++) {
        this.items[i].dispose();
      }
      this.items = [];
    }
  }, {
    key: 'endSelection',
    value: function endSelection(item) {
      if (this.calendar.useForms && this.calendar.enabled) {
        var p = new NewForm(this.calendar, item);
        p.showForm();
      }
    }
  }, {
    key: 'selectItem',
    value: function selectItem(e, data) {
      if (this._selectionPaused) return;

      this.calendar._itemSelection.clear();
      this.calendar._itemSelection.add(data.item);

      this.itemData = data;
      this._dragging = false;
      this._resizing = false;
      this._selecting = true;

      data.startPos = DomUtils.getCursorPosition(e, this.getContainer());

      data.popupMode = DomUtils.getParent(data.appointment.Dom.wrapper, "mfp-popup") != null;

      if (!data.item.allowMove || data.item.locked) {
        return true;
      }
      if (e.target.className.indexOf('resize') > -1 && !data.popupMode) {
        this.resize = new ResizeItem(this, data);
        this.resizeStartCell = this.itemData.itemStartCell;
        this.resizeLastCell = this.itemData.itemLastCell;
      } else if (!this.drag) {
        this.drag = new DragItem(this, data);
      }
    }
  }, {
    key: 'endItemDrag',
    value: function endItemDrag(changes) {

      this.calendar.modifyItem(this.itemData.item, changes, ItemModifyAction.Drag);

      this._selecting = false;
      this._dragging = false;

      //  this.itemData.appointment.element.style.cursor = 'pointer';
      //  this.getContent().style.cursor = 'default';

      this.drag.dispose();
      this.dragContainer.dispose();
      this.itemData = null;
    }
  }, {
    key: 'endItemResize',
    value: function endItemResize(changes) {

      this.calendar.modifyItem(this.itemData.item, changes, ItemModifyAction.Resize);

      this._selecting = false;
      this._resizing = false;

      this.resize.dispose();
      this.resizeContainer.dispose();
      this.itemData = null;
    }
  }, {
    key: 'cancelInteraction',
    value: function cancelInteraction(action) {}
  }, {
    key: 'placeItems',
    value: function placeItems() {
      for (var i = 0; i < this.items.length; i++) {
        var item = this.items[i];

        if (item.cell) {
          item.hidden = false;
          item.element.parentNode.style.cssText = '';
          item.element.style.margin = this.calendar.itemSettings.spacing + 'px';
          if (this.calendar.itemSettings.spacing > 0) {
            item.element.style.marginBottom = '0px';
          }

          item.cell.appendChild(item.element.parentNode);
        } else {
          item.hidden = true;
          item.row = -1;
        }
      }
    }
  }, {
    key: 'getAllItems',
    value: function getAllItems() {

      var items = [];

      var source = this.calendar.schedule.items.items();
      var startTime = this.itemsStartTime;
      var endTime = this.itemsEndTime;

      for (var i = 0, l = source.length; i < l; i++) {
        var item = source[i];

        // recurrence items
        if (item.recurrenceState === RecurrenceState.Master) {

          var startTimeTicks = startTime.valueOf() - (item.endTime.valueOf() - item.startTime.valueOf());
          if (startTimeTicks < 0) startTimeTicks = 0;

          var occurrences = item.recurrence.generateItems(new DateTime(new Date(startTimeTicks)), endTime);

          // endTime fix
          var master = item;
          for (var k = 0, n = occurrences.length; k < n; k++) {
            var occ = occurrences[k];

            if (occ.recurrenceState === RecurrenceState.Occurrence) {
              if (this.calendar.currentView !== CalendarView.Timetable) {
                if (occ.allDayEvent) {
                  var duration = DateTime.millisecondsBetween(master.endTime, master.startTime);
                  occ._endTime = DateTime.addTicksToDate(occ.startTime, duration);
                } else {
                  var duration = master.endTime.valueOf() - master.startTime.valueOf();
                  occ._endTime = new DateTime(new Date(occ.startTime.valueOf() + duration));
                }
              } else {
                var d = occ.startTime.valueOf() + (master.endTime.valueOf() - master.startTime.valueOf());
                occ._endTime = new DateTime(new Date(d));
              }
            }
          }

          for (var j = 0, m = occurrences.length; j < m; j++) {
            occurrences[j].isHeader = occurrences[j].allDayEvent || occurrences[j].endTime.valueOf() - occurrences[j].startTime.valueOf() >= this.dayLength;

            if (this.itemInViewRange(occurrences[j])) items.push(occurrences[j]);
          }
        } else {
          // regular items
          if (item.recurrenceState === RecurrenceState.None) {

            if (this.itemInViewRange(item)) items.push(item);
          }
        }
      }

      this.calendar.applyFilter(items);

      var appointments = [];

      for (var i = 0, l = items.length; i < l; i++) {
        var item = items[i];

        if (item.recurrenceState != RecurrenceState.Master) {

          if (item.recurrenceState === RecurrenceState.None) {
            var apps = this.getItemElements(item);

            if (apps.length === 0) {
              var apps = this.createAppointment(item);
            }

            if (apps.length > 0) {
              appointments = appointments.concat(apps);
            }
          } else {
            var apps = this.createOccurrence(item);
            if (apps.length > 0) {
              appointments = appointments.concat(apps);
            }
          }
        }
      }

      for (var i = 0, l = appointments.length; i < l; i++) {
        if (this.calendar.itemSelection.contains(appointments[i].item)) DomUtils.addCssClass(appointments[i].element, "mfp-selected");else DomUtils.removeCssClass(appointments[i].element, "mfp-selected");
      }

      appointments.sort(this.calendar.sortAppointments);

      this.items = appointments;

      this.calendar.setTimer();
    }
  }, {
    key: 'itemInViewRange',
    value: function itemInViewRange(item) {
      var ranges = [];

      if (this.calendar.currentView === CalendarView.Timetable) {

        if (item.allDayEvent && !this.settings._showDayHeader) return false;

        for (var i = 0, l = this._columns.count(); i < l; i++) {
          ranges.push(this._columns.items()[i].timeRange);
        }
      } else ranges.push(new TimeRange(this.itemsStartTime, this.itemsEndTime));

      var itemRange = new TimeRange(item.startTime, item.endTime);
      for (var i = 0, l = ranges.length; i < l; i++) {
        if (ranges[i].contains(itemRange)) return true;
        if (ranges[i].intersects(itemRange)) return true;
      }

      return false;
    }
  }, {
    key: 'createAppointment',
    value: function createAppointment(args) {
      var data = {
        view: this,
        create: true,
        item: args
      };

      data.isHeader = args.endTime.valueOf() - args.startTime.valueOf() >= DateTime.MillisPerDay;

      var appointment = new Appointment(data);
      this.getElement().appendChild(appointment.element.parentNode);
      return this.updateItem(appointment, false);
    }

    /**
    * Creates a new occurrence appointment.
    */

  }, {
    key: 'createOccurrence',
    value: function createOccurrence(args) {
      var data = {
        view: this,
        occurrence: true,
        item: args
      };

      data.isHeader = args.endTime.valueOf() - args.startTime.valueOf() >= DateTime.MillisPerDay;

      var appointment = new Appointment(data);
      this.getElement().appendChild(appointment.element.parentNode);
      return this.updateItem(appointment, false);
    }
  }, {
    key: 'itemsContainItem',
    value: function itemsContainItem(item, items) {
      for (var i = 0; i < items.length; i++) {
        if (items[i].item === item.item) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'getItemElements',
    value: function getItemElements(item) {
      var result = [];
      for (var i = 0, l = this.items.length; i < l; i++) {
        if (this.items[i].item.id === item.id && this.items[i].item.occurrenceIndex === item.occurrenceIndex) {
          result.push(this.items[i]);
        }
      }
      return result;
    }
  }, {
    key: 'getItemsCount',
    value: function getItemsCount(cell) {
      return this.itemsCount;
    }
  }, {
    key: 'getHiddenItems',
    value: function getHiddenItems() {
      for (var i = 0, l = this.items.length; i < l; i++) {
        var item = this.items[i];
        if (item.row >= this.itemsCount) {
          item.hidden = true;
          item.row = -1;
        }
      }
    }
  }, {
    key: 'isValidCell',
    value: function isValidCell(index) {
      if (index === null) {
        return false;
      }

      if (this.firstVisibleCell !== null && this.firstVisibleCell !== undefined) {
        if (index < this.firstVisibleCell || index > this.lastVisibleCell) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: 'getCellHeaderAt',
    value: function getCellHeaderAt(cell, x, y) {
      // in resource view cell title and cell.bgTitle are the same
      if (cell.title & cell.title != cell.bgCell) {
        var cursor = DomUtils.getCursorPosition({ clientX: x, clientY: y }, cell.bgCell);
        var b = DomUtils.getBounds(cell.title);
        if (cursor.y < b.height) return cell;
      }
      return null;
    }
  }, {
    key: 'getDragOffset',
    value: function getDragOffset(cell, item) {
      var masterRows = this.getContent().querySelectorAll("table.mfp-item-table")[cell.rowIndex].querySelectorAll('.mfp-item-row');

      var rowsDict = [];
      for (var i = 0, l = masterRows.length; i < l; i++) {
        rowsDict[i] = masterRows[i].clientHeight > 0;
      }var itemsInCell = this.getAllItemsInCell(cell);

      if (this.itemsContainItem(item, itemsInCell)) itemsInCell.splice(itemsInCell.indexOf(item), 1);

      if (itemsInCell.length === 0) return 0;
      var indexColl = [];
      for (var i = 0, l = itemsInCell.length; i < l; i++) {
        if (itemsInCell[i].row != -1) indexColl.push(itemsInCell[i].row);
      }

      indexColl.sort(function (a, b) {
        return a - b;
      });

      var rowsDictLength = rowsDict.length;
      var result = 0;
      for (var l = indexColl.length; result < l; result++) {

        if (result < rowsDictLength && !rowsDict[result] || indexColl[result] === result || indexColl.indexOf(result) > -1) continue;
        return result;
      }
      return result;
    }
  }, {
    key: 'getCues',
    value: function getCues() {
      this.cues = [];

      var items = this.parent ? this.parent.items : this.items;
      var itemsCount = this.parent ? this.itemsCount : this.itemsCount;

      for (var i = 0, l = items.length; i < l; i++) {
        var item = items[i];

        if (this.parent && item.monthCellIndex != this.index) continue;

        if (item.row >= itemsCount || item.row === -1) {
          var cells = this.getItemCueCells(item);
          for (var k = 0; k < cells.length; k++) {
            if (this.cues.indexOf(cells[k]) === -1) this.cues.push(cells[k]);
          }
          item.element.parentNode.style.visibility = 'hidden';
          item.element.parentNode.style.display = 'none';
        } else item.element.parentNode.style.visibility = 'visible';
      }
    }
  }, {
    key: 'getItemCueCells',
    value: function getItemCueCells(item) {
      var result = [];
      for (var i = item.startCellIndex; i <= item.lastCellIndex; i++) {
        result.push(i);
      }
      return result;
    }
  }, {
    key: 'createCues',
    value: function createCues() {
      this.clearCues();

      if (this.calendar.itemSettings.showCues != false) {
        var headers = this.cueCells;
        for (var i = 0, l = this.cues.length; i < l; i++) {
          var c = document.createElement('div');
          c.className = 'mfp-cue';

          var a = document.createElement('i');
          c.appendChild(a);

          var header = headers[this.cues[i]];
          header.innerHTML = "";
          header.appendChild(c);

          c.addEventListener('click', this.cueClickHandler);
        }
      }
    }
  }, {
    key: 'clearCues',
    value: function clearCues() {
      var indicators = this.getElement().querySelectorAll(".mfp-cue");
      for (var i = 0, l = indicators.length; i < l; i++) {
        indicators[i].removeEventListener('click', this.cueClickHandler);
      }
      DomUtils.removeNodes(indicators);
    }
  }, {
    key: 'getCueItems',
    value: function getCueItems(cell) {
      var result = [];
      var items = this.parent ? this.parent.items : this.items;

      for (var i = 0, l = items.length; i < l; i++) {

        if (this.parent && items[i].monthCellIndex != this.index) continue;

        if (items[i].startCellIndex <= cell.index && items[i].lastCellIndex >= cell.index) {
          if (items[i].hidden) {
            result.push(items[i]);
          }
        }
      }
      return result;
    }
  }, {
    key: 'onCueClick',
    value: function onCueClick(e) {
      if (!this._selectionPaused && !this._dragging) {

        var cell = this.getCellAt(e.clientX, e.clientY);

        this.calendar.onCueClick(new CellEventArgs(cell));

        var items = this.getCueItems(cell);

        if (this.calendar.enabled && this.calendar.useForms) {
          var p = new CueForm(this.calendar, items, cell, null);
          p.showForm();
        }
      }
    }
  }, {
    key: 'onHeaderClick',
    value: function onHeaderClick(e) {
      var headerType = this.getHeaderType(e.target);
      this.calendar.onHeaderClick(new HeaderEventArgs(headerType));
      e.stopPropagation();
    }
  }, {
    key: 'getHeaderType',
    value: function getHeaderType(element) {
      var h = this.getGroupHeader();
      if (h) {
        if (h.contains(element)) return HeaderType.Group;
      }

      h = this.getTimelineHeader();
      if (h) {
        if (h.contains(element)) return HeaderType.Timeline;
      }

      var h = this.getHeader();
      if (h) {
        if (h.contains(element)) return HeaderType.Main;
      }
    }
  }, {
    key: 'onNavButtonClick',
    value: function onNavButtonClick(e) {
      if (this.calendar.enabled) {
        var buttonType = 1;
        if (DomUtils.hasCssClass(e.currentTarget, "mfp-button-next-2")) buttonType = 2;else if (DomUtils.hasCssClass(e.currentTarget, "mfp-button-prev")) buttonType = -1;else if (DomUtils.hasCssClass(e.currentTarget, "mfp-button-prev-2")) buttonType = -2;

        this.calendar.processButtonClick(buttonType);
      }
    }
  }, {
    key: 'onThemeChanged',
    value: function onThemeChanged(oldValue, newValue) {}
  }, {
    key: 'cueCells',
    get: function get$$1() {
      return this.getContent().querySelectorAll(".mfp-item-table .mfp-cell-header");
    }
  }, {
    key: 'orientation',
    get: function get$$1() {
      return Orientation.Horizontal;
    }
  }, {
    key: 'formatInfo',
    get: function get$$1() {
      return this.calendar.formatInfo;
    }
  }, {
    key: 'startTime',
    get: function get$$1() {
      return this._startTime;
    },
    set: function set$$1(value) {
      this._startTime = value;
    }
  }, {
    key: 'endTime',
    get: function get$$1() {
      return this._endTime;
    },
    set: function set$$1(value) {
      this._endTime = value;
    }
  }, {
    key: 'itemsStartTime',
    get: function get$$1() {
      return this._itemsStartTime;
    },
    set: function set$$1(value) {
      this._itemsStartTime = value;
    }
  }, {
    key: 'itemsEndTime',
    get: function get$$1() {
      return this._itemsEndTime;
    },
    set: function set$$1(value) {
      this._itemsEndTime = value;
    }
  }, {
    key: 'settings',
    get: function get$$1() {
      return this._settings;
    }
  }, {
    key: 'grouped',
    get: function get$$1() {
      var groupable = this.calendar.currentView === CalendarView.Timetable || this.calendar.currentView === CalendarView.List || this.calendar.currentView === CalendarView.ResourceView;
      return groupable && this.calendar.groupType > 0 && this.calendar.groupType < 5;
    }
  }, {
    key: 'resources',
    get: function get$$1() {
      return this.calendar.groupResources.items();
    }
  }, {
    key: 'groupResources',
    get: function get$$1() {
      return this.resources;
    }
  }]);
  return Cell;
}();

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* For internal use only.
* @private
*/

var ViewRow = function () {
    function ViewRow(start, end, itemStart, itemEnd) {
        classCallCheck(this, ViewRow);

        this._startTime = start;
        this._endTime = end;
        this._itemsStartTime = itemStart;
        this._itemsEndTime = itemEnd;

        this.cells = new List();
        //this.items = new List();
    }

    createClass(ViewRow, [{
        key: 'index',
        get: function get$$1() {
            return this._index;
        },
        set: function set$$1(value) {
            this._index = value;
        }
    }, {
        key: 'startTime',
        get: function get$$1() {
            return this._startTime;
        }
    }, {
        key: 'endTime',
        get: function get$$1() {
            return this._endTime;
        }
    }, {
        key: 'itemsStartTime',
        get: function get$$1() {
            return this._itemsStartTime;
        },
        set: function set$$1(value) {
            this._itemsStartTime = value;
        }
    }, {
        key: 'itemsEndTime',
        get: function get$$1() {
            return this._itemsEndTime;
        },
        set: function set$$1(value) {
            this._itemsEndTime = value;
        }
    }, {
        key: 'rowOffset',
        get: function get$$1() {
            return this._rowOffset;
        },
        set: function set$$1(value) {
            this._rowOffset = value;
        }
    }, {
        key: 'cells',
        get: function get$$1() {
            return this._cells;
        },
        set: function set$$1(value) {
            this._cells = value;
        }
    }]);
    return ViewRow;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
 * @class Encapsulates data for a datetime cell in a calendar view.
 * @property {Number} index Gets the index of the cell.
 * @property {DateTime} startTime Gets the start time of the cell.
 * @property {DateTime} endTime Gets the end time of the cell.
 * @property {Resource} resource Gets the resource associated with the cell.
 * @property {DOMElement} bgCell Gets DOM element of the cell's content.
 * @property {DOMElement} title Gets DOM element of the cell's header.
 * @property {Boolean} isHeader Gets a value indicating whether this cell is a header cell.
 */
var ViewCell = function () {
    /**
    * @private
    */
    function ViewCell() {
        classCallCheck(this, ViewCell);

        this._resource = null;
    }

    /**
    * Gets the index of the cell.
    */


    createClass(ViewCell, [{
        key: "index",
        get: function get$$1() {
            return this._index;
        }

        /**
        * For internal use only.
        * @private
        */
        ,
        set: function set$$1(value) {
            this._index = value;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: "cellIndex",
        get: function get$$1() {
            return this._cellIndex;
        }
        /**
        * For internal use only.
        * @private
        */
        ,
        set: function set$$1(value) {
            this._cellIndex = value;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: "rowIndex",
        get: function get$$1() {
            return this._rowIndex;
        }
        /**
        * For internal use only.
        * @private
        */
        ,
        set: function set$$1(value) {
            this._rowIndex = value;
        }
        /**
        * For internal use only.
        * @private
        */

    }, {
        key: "columnIndex",
        get: function get$$1() {
            return this._columnIndex;
        }
        /**
        * For internal use only.
        * @private
        */
        ,
        set: function set$$1(value) {
            this._columnIndex = value;
        }

        /**
        * Gets the start time of the cell.
        * @returns {DateTime} The start time of the cell.
        */

    }, {
        key: "startTime",
        get: function get$$1() {
            return this._startTime;
        }
        /**
        * For internal use only.
        * @private
        */
        ,
        set: function set$$1(value) {
            this._startTime = value;
        }
        /**
        * Gets the end time of the cell.
        * @returns {DateTime} The end time of the cell.
        */

    }, {
        key: "endTime",
        get: function get$$1() {
            return this._endTime;
        }
        /**
        * For internal use only.
        * @private
        */
        ,
        set: function set$$1(value) {
            this._endTime = value;
        }
        /**
        * Gets the resource associated with the cell.
        * @returns {Resource} The resource associated with the cell in a grouped view, or null in a non-grouped view.
        */

    }, {
        key: "resource",
        get: function get$$1() {
            return this._resource;
        }
        /**
        * For internal use only.
        * @private
        */
        ,
        set: function set$$1(value) {
            this._resource = value;
        }
        /**
        * Gets the DOM element of the cell's content.
        * @returns {DOMElement} The DOM element representing the cell content.
        */

    }, {
        key: "bgCell",
        get: function get$$1() {
            return this._bgCell;
        }
        /**
        * For internal use only.
        * @private
        */
        ,
        set: function set$$1(value) {
            this._bgCell = value;
        }
        /**
        * Gets the DOM element of the cell's header.
        * @returns {DOMElement} The DOM element representing the cell header.
        */

    }, {
        key: "title",
        get: function get$$1() {
            return this._title;
        }
        /**
        * For internal use only.
        * @private
        */
        ,
        set: function set$$1(value) {
            this._title = value;
        }

        /**
        * Gets a value indicating whether this cell is a header cell.
        * @returns {Boolean} True if it is a header cell, otherwise false.
        * @remarks Only applies to Timetable view cells.
        */

    }, {
        key: "isHeader",
        get: function get$$1() {
            return this._isHeader;
        }
        /**
        * For internal use only.
        * @private
        */
        ,
        set: function set$$1(value) {
            this._isHeader = value;
        }
    }]);
    return ViewCell;
}();

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/** 
* For internal use only.
* @private
*/

var DummyItem = function DummyItem(startTime, endTime, headerText, allDay, calendar, resource) {
    classCallCheck(this, DummyItem);

    this.startTime = startTime;
    this.endTime = endTime;
    this.headerText = headerText;
    this.allDayEvent = allDay;
    this.allowMove = true;
    this.allowChangeStart = true;
    this.allowChangeEnd = true;
    this.locked = false;

    if (calendar) {
        switch (calendar.groupType) {
            case GroupType.FilterByContacts:
                this.contacts = calendar.contacts;
                break;
            case GroupType.FilterByLocations:
                this.location = calendar.locations.items()[0];
                break;
            case GroupType.FilterByTasks:
                this.task = calendar.tasks.items()[0];
                break;
            case GroupType.FilterByResources:
                this.resources = calendar.resources;
                break;
            default:
                break;
        }
        if (resource) {
            if (resource instanceof Location) {
                this.location = resource;
            } else if (resource instanceof Contact) {
                this.contacts = new ObservableCollection();
                this.contacts.add(resource);
            } else if (resource instanceof Task) {
                this.task = resource;
            } else if (resource instanceof Resource) {
                this.resources = new ObservableCollection();
                this.resources.add(resource);
            }
        }
    }
    return this;
};

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* For internal use only.
* @private
*/

var MonthCell = function (_Cell) {
    inherits(MonthCell, _Cell);

    function MonthCell(calendar, parent, date, index, firstLast, maxWeekCount) {
        classCallCheck(this, MonthCell);

        var _this = possibleConstructorReturn(this, (MonthCell.__proto__ || Object.getPrototypeOf(MonthCell)).call(this, calendar));

        _this.unit = TimeUnit.Day;

        if (!parent) {
            _this.index = 0;
            _this._showLeadingDays = calendar.monthSettings.showPaddingDays;
            _this._showTrailingDays = calendar.monthSettings.showPaddingDays;
            _this._maxWeekCount = -1;

            _this._date = _this.calendar.date;
        } else {
            _this.parent = parent;

            _this.index = index;

            _this._date = date;

            if (!calendar.monthSettings.showPaddingDays) {
                _this._showLeadingDays = false;
                _this._showTrailingDays = false;
            } else {
                _this._showLeadingDays = firstLast === -1 || firstLast === 2;
                _this._showTrailingDays = firstLast === 1 || firstLast === 2;
            }

            _this._maxWeekCount = maxWeekCount;
        }

        _this._settings = _this.calendar.monthSettings;

        _this.itemsCount = 3;
        _this.rowCellsCount = 7;

        _this._rows = new List();

        _this.initVars();

        _this._dragging = false;
        _this._resizing = false;
        _this._selecting = false;
        _this._selectionPaused = false;

        _this.items = [];

        _this.Dom = {};
        return _this;
    }

    createClass(MonthCell, [{
        key: 'initVars',
        value: function initVars() {
            this._isSubHeaderVisible = false;
            this._daysPerWeek = 7;

            this._date = this.calendar.getMonthFirstDate(this._date);

            this._startTime = this.calendar.getMonthFirstVisibleDate(this._date);

            var weekCount = 6;

            var d = DateTime.addDays(this._date, DateTime.getDaysInMonth(this._date));
            while (d.dayOfWeek !== +this.formatInfo.firstDayOfWeek) {
                d = DateTime.addDays(d, 1);
            }var t = TimeSpan.fromMilliseconds(d - this._startTime);
            weekCount = Math.round(t.days / this._daysPerWeek);

            if (this._settings.leadingWeekCount > 0 && this._showLeadingDays) this._startTime = DateTime.addDays(this._startTime, -1 * this._settings.leadingWeekCount * this._daysPerWeek);

            if (!this._settings.hideTrailingWeeks) {

                this._rowsCount = (this._showTrailingDays ? this._settings.leadingWeekCount + (weekCount !== 6 && this._settings.trailingWeekCount > 0 && !this._settings.hideTrailingWeeks ? this._settings.trailingWeekCount - (6 - weekCount) : this._settings.trailingWeekCount) : 0) + (this._settings.hideTrailingWeeks ? weekCount : 6);
            } else this._rowsCount = (this._showTrailingDays ? this._settings.leadingWeekCount : 0) + (this._settings.hideTrailingWeeks ? weekCount : 6);

            if (this._maxWeekCount !== -1) this._rowsCount = this._maxWeekCount;

            this._rowHeight = Math.round(100 / this._rowsCount, 3);
            this._endTime = DateTime.addDays(this._startTime, this._rowsCount * this._daysPerWeek);

            this.createRows();
        }

        /* Dom */

    }, {
        key: 'getElement',
        value: function getElement() {
            if (this.parent) {
                return this.calendar.getElement().querySelectorAll('div.mfp-content')[this.index].parentNode;
            }
            return this.calendar.getElement();
        }
    }, {
        key: 'getWeekHeader',
        value: function getWeekHeader() {
            if (!this.Dom.weekHeader) {
                this.Dom.weekHeader = this.getContent().querySelector('div.mfp-header-weeknumbers');
            }
            return this.Dom.weekHeader;
        }
    }, {
        key: 'getDaysHeader',
        value: function getDaysHeader() {
            if (!this.Dom.daysHeader) {
                this.Dom.daysHeader = this.getHeader().querySelector('div.mfp-header-weekdays');
            }
            return this.Dom.daysHeader;
        }
    }, {
        key: 'getRows',
        value: function getRows() {
            if (!this.Dom.rows) {
                this.Dom.rows = this.getContent().querySelectorAll('div.mfp-week');
            }
            return this.Dom.rows;
        }
    }, {
        key: 'getBgCells',
        value: function getBgCells() {
            if (!this.Dom.bgCells) {
                this.Dom.bgCells = this.getContent().querySelectorAll('div.mfp-bg-cell');
            }
            return this.Dom.bgCells;
        }
    }, {
        key: 'createRows',
        value: function createRows() {
            var showLeadingPaddingItems = this._showLeadingDays && this._settings.showPaddingItems;
            var showTrailingPaddingItems = this._showTrailingDays && this._settings.showPaddingItems;

            var rowStart, rowEnd, realStart, realEnd;

            // Calculating Days
            if (!showLeadingPaddingItems && !showTrailingPaddingItems) {
                rowStart = this._date;
                rowEnd = DateTime.addDays(this._date, DateTime.getDaysInMonth(this._date));
                realStart = rowStart;
                realEnd = rowEnd;
            } else if (showLeadingPaddingItems && !showTrailingPaddingItems) {
                rowStart = this._startTime;
                rowEnd = DateTime.addDays(this._date, DateTime.getDaysInMonth(this._date));
                realStart = rowStart;
                realEnd = rowEnd;
            } else if (!showLeadingPaddingItems && showTrailingPaddingItems) {
                rowStart = this._date;
                rowEnd = this._endTime;
                realStart = rowStart;
                realEnd = rowEnd;
            } else {
                rowStart = this._startTime;
                rowEnd = this._endTime;
                realStart = rowStart;
                realEnd = rowEnd;
            }
            this.itemsStartTime = realStart;
            this.itemsEndTime = realEnd;

            var j = 0;

            var newRow = null;
            for (var row = 0; row < this._rowsCount; row++) {
                rowStart = DateTime.addDays(this._startTime, row * this._daysPerWeek);
                rowEnd = DateTime.addDays(rowStart, this._daysPerWeek);
                newRow = new ViewRow(rowStart, rowEnd, rowStart, rowEnd);
                newRow.index = row;
                newRow.monthCellIndex = this.index;

                if (realStart >= rowStart && rowEnd > realStart && rowEnd < realEnd || realStart < rowStart && rowEnd >= realEnd && rowStart < realEnd || realStart < rowStart && rowEnd < realEnd) {
                    if (newRow.startTime < realStart) {
                        newRow.rowOffset = DateTime.daysBetween(newRow.startTime, realStart);
                        newRow.itemsStartTime = realStart;
                    }
                    if (newRow.endTime > realEnd) {
                        newRow.rowOffset = -1 * DateTime.daysBetween(realEnd, newRow.endTime);
                        newRow.itemsEndTime = realEnd;
                    }
                } else if (rowStart < realStart && rowEnd <= realStart) //leading
                    {
                        newRow.itemsStartTime = DateTime.minValue();
                        newRow.itemsEndTime = DateTime.minValue();
                    } else {
                    newRow.itemsEndTime = realEnd;
                }

                this._rows.add(newRow);

                for (var k = 0, m = this.rowCellsCount; k < m; k++) {
                    var cellStartTime = DateTime.addDays(newRow.startTime, k);
                    var cellEndTime = DateTime.addDays(newRow.startTime, k + 1);
                    var cell = new ViewCell();
                    cell.index = j;
                    cell.cellIndex = k;
                    cell.rowIndex = row;
                    cell.startTime = cellStartTime;
                    cell.endTime = cellEndTime;
                    newRow.cells.add(cell);
                    j += 1;
                }
            }

            var st = this._showLeadingDays ? this._rows.items()[0].startTime : this._rows.items()[0].itemsStartTime;
            var et = this._showLeadingDays ? this._rows.items()[this._rows.count() - 1].endTime : this._rows.items()[this._rows.count() - 1].itemsEndTime;

            this.firstVisibleCell = this.getTimeCell(st, false).index;
            this.lastVisibleCell = this.getTimeCell(et, true).index;

            for (var i = 0; i < this.cells.count(); i++) {
                this.cells.items()[i].visible = this.cells.items()[i].index >= this.firstVisibleCell && this.cells.items()[i].index <= this.lastVisibleCell;
            }
        }
    }, {
        key: 'detach',
        value: function detach() {
            if (!this.parent) {
                var buttons = this.getHeader().querySelectorAll("a.mfp-button");
                for (var i = 0; i < buttons.length; i++) {
                    buttons[i].removeEventListener('click', this.buttonClickHandler);
                }
            }

            this.getHeader().removeEventListener("click", this.headerClickHandler);
            if (this.getWeekHeader()) this.getWeekHeader().removeEventListener("click", this.headerClickHandler);
            if (this.getDaysHeader()) this.getDaysHeader().removeEventListener("click", this.headerClickHandler);
        }
    }, {
        key: 'attach',
        value: function attach() {
            var bgTables = this.getContent().querySelectorAll("div.mfp-bg-row");
            var itemTables = this.getContent().querySelectorAll("table.mfp-item-table");

            for (var i = 0; i < this._rows.count(); i++) {
                var row = this._rows.items()[i];
                row.bgTable = bgTables[i];
                row.itemTable = itemTables[i];

                var bgCells = row.bgTable.querySelectorAll("div.mfp-bg-cell");

                for (var k = 0, m = row.cells.count(); k < m; k++) {
                    var cell = row.cells.items()[k];
                    cell.bgCell = bgCells[k];
                    cell.title = bgCells[k].childNodes[0];
                }
            }

            // flex items repaint for month range view
            this.getContent().querySelector(".mfp-wrap").style.display = "none";
            this.getContent().querySelector(".mfp-wrap").style.display = "flex";

            if (!this.parent) {
                this.clear();
                this.init();

                var buttons = this.getHeader().querySelectorAll("a.mfp-button");
                for (var i = 0; i < buttons.length; i++) {
                    buttons[i].addEventListener('click', this.buttonClickHandler);
                }
            }

            this.getHeader().addEventListener("click", this.headerClickHandler);
            if (this.getWeekHeader()) this.getWeekHeader().addEventListener("click", this.headerClickHandler);
            if (this.getDaysHeader()) this.getDaysHeader().addEventListener("click", this.headerClickHandler);
        }
    }, {
        key: 'getAllItemsInCell',
        value: function getAllItemsInCell(cell) {
            var result = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].startCellIndex <= cell.index && this.items[i].lastCellIndex >= cell.index) {
                    if (this.items[i].row < this.itemsCount || this.items[i].row === -1) {
                        result.push(this.items[i]);
                    }
                }
            }
            return result;
        }
    }, {
        key: 'getCellAt',
        value: function getCellAt(x, y) {
            var i = this.getCellIndexAt(x, y);
            return this.cells.items()[i];
        }
    }, {
        key: 'getCellIndexAt',
        value: function getCellIndexAt(x, y) {
            if (!this.rowHeight) this.getDimensions();
            var cursor = DomUtils.getCursorPosition({ clientX: x, clientY: y }, this.getContent(), this.getScroller());
            var r = Math.floor(cursor.y / this.rowHeight);
            var c = Math.floor((cursor.x - this.offsetLeft) / this.calculatedCellWidth);
            if (c >= this.rowCellsCount || c < 0 || r >= this._rows.count() || r < 0) {
                return null;
            }
            return r * this.rowCellsCount + c;
        }

        /* Interactions */

    }, {
        key: 'endSelection',
        value: function endSelection(e, start, end) {
            var st = this.cells.items()[start].startTime;
            var et = this.cells.items()[end].endTime;

            var item = new DummyItem(st, et, '', true, this._calendar);
            get(MonthCell.prototype.__proto__ || Object.getPrototypeOf(MonthCell.prototype), 'endSelection', this).call(this, item);
        }
    }, {
        key: 'endItemDrag',
        value: function endItemDrag(e) {
            var cell = this.getCellAt(e.clientX, e.clientY);
            var startCell = this.cells.items()[this.itemData.startCellIndex];
            if (!cell) {
                cell = startCell;
            }

            if (cell.index < this.firstVisibleCell) {
                cell = this.cells.items()[this.firstVisibleCell];
            } else if (cell.index > this.lastVisibleCell) {
                cell = this.cells.items()[this.lastVisibleCell];
            }

            var item = this.itemData.item;
            var app = this.itemData.appointment;

            var startTime = DateTime.setTimeOfDay(item.startTime, cell.startTime);
            var endTime = app.getEndTime(startTime);

            get(MonthCell.prototype.__proto__ || Object.getPrototypeOf(MonthCell.prototype), 'endItemDrag', this).call(this, { startTime: startTime, endTime: endTime });
        }
    }, {
        key: 'endItemResize',
        value: function endItemResize(e) {
            var startCell = this.itemData.itemStartCell;
            var endCell = this.itemData.itemLastCell;

            var cell = this.getCellAt(e.clientX, e.clientY);
            if (!cell) {
                startCell = endCell = null;
            }

            var item = this.itemData.item;
            var app = this.itemData.appointment;

            var startTime = startCell != null ? DateTime.setTimeOfDay(item.startTime, startCell.startTime) : item.startTime;
            var endTime = endCell != null ? endCell.endTime : item.endTime;

            get(MonthCell.prototype.__proto__ || Object.getPrototypeOf(MonthCell.prototype), 'endItemResize', this).call(this, { startTime: startTime, endTime: endTime });
        }

        /* Item placement */

    }, {
        key: 'getDimensions',
        value: function getDimensions() {

            var getBounds = DomUtils.getBounds;
            this.cellWidth = getBounds(this.getBgCells()[0]).width;
            this.calculatedCellWidth = getBounds(this.getRows()[0]).width / this.rowCellsCount;
            this.rowHeight = getBounds(this.getRows()[0]).height;
            this.headerHeight = getBounds(DomUtils.firstRealChild(this.getBgCells()[0])).height;
            this.offsetLeft = this._settings.weekHeaderStyle == VerticalHeaderStyle.Left ? getBounds(this.getWeekHeader()).width : 0;

            this.dragOffsetLeft = getBounds(this.calendar.getElement()).x;
            this.dragWidth = this.cellWidth;

            this.itemsCount = Math.floor((this.rowHeight - this.headerHeight) / (this.calendar.itemSettings.size + this.calendar.itemSettings.spacing));
            if (this._settings.maxItems) this.itemsCount = Math.min(this._settings.maxItems, this.itemsCount);

            if (this.items) {
                this.getHiddenItems();

                if (this.calendar.itemSettings.showItems) {
                    this.getCues();
                    this.createCues();
                }
            }
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'clear',
        value: function clear() {
            DomUtils.removeNodes(this.getContent().querySelectorAll('.mfp-item-wrap'));
            DomUtils.removeNodes(this.getContent().querySelectorAll('.mfp-item-row'));
        }
    }, {
        key: 'init',
        value: function init() {
            if (!this.cellWidth) this.getDimensions();

            this.getAllItems();

            this.itemsToPut = this.items.slice();

            for (var i = 0, l = this._rows.count(); i < l; i++) {
                this.createItemsTable(this._rows.items()[i]);
            }
            for (var i = 0; i < this.itemsToPut.length; i++) {
                var item = this.items[this.items.indexOf(this.itemsToPut[i])];
                item.cell = null;
                item.row = -1;
                item.hidden = true;
            }

            this.placeItems();

            if (this.calendar.itemSettings.showItems) {
                this.getCues();
                this.createCues();
            }
        }
    }, {
        key: 'createItemsTable',
        value: function createItemsTable(row) {
            var items; // = this.getItemsInRow(row);

            for (var i = 0, l = this.itemsCount; i < l; i++) {
                var trow = document.createElement('tr');
                trow.className = 'mfp-item-row';
                var day = 0;
                while (day < this.rowCellsCount) {
                    items = this.getItemsInCell(row.cells.items()[day], this.itemsToPut);

                    var item = null;
                    if (items.length > 0) item = items[0];
                    if (item !== null) {
                        var tcell = document.createElement('td');
                        tcell.className = 'mfp-item-cell';
                        tcell.colSpan = item.cellsLength;
                        tcell.style.paddingLeft = this.padding + 'px';
                        tcell.style.paddingRight = this.padding + 'px';
                        day += item.cellsLength - 1;
                        item.cell = tcell;
                        item.row = i;
                        this.itemsToPut.splice(this.itemsToPut.indexOf(item), 1);
                    } else {
                        var tcell = document.createElement('td');
                        tcell.className = 'mfp-item-cell';
                    }
                    trow.appendChild(tcell);
                    day += 1;
                }
                row.itemTable.getElementsByTagName("TBODY")[0].appendChild(trow);
            }
        }

        /**
              * For internal use only.
              * @private
              */

    }, {
        key: 'updateItem',
        value: function updateItem(appointment, addToItems) {
            var item = appointment.item;

            //invisible items
            if (!item.visible) {
                return appointment;
            }

            var parts = [];
            var removed = [];
            if (!this.hasVisibleParts(item)) {
                removed.push(appointment);
            } else if (this.isComposite(item)) {
                var ist = DateTime.maxDate(item.startTime, this.itemsStartTime, false);
                var iet = DateTime.minDate(item.endTime, this.itemsEndTime, true);
                var rows = this.getTimeRows(ist, iet);

                for (var j = rows.start, m = rows.end; j <= m; j++) {
                    var st = DateTime.maxDate(item.startTime, this._rows.items()[j].itemsStartTime, false);

                    var et = DateTime.minDate(item.endTime, this._rows.items()[j].itemsEndTime, true);
                    if (st.equals(et)) continue;
                    var partIndex = 0;

                    // todo : workaroud till DateTime is fixed
                    if (st.compareTo(item.startTime) === 1) // right arrow
                        partIndex = 1;
                    if (et.compareTo(item.endTime) === -1) // left arrow
                        partIndex = -1;
                    if (st.compareTo(item.startTime) === 1 && et.compareTo(item.endTime) === -1) // both arrows
                        partIndex = 0;

                    var scell = this.getTimeCell(st, false);
                    var lcell = this.getTimeCell(et, true);
                    var partData = {
                        prototype: appointment,
                        type: 'part',
                        cellIndex: scell.index,
                        cellsLength: lcell.index - scell.index + 1,
                        colIndex: j,
                        isPartial: true,
                        partIndex: partIndex,
                        lastCellIndex: lcell.index,
                        startCellIndex: scell.index
                    };
                    var part = new Appointment(partData);
                    part.composite = true;
                    parts.push(part);
                    removed.push(appointment);
                }
            } else {
                var cell = this.getTimeCell(item.startTime, false);
                if (item.startTime._date.valueOf() === item.endTime._date.valueOf()) {
                    var lcell = cell;
                } else {
                    var lcell = this.getTimeCell(item.endTime, true);
                }

                appointment.lastCellIndex = lcell.index;
                appointment.startCellIndex = cell.index;
                appointment.cellsLength = lcell.index - cell.index + 1;
                if (appointment.cellsLength < 1) {
                    appointment.cellsLength = 1;
                }
                appointment.cellIndex = cell.index;
                appointment.colIndex = cell.rowIndex;
                appointment.updateVisual();
            }

            for (var i = 0; i < removed.length; i++) {
                this.removeAppointment(removed[i]);
            }

            if (addToItems !== false) this.items = this.items.concat(parts);

            for (var i = 0; i < parts.length; i++) {
                parts[i].updateVisual();
            }

            //return value is only used for recurrent composite items
            if (parts.length > 0) return parts;
            parts.push(appointment);
            return parts;
        }
    }, {
        key: 'getTimeRows',
        value: function getTimeRows(start, end) {
            var fcell = this.getTimeCell(start, false);
            var ecell = this.getTimeCell(end, true);
            var startRow = fcell == null ? 0 : fcell.rowIndex;
            var endRow = ecell == null ? this._rows.count() - 1 : ecell.rowIndex;
            return { start: startRow, end: endRow };
        }

        /**
               * Gets the cell that corresponds to the specified time.
               * @param {Object} [time] The time to search for.
               * @param {Boolean} [isEndTime] true if the index of the first interval is returned when the time is the boundary between two consecutive intervals;
               false if the index of the second interval is contained.
               * @returns {Object} The cell that holds the specified time.
               */

    }, {
        key: 'getTimeCell',
        value: function getTimeCell(time, isEndTime) {
            if (time._date.valueOf() < this._startTime._date.valueOf()) return null;
            if (time._date.valueOf() > this._endTime._date.valueOf()) return null;
            var t = DateTime.setTimeOfDay(this.startTime, time);
            var i = DateTime.daysBetween(this.startTime, t);

            if (i > this.cells.count()) return null;
            if (i === this.cells.count()) {
                if (isEndTime && time.equals(this.cells.items()[i - 1].endTime)) return this.cells.items()[i - 1];else return null;
            }
            if (isEndTime && time.equals(this.cells.items()[i].startTime) && i > 0) i -= 1;
            return this.cells.items()[i];
        }
    }, {
        key: 'getTimeCells',
        value: function getTimeCells(startTime, endTime, isEndTime) {
            var startCell = null;
            var endCell = null;

            if (startTime.valueOf() < this.startTime.valueOf()) {
                startCell = this.cells[0];
            } else if (startTime.valueOf() > this.endTime.valueOf()) {
                return [];
            } else {
                startCell = this.getTimeCell(startTime, false);
            }
            if (endTime !== null && typeof endTime !== "undefined" && typeof endTime._date !== "undefined") {
                if (endTime.valueOf() > this.endTime.valueOf()) {
                    endCell = this.cells.items()[this.cells.count() - 1];
                } else if (endTime.valueOf() < this.startTime.valueOf()) {
                    return [];
                } else {
                    endCell = this.getTimeCell(endTime, isEndTime);
                }
            } else {
                endCell = startCell;
            }

            if (startCell && endCell) {
                return this.cells.items().slice(startCell.index, endCell.index + 1);
            }
            return [];
        }

        /**
             * For internal use only.
             * @private
             */

    }, {
        key: 'isComposite',
        value: function isComposite(item) {
            if (item.startTime._date.valueOf() === item.endTime._date.valueOf()) {
                return false;
            }
            var fcell = this.getTimeCell(item.startTime, false);
            var ecell = this.getTimeCell(item.endTime, true);
            if (fcell === null || ecell === null) return true;
            if (fcell.startTime._date.valueOf() < this.itemsStartTime._date.valueOf()) return true;
            if (ecell.endTime._date.valueOf() > this.itemsEndTime._date.valueOf()) return true;
            if (fcell.rowIndex === ecell.rowIndex) return false;
            return true;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'hasVisibleParts',
        value: function hasVisibleParts(item) {
            if (item.startTime._date.valueOf() >= this._rows.items()[0].itemsStartTime._date.valueOf() && item.startTime._date.valueOf() < this._rows.items()[this._rows.count() - 1].itemsEndTime._date.valueOf()) return true;
            if (item.endTime._date.valueOf() > this._rows.items()[0].itemsStartTime._date.valueOf() && item.endTime._date.valueOf() < this._rows.items()[this._rows.count() - 1].itemsEndTime._date.valueOf()) return true;
            if (item.startTime._date.valueOf() <= this._rows.items()[0].itemsStartTime._date.valueOf() && item.endTime._date.valueOf() >= this._rows.items()[0].itemsEndTime._date.valueOf()) return true;
            return false;
        }

        // getItemsInRow(row) {
        //     var items = [];
        //     for (var i = 0, l = this.itemsToPut.length; i < l; i++) {
        //         if (this.itemsToPut[i].startCellIndex >= row.index * 7 &&
        //             this.itemsToPut[i].startCellIndex < row.index * 7 + 7)
        //             items.push(this.itemsToPut[i]);
        //     }
        //     return items;
        // }

    }, {
        key: 'getItemsInCell',
        value: function getItemsInCell(cell, items) {
            var result = [];
            for (var i = 0, l = items.length; i < l; i++) {
                if (items[i].startCellIndex === cell.index) result.push(items[i]);
            }
            return result;
        }

        /**
              * For internal use only.
              * @private
              */

    }, {
        key: 'getFirstRowCell',
        value: function getFirstRowCell(row) {
            return this.cells.items()[row * this.rowCellsCount];
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getLastRowCell',
        value: function getLastRowCell(row) {
            return this.cells.items()[(row + 1) * this.rowCellsCount - 1];
        }
    }, {
        key: 'getHeaderType',
        value: function getHeaderType(element) {
            var h = this.getWeekHeader();
            if (h) {
                if (h.contains(element)) return HeaderType.WeekNumbers;
            }

            h = this.getDaysHeader();
            if (h) {
                if (h.contains(element)) return HeaderType.DayNames;
            }
            return get(MonthCell.prototype.__proto__ || Object.getPrototypeOf(MonthCell.prototype), 'getHeaderType', this).call(this, element);
        }

        /*Rendering*/

    }, {
        key: 'drawHeader',
        value: function drawHeader() {
            var result = null;

            var header = document.createElement("div");
            header.className = "mfp-header";
            result = header;

            if (this.settings.showHeader) {
                var title = document.createElement("div");
                title.className = "mfp-title";
                header.appendChild(title);

                var a = document.createElement("a");
                a.className = "mfp-link";
                title.appendChild(a);

                if ((this.settings.headerStyle & MainHeaderStyle.Title) === MainHeaderStyle.Title) a.innerHTML = this._date.toString(this.formatInfo.dateFormats.yearMonth, this.formatInfo);else a.innerHTML = "&nbsp;";

                if (this.calendar.showTooltips) a.title, this._date.toString(this.formatInfo.dateFormats.yearMonth, this.formatInfo);

                if (!this.parent) {
                    if ((this._settings.headerStyle & MainHeaderStyle.Buttons) === MainHeaderStyle.Buttons) {
                        var b = this.drawHeaderButtons(title);
                    }
                }
            }

            if (this.settings.showDayNamesHeader) {
                var title = document.createElement("div");
                title.className = "mfp-header-weekdays";
                header.appendChild(title);

                if (this._settings.weekHeaderStyle === VerticalHeaderStyle.Left) {
                    var d = document.createElement("div");
                    d.className = "mfp-header-weeknumbers";
                    d.innerHTML = "&nbsp;";
                    title.appendChild(d);
                }

                var days = document.createElement("div");
                days.className = "mfp-weekdays-wrap";
                title.appendChild(days);

                var day = 0;
                var dayName = null;
                for (var i = 0; i < this._daysPerWeek; i++) {
                    day = +this.formatInfo.firstDayOfWeek + i;
                    dayName = this.calendar.getDayName(day, this._settings.dayOfWeekFormat);
                    var d = document.createElement("div");
                    d.className = "mfp-weekday";
                    if (this.calendar.showTooltips) d.title = this.calendar.getDayName(day, DayOfWeekFormat.Full);
                    days.appendChild(d);
                    if (dayName !== "") d.innerHTML = dayName;else d.innerHTML = "&nbsp;";
                }

                if (this.settings.weekHeaderStyle === VerticalHeaderStyle.Right) {
                    var d = document.createElement("div");
                    d.className = "mfp-header-weeknumbers";
                    d.innerHTML = "&nbsp;";
                    title.appendChild(d);
                }
            }
            return result;
        }
    }, {
        key: 'drawHeaderButtons',
        value: function drawHeaderButtons(parent) {
            var b = document.createElement("a");
            var s = document.createElement("span");
            b.appendChild(s);
            if (this.calendar.showTooltips) {
                b.title = DateTime.addYears(this._date, -1).toString(this.formatInfo.dateFormats.yearMonth, this.formatInfo);
            }
            parent.appendChild(b);
            DomUtils.addCssClass(b, "mfp-button");
            DomUtils.addCssClass(b, "mfp-button-prev-2");

            b = document.createElement("a");
            s = document.createElement("span");
            b.appendChild(s);
            if (this.calendar.showTooltips) {
                b.title = DateTime.addMonths(this._date, -1).toString(this.formatInfo.dateFormats.yearMonth, this.formatInfo);
            }
            parent.appendChild(b);
            DomUtils.addCssClass(b, "mfp-button");
            DomUtils.addCssClass(b, "mfp-button-prev");

            b = document.createElement("a");
            s = document.createElement("span");
            b.appendChild(s);
            if (this.calendar.showTooltips) {
                b.title = DateTime.addMonths(this._date, 1).toString(this.formatInfo.dateFormats.yearMonth, this.formatInfo);
            }
            parent.appendChild(b);
            DomUtils.addCssClass(b, "mfp-button");
            DomUtils.addCssClass(b, "mfp-button-next");

            b = document.createElement("a");
            s = document.createElement("span");
            b.appendChild(s);
            if (this.calendar.showTooltips) {
                b.title = DateTime.addYears(this._date, 1).toString(this.formatInfo.dateFormats.yearMonth, this.formatInfo);
            }
            parent.appendChild(b);
            DomUtils.addCssClass(b, "mfp-button");
            DomUtils.addCssClass(b, "mfp-button-next-2");
        }
    }, {
        key: 'drawContent',
        value: function drawContent() {

            var result = null;

            var content = document.createElement("div");
            content.className = "mfp-content";
            result = content;

            // left weekNumbersHeader
            if (this._settings.weekHeaderStyle === VerticalHeaderStyle.Left) {
                var d = document.createElement("div");
                d.className = "mfp-header-weeknumbers";
                content.appendChild(d);

                var t = this.drawWeekNumbersHeader();
                d.appendChild(t);
            }

            var d = document.createElement("div");
            d.className = "mfp-wrap";
            content.appendChild(d);

            var pointDate = this._startTime;
            var weekClass = "";
            for (var row = 0; row < this._rowsCount; row++) {
                weekClass = "mfp-week";
                // if (row === 0)
                //     weekClass += " mfp-top-row";
                // if (row === this._rowsCount - 1)
                //     weekClass += " mfp-bottom-row";

                var r = document.createElement("div");
                r.className = weekClass;
                d.appendChild(r);

                var t = this.drawBackgroundTable(pointDate, row);
                r.appendChild(t);

                var t = this.drawItemTable(pointDate, row);
                r.appendChild(t);

                pointDate = DateTime.addDays(pointDate, this._daysPerWeek);
            }

            // right weekNumberHeader
            if (this._settings.weekHeaderStyle === VerticalHeaderStyle.Right) {
                var d = document.createElement("div");
                d.className = "mfp-header-weeknumbers";
                content.appendChild(d);

                var t = this.drawWeekNumbersHeader();
                d.appendChild(t);
            }

            return result;
        }
    }, {
        key: 'drawWeekNumbersHeader',
        value: function drawWeekNumbersHeader() {
            var result = null;

            var t = document.createElement("table");
            t.className = "mfp-weeknumbers";
            t.cellSpacing = 0;
            t.cellPadding = 0;
            result = t;

            var date = DateTime.minValue;
            for (var row = 0; row < this._rows.count(); row++) {
                date = DateTime.addDays(this.startTime, row * this._daysPerWeek).date;
                var tr = document.createElement("tr");
                t.appendChild(tr);

                var td = document.createElement("td");
                tr.appendChild(td);
                td.innerHTML = this.calendar.getWeekOfYear(DateTime.addDays(date, 6));
            }

            return result;
        }
    }, {
        key: 'drawBackgroundTable',
        value: function drawBackgroundTable(startDate, row) {
            var result = null;

            var dayClass = "";
            var isMonthDay = false;
            var isPaddingDay = false;
            var dateMonth = DateTime.getMonth(this._date);

            var r = document.createElement("div");
            r.className = "mfp-bg-row";
            result = r;

            for (var day = 0; day < this._daysPerWeek; day++) {
                isMonthDay = false;
                isPaddingDay = false;
                dayClass = "mfp-bg-cell";
                var startDateMonth = DateTime.getMonth(startDate);
                if (startDateMonth !== dateMonth) {
                    if (startDate < this._date && this._showLeadingDays) {
                        dayClass += " mfp-padding-cell";
                        isPaddingDay = true;
                    }

                    if (startDate > this._date && this._showTrailingDays) {
                        dayClass += " mfp-padding-cell";
                        isPaddingDay = true;
                    }
                } else {
                    isMonthDay = true;
                }
                if (!isMonthDay && !isPaddingDay) dayClass += " mfp-empty-cell";

                var dayOfWeek = startDate.dayOfWeek;
                if (dayOfWeek === DayOfWeek.Saturday || dayOfWeek === DayOfWeek.Sunday) dayClass += " mfp-weekend-cell";

                var d = this.drawMonthDay(startDate, !(isMonthDay || isPaddingDay), isMonthDay, isPaddingDay);
                d.className = dayClass;
                r.appendChild(d);

                startDate = DateTime.addDays(startDate, 1);
            }
            return result;
        }
    }, {
        key: 'drawMonthDay',
        value: function drawMonthDay(day, isEmptyCell, isMonthDay, isPaddingDay) {
            var result = null;

            var t = document.createElement("div");
            result = t;

            var title = document.createElement("div");
            title.className = "mfp-bg-cell-header";
            t.appendChild(title);

            if (!isEmptyCell) {
                var dayOfMonth = DateTime.getDayOfMonth(day);
                var month = DateTime.getMonth(day);
                if (month === 1 && dayOfMonth === 1) {
                    title.innerHTML = day.toString(this._settings.firstDayOfYearFormat, this.formatInfo);
                } else if (month !== 1 && dayOfMonth === 1) {
                    title.innerHTML = day.toString(this._settings.firstDayOfMonthFormat, this.formatInfo);
                } else {
                    title.innerHTML = day.toString(this._settings.generalFormat, this.formatInfo);
                }
            } else title.innerHTML = "&nbsp;";

            return result;
        }
    }, {
        key: 'drawItemTable',
        value: function drawItemTable(startDate, row) {
            var result = null;

            var isMonthDay = false;
            var isPaddingDay = false;
            var pointDate = startDate;

            var t = document.createElement("table");
            t.className = "mfp-item-table";
            t.cellSpacing = 0;
            t.cellPadding = 0;
            result = t;

            var tb = document.createElement("tbody");
            t.appendChild(tb);

            var tr = document.createElement("tr");
            tb.appendChild(tr);

            for (var day = 0; day < this._daysPerWeek; day++) {
                isMonthDay = false;
                isPaddingDay = false;
                if (pointDate.getMonth() !== this._date.getMonth()) {
                    if (pointDate.getMonth() < this._date.getMonth() && this._showLeadingDays) isPaddingDay = true;
                    if (pointDate.getMonth() > this._date.getMonth() && this._showTrailingDays) isPaddingDay = true;
                } else {
                    isMonthDay = true;
                }

                var td = document.createElement("td");
                if (this.calendar.showTooltips && (isMonthDay || isPaddingDay)) td.title = pointDate.toString(this.formatInfo.dateFormats.longDate, this.formatInfo);
                tr.appendChild(td);

                var d = document.createElement("div");
                d.innerHTML = "&nbsp;";
                d.className = "mfp-cell-header";
                td.appendChild(d);

                pointDate = DateTime.addDays(pointDate, 1)._date;
            }

            return result;
        }
    }, {
        key: 'cells',
        get: function get$$1() {
            var result = new List();
            this._rows.forEach(function (t) {
                result.addRange(t.cells.items());
            }, this);
            return result;
        }
    }, {
        key: 'cssClass',
        get: function get$$1() {
            return "mfp-month-view";
        }
    }]);
    return MonthCell;
}(Cell);

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

var MonthRangeCell = function (_Cell) {
    inherits(MonthRangeCell, _Cell);

    function MonthRangeCell(calendar) {
        classCallCheck(this, MonthRangeCell);

        var _this = possibleConstructorReturn(this, (MonthRangeCell.__proto__ || Object.getPrototypeOf(MonthRangeCell)).call(this, calendar));

        _this.unit = TimeUnit.Day;

        _this.initVars();
        return _this;
    }

    /* Dom */


    createClass(MonthRangeCell, [{
        key: 'getContent',
        value: function getContent() {
            if (!this.Dom.content) {
                this.Dom.content = this.getElement().querySelector("div.mfp-content-wrap");
            }
            return this.Dom.content;
        }
    }, {
        key: 'getRows',
        value: function getRows() {
            if (!this.Dom.rows) {
                this.Dom.rows = this.calendar.getElement().querySelectorAll('div.mfp-month-view');
            }
            return this.Dom.rows;
        }
    }, {
        key: 'getBgCells',
        value: function getBgCells() {
            if (!this.Dom.bgCells) {
                this.Dom.bgCells = this.calendar.getElement().querySelectorAll('div.mfp-bg-cell');
            }
            return this.Dom.bgCells;
        }
    }, {
        key: 'initVars',
        value: function initVars() {
            var date = this.calendar.date.date;
            this._date = this.calendar.getMonthFirstDate(date);

            this._settings = this.calendar.monthRangeSettings;
            this._isHeaderVisible = false;
            var months = this._settings.numberOfMonths;
            this._rows = this._settings.visibleRows;

            this._startTime = this.calendar.getMonthFirstVisibleDate(this._date);
            this._endTime = this._date.clone().addMonths(this._settings.numberOfMonths).addDays(-1);
            var _monthDate = this._date.clone();
            this._rowHeight = 0;

            this._cols = months > this._settings.monthsPerRow ? this._settings.monthsPerRow : months;
            if (months > this._settings.monthsPerRow) this._realRows = months % this._settings.monthsPerRow != 0 ? Math.floor(months / this._settings.monthsPerRow) + 1 : Math.floor(months / this._settings.monthsPerRow);else this._realRows = 1;

            var firstLast = 0;

            this.monthCells = new List();

            var maxWeekCount = this.getMaxWeekCount(_monthDate.clone());

            for (var i = 0; i < months; i++) {
                if (i == 0) firstLast = -1;else if (i == months - 1) firstLast = 1;else firstLast = 0;

                if (months == 1) firstLast = 2;

                var cell = new MonthCell(this.calendar, this, _monthDate, i, firstLast, maxWeekCount);
                this.monthCells.add(cell);
                _monthDate = _monthDate.addMonths(1);
            }

            this.rowCellsCount = 7;

            this.createCells();
        }
    }, {
        key: 'getMaxWeekCount',
        value: function getMaxWeekCount(date) {
            var maxWeekCount = 0;
            var weekCount = 6;
            var months = this._settings.numberOfMonths;
            var settings = this.calendar.monthSettings;

            for (var i = 0; i < months; i++) {
                var realShowLeadingDays = settings.showPaddingDays && (i == 0 || months == 1);

                var t = DateTime.getDaysInMonth(date);

                var d = DateTime.addDays(date, t);
                var firstVisibleDate = this.calendar.getMonthFirstVisibleDate(date);
                while (d.dayOfWeek != +this.formatInfo.firstDayOfWeek) {
                    d = DateTime.addDays(d, 1);
                }weekCount = Math.round(TimeSpan.fromMilliseconds(d - firstVisibleDate).days / 7);

                if (settings.leadingWeekCount > 0 && realShowLeadingDays) firstVisibleDate = DateTime.addDays(firstVisibleDate, -1 * settings.leadingWeekCount * 7);

                if (weekCount > maxWeekCount) maxWeekCount = weekCount;
                date = date.addMonths(1);
            }
            return maxWeekCount;
        }
    }, {
        key: 'createCells',
        value: function createCells() {
            var g = 0;
            for (var i = 0; i < this.monthCells.count(); i++) {
                var m = this.monthCells.items()[i];
                for (var k = 0; k < m.cells.count(); k++) {
                    var c = m.cells.items()[k];
                    c.monthCellIndex = i;
                    c.globalIndex = g;
                    g++;
                }
            }

            this.itemsStartTime = this.monthCells.items()[0].itemsStartTime;
            this.itemsEndTime = this.monthCells.items()[this.monthCells.count() - 1].itemsEndTime;
        }
    }, {
        key: 'detach',
        value: function detach() {
            for (var i = 0; i < this.monthCells.count(); i++) {
                this.monthCells.items()[i].detach();
            }

            var buttons = this.getHeader().querySelectorAll("a.mfp-button");
            for (var i = 0; i < buttons.length; i++) {
                buttons[i].removeEventListener("click", this.buttonClickHandler);
            }
            this.getHeader().removeEventListener("click", this.headerClickHandler);
        }
    }, {
        key: 'attach',
        value: function attach() {
            var h = DomUtils.getBounds(this.getContent()).height;

            for (var i = 0; i < this.monthCells.count(); i++) {
                this.monthCells.items()[i].attach();
            }

            this.clear();
            this.init();

            this.getHeader().addEventListener("click", this.headerClickHandler);

            var buttons = this.getHeader().querySelectorAll("a.mfp-button");
            for (var i = 0; i < buttons.length; i++) {
                buttons[i].addEventListener("click", this.buttonClickHandler);
            }
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'clear',
        value: function clear() {
            DomUtils.removeNodes(this.getContent().querySelectorAll('.mfp-item-wrap'));
            DomUtils.removeNodes(this.getContent().querySelectorAll('.mfp-item-row'));
        }
    }, {
        key: 'init',
        value: function init() {
            if (!this.cellWidth) this.getDimensions();

            this.getAllItems();

            this.itemsToPut = this.items.slice(0);

            for (var i = 0, l = this.monthCells.count(); i < l; i++) {
                for (var k = 0, m = this.monthCells.items()[i]._rows.count(); k < m; k++) {
                    this.createItemsTable(i, this.monthCells.items()[i]._rows.items()[k]);
                }
            }
            for (var i = 0; i < this.itemsToPut.length; i++) {
                var item = this.items[this.items.indexOf(this.itemsToPut[i])];
                item.cell = null;
                item.row = -1;
                item.hidden = true;
            }

            this.placeItems();

            if (this.calendar.itemSettings.showItems) {
                for (var i = 0, l = this.monthCells.count(); i < l; i++) {
                    this.monthCells.items()[i].getCues();
                    this.monthCells.items()[i].createCues();
                }
            }
        }
    }, {
        key: 'createItemsTable',
        value: function createItemsTable(monthCell, row) {
            var items = this.getItemsInRow(monthCell, row);

            for (var i = 0, l = this.itemsCount; i < l; i++) {
                var trow = document.createElement('tr');
                trow.className = 'mfp-item-row';
                var day = 0;

                while (day < this.rowCellsCount) {
                    var items = this.getItemsInCell(row.cells.items()[day], this.itemsToPut);
                    var item = null;
                    if (items.length > 0) item = items[0];
                    if (item != null) {
                        var tcell = document.createElement('td');
                        tcell.className = 'mfp-item-cell';
                        tcell.colSpan = item.cellsLength;
                        tcell.style.paddingLeft = this.padding + 'px';
                        tcell.style.paddingRight = this.padding + 'px';
                        day += item.cellsLength - 1;
                        item.cell = tcell;
                        item.row = i;
                        this.itemsToPut.splice(this.itemsToPut.indexOf(item), 1);
                    } else {
                        var tcell = document.createElement('td');
                        tcell.className = 'mfp-item-cell';
                    }
                    trow.appendChild(tcell);
                    day += 1;
                }

                row.itemTable.appendChild(trow);
            }
        }
    }, {
        key: 'updateItem',
        value: function updateItem(appointment, addToItems) {
            var item = appointment.item;
            //invisible items
            if (!item.visible) {
                return appointment;
            }
            var appointment = appointment;

            var parts = [];
            var removed = [];
            if (!this.hasVisibleParts(item)) {
                removed.push(appointment);
            } else if (this.isComposite(item)) {
                var monthCells = this.getTimeMonthCells(item.startTime, item.endTime);
                for (var i = monthCells.start.index, l = monthCells.end.index; i <= l; i++) {

                    var stm = DateTime.maxDate(item.startTime, this.monthCells.items()[i].itemsStartTime, false);
                    var etm = DateTime.minDate(item.endTime, this.monthCells.items()[i].itemsEndTime, true);

                    var rows = this.getTimeRows(this.monthCells.items()[i], stm, etm);

                    for (var j = rows.start, m = rows.end; j <= m; j++) {
                        var st = DateTime.maxDate(item.startTime, this.rows.items()[j].itemsStartTime, false);
                        var et = DateTime.minDate(item.endTime, this.rows.items()[j].itemsEndTime, true);
                        if (st.equals(et)) continue;
                        var partIndex = 0;

                        // todo : workaroud till DateTime is fixed
                        if (st.compareTo(item.startTime) == 1) // right arrow
                            partIndex = 1;
                        if (et.compareTo(item.endTime) == -1) // left arrow
                            partIndex = -1;
                        if (st.compareTo(item.startTime) == 1 && et.compareTo(item.endTime) == -1) // both arrows
                            partIndex = 0;

                        var scell = this.getTimeCell(st, false);
                        var lcell = this.getTimeCell(et, true);

                        var partData = {
                            prototype: appointment,
                            type: 'part',
                            cellIndex: scell.index,
                            cellsLength: lcell.index - scell.index + 1,
                            colIndex: j,
                            isPartial: true,
                            partIndex: partIndex,
                            lastCellIndex: lcell.index,
                            startCellIndex: scell.index,
                            monthCellIndex: scell.monthCellIndex
                        };
                        var part = new Appointment(partData);
                        part.composite = true;
                        parts.push(part);

                        removed.push(appointment);
                    }
                }
            } else {
                var cell = this.getTimeCell(item.startTime, false);
                if (item.startTime._date.valueOf() == item.endTime._date.valueOf()) {
                    var lcell = cell;
                } else {
                    var lcell = this.getTimeCell(item.endTime, true);
                }
                if (lcell.globalIndex < cell.globalIndex) {
                    lcell = cell;
                }

                appointment.monthCellIndex = cell.monthCellIndex;

                appointment.lastCellIndex = lcell.index;
                appointment.startCellIndex = cell.index;
                appointment.cellsLength = lcell.index - cell.index + 1;
                if (appointment.cellsLength < 1) {
                    appointment.cellsLength = 1;
                }
                appointment.cellIndex = cell.index;
                appointment.colIndex = cell.rowIndex;
                appointment.updateVisual();
            }

            for (var i = 0; i < removed.length; i++) {
                this.removeAppointment(removed[i]);
            }

            if (addToItems != false) this.items = this.items.concat(parts);

            for (var i = 0; i < parts.length; i++) {
                parts[i].updateVisual();
            }

            //return value is only used for recurrent composite items
            if (parts.length > 0) return parts;
            parts.push(appointment);
            return parts;
        }
    }, {
        key: 'getItemsInRow',
        value: function getItemsInRow(monthCell, row) {
            var items = [];
            for (var i = 0, l = this.itemsToPut.length; i < l; i++) {
                if (this.itemsToPut[i].monthCellIndex == monthCell) {
                    if (this.itemsToPut[i].startCellIndex >= row.index * 7 && this.itemsToPut[i].startCellIndex < row.index * 7 + 7) items.push(this.itemsToPut[i]);
                }
            }
            return items;
        }

        /**
           * For internal use only.
           * @private
           */

    }, {
        key: 'isComposite',
        value: function isComposite(item) {
            if (item.startTime._date.valueOf() == item.endTime._date.valueOf()) {
                return false;
            }
            var fcell = this.getTimeCell(item.startTime, false);
            var ecell = this.getTimeCell(item.endTime, true);

            if (fcell == null || ecell == null) return true;
            if (ecell.globalIndex < fcell.globalIndex) {
                ecell = fcell;
                return false;
            }
            if (fcell.monthCellIndex != ecell.monthCellIndex) return true;
            if (fcell.startTime._date.valueOf() < this.rows.items()[0].itemsStartTime._date.valueOf()) return true;
            if (ecell.endTime._date.valueOf() > this.rows.items()[this.rows.count() - 1].itemsEndTime._date.valueOf()) return true;
            if (fcell.rowIndex == ecell.rowIndex) return false;
            return true;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'hasVisibleParts',
        value: function hasVisibleParts(item) {
            if (item.startTime._date.valueOf() >= this.rows.items()[0].itemsStartTime._date.valueOf() && item.startTime._date.valueOf() < this.rows.items()[this.rows.count() - 1].itemsEndTime._date.valueOf()) return true;
            if (item.endTime._date.valueOf() > this.rows.items()[0].itemsStartTime._date.valueOf() && item.endTime._date.valueOf() < this.rows.items()[this.rows.count() - 1].itemsEndTime._date.valueOf()) return true;
            if (item.startTime._date.valueOf() <= this.rows.items()[0].itemsStartTime._date.valueOf() && item.endTime._date.valueOf() >= this.rows.items()[0].itemsEndTime._date.valueOf()) return true;
            return false;
        }
    }, {
        key: 'getItemsInCell',
        value: function getItemsInCell(cell, items) {
            var result = [];
            for (var i = 0, l = items.length; i < l; i++) {
                if (items[i].monthCellIndex == cell.monthCellIndex) {
                    if (items[i].startCellIndex == cell.index) result.push(items[i]);
                }
            }
            return result;
        }

        /**
              * Gets the cell of the month that corresponds to the specified time.
              * @param {Object} [time] The time to check.
              * @param {Boolean} [isEndTime] true if the cell of the first interval is returned, when the time is the border between two intervals;
              false if the second interval is returned.
              * @returns {Object} The month cell.
              */

    }, {
        key: 'getMonthTimeCell',
        value: function getMonthTimeCell(time, isEndTime) {
            var cell = null;
            for (var i = 0, l = this.monthCells.count(); i < l; i++) {

                if (time._date.valueOf() >= this.monthCells.items()[i].itemsStartTime._date.valueOf() && time._date.valueOf() <= this.monthCells.items()[i].itemsEndTime._date.valueOf()) {
                    cell = this.monthCells.items()[i];
                }
                if (isEndTime && this.monthCells.items()[i].itemsStartTime._date.valueOf() == time._date.valueOf() && i > 0) {
                    cell = this.monthCells.items()[i - 1];
                }
                if (cell == null && (i == 0 || i == this.monthCells.count() - 1)) {
                    if (time._date.valueOf() >= this.monthCells.items()[i].startTime._date.valueOf() && time._date.valueOf() <= this.monthCells.items()[i].endTime._date.valueOf()) {
                        cell = this.monthCells.items()[i];
                    }

                    if (isEndTime && this.monthCells.items()[i].startTime._date.valueOf() == time._date.valueOf() && i > 0) {
                        cell = this.monthCells.items()[i - 1];
                    }
                }
            }
            return cell;
        }

        /**
              * Gets the first and last month cell that correspond to the given period.
              * @param {Object} [start] The start of the period.
              * @param {Object} [end] The end of the period.
              * @returns {Object} An object that contains the start and end month cells.
              */

    }, {
        key: 'getTimeMonthCells',
        value: function getTimeMonthCells(start, end) {
            var fmonthCell = this.getMonthTimeCell(start, false);
            var emonthCell = this.getMonthTimeCell(end, true);
            if (fmonthCell == null) fmonthCell = this.monthCells.items()[0];
            if (emonthCell == null) emonthCell = this.monthCells.items()[this.monthCells.count() - 1];
            return { start: fmonthCell, end: emonthCell };
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getTimeRows',
        value: function getTimeRows(monthCell, start, end) {
            var fcell = this.getTimeCell(start, false);
            var ecell = this.getTimeCell(end, true);

            var startRow = fcell == null ? monthCell.index * (monthCell._rows.count() + 1) : fcell.rowIndex + monthCell.index * monthCell._rows.count();
            var endRow = ecell == null ? monthCell.index * (monthCell._rows.count() + 1) : ecell.rowIndex + monthCell.index * monthCell._rows.count();
            return { start: startRow, end: endRow };
        }

        /**
        * Gets the cell that corresponds to the specified time.
        * @param {Object} [time] The time to check.
        * @param {Boolean} [isEndTime] true if the cell of the first interval is returned, when the time is the border between two intervals;
        false if the second interval is returned.
        * @param {Object} The month to look into.
        * @returns {Object} The daily cell that contains the given time.
        */

    }, {
        key: 'getTimeCell',
        value: function getTimeCell(time, isEndTime, cell) {
            var t = DateTime.setTimeOfDay(this.startTime, time);

            if (cell == undefined || typeof cell == "number") {
                var monthCell = this.getMonthTimeCell(time, isEndTime);
                if (monthCell == null) return null;
            } else {
                var monthCell = cell;
            }
            var i = DateTime.daysBetween(monthCell.startTime, t);

            if (i > monthCell.cells.count()) return null;
            if (i == monthCell.cells.count()) {
                if (isEndTime && time.equals(monthCell.cells.items()[i - 1].endTime)) return monthCell.cells.items()[i - 1];else return null;
            }
            if (isEndTime && time.equals(monthCell.cells.items()[i].startTime) && i > 0) i -= 1;
            return monthCell.cells.items()[i];
        }
    }, {
        key: 'getTimeCells',
        value: function getTimeCells(startTime, endTime, isEndTime) {
            var startCell = null;
            var endCell = null;
            var viewStart = this.monthCells.items()[0].startTime.valueOf();
            var viewEnd = this.monthCells.items()[this.monthCells.count() - 1].endTime.valueOf();

            if (startTime.valueOf() < viewStart) {
                startCell = this.cells.items()[0];
            } else if (startTime.valueOf() > viewEnd) {
                return [];
            } else {
                //start month cell
                var fmc = this.getMonthTimeCell(startTime, false);
                if (fmc) {
                    startCell = this.getTimeCell(startTime, false, fmc);
                }
            }

            if (endTime !== null && typeof endTime !== "undefined" && typeof endTime._date !== "undefined") {
                if (endTime.valueOf() > viewEnd) {
                    endCell = this.cells.items()[this.cells.count() - 1];
                } else if (endTime.valueOf() < viewStart) {
                    return [];
                } else {
                    //end month cell
                    var lmc = this.getMonthTimeCell(endTime, isEndTime);
                    if (lmc) {
                        endCell = this.getTimeCell(endTime, isEndTime, lmc);
                    }
                }
            } else {
                endCell = startCell;
            }

            if (startCell && endCell) {
                return this.cells.items().slice(startCell.globalIndex, endCell.globalIndex + 1);
            }
            return [];
        }

        /* Interactions */

    }, {
        key: 'endSelection',
        value: function endSelection(e, start, end) {
            var st = this.cells.items()[start].startTime;
            var et = this.cells.items()[end].endTime;

            var item = new DummyItem(st, et, '', true, this.calendar);
            get(MonthRangeCell.prototype.__proto__ || Object.getPrototypeOf(MonthRangeCell.prototype), 'endSelection', this).call(this, item);
        }
    }, {
        key: 'selectItem',
        value: function selectItem(e, data) {
            get(MonthRangeCell.prototype.__proto__ || Object.getPrototypeOf(MonthRangeCell.prototype), 'selectItem', this).call(this, e, data);

            // appointment sends local index, so these have to be adjusted.
            this.itemData.startCellIndex = this.getTimeCell(this.itemData.item.startTime, false).globalIndex;
        }
    }, {
        key: 'endItemDrag',
        value: function endItemDrag(e) {
            // this.itemData.appointment.element.style.cursor = 'pointer';
            //  this.getContent().style.cursor = 'default';
            //this._dragging = false;
            var cell = this.getCellAt(e.clientX, e.clientY);
            var startCell = this.cells.items()[this.itemData.startCellIndex];
            if (cell == null) cell = startCell;

            var cellIndex = this.cells.items().indexOf(cell);
            if (cell.monthCellIndex == 0) {
                if (cellIndex < this.firstVisibleCellOfMonth(cellIndex)) {
                    cell = this.cells[this.firstVisibleCellOfMonth(cellIndex)];
                }
            }

            if (cell.monthCellIndex == this.monthCells.count() - 1) {
                if (cellIndex > this.lastVisibleCellOfMonth(cellIndex)) {
                    cell = this.cells[this.lastVisibleCellOfMonth(cellIndex)];
                }
            }

            var item = this.itemData.item;
            var app = this.itemData.appointment;

            var startTime = DateTime.setTimeOfDay(item.startTime, cell.startTime);
            var endTime = app.getEndTime(startTime);

            get(MonthRangeCell.prototype.__proto__ || Object.getPrototypeOf(MonthRangeCell.prototype), 'endItemDrag', this).call(this, { startTime: startTime, endTime: endTime });
        }
    }, {
        key: 'endItemResize',
        value: function endItemResize(e) {
            var startCell = this.itemData.itemStartCell;
            var endCell = this.itemData.itemLastCell;

            var item = this.itemData.item;
            var app = this.itemData.appointment;

            if (startCell != null) var startTime = DateTime.setTimeOfDay(item.startTime, startCell.startTime);else var startTime = item.startTime;
            if (endCell != null) var endTime = endCell.endTime;else var endTime = item.endTime;

            get(MonthRangeCell.prototype.__proto__ || Object.getPrototypeOf(MonthRangeCell.prototype), 'endItemResize', this).call(this, { startTime: startTime, endTime: endTime });
        }
    }, {
        key: 'getDimensions',
        value: function getDimensions() {
            var getBounds = DomUtils.getBounds;
            this.monthRowHeight = getBounds(this.getRows()[0]).height;
            this.calculatedMonthCellWidth = getBounds(this.getRows()[0]).width;

            var c = this.monthCells.items()[0];
            c.getDimensions();
            this.cellWidth = c.cellWidth;
            this.calculatedCellWidth = c.calculatedCellWidth;
            this.weekRowHeight = c.rowHeight;
            this.headerHeight = c.headerHeight;
            this.offsetLeft = 0;
            this.offsetLeft += c.offsetLeft;
            this.dragOffsetLeft = getBounds(this.calendar.getElement()).x;
            this.dragWidth = c.dragWidth;

            this.itemsCount = c.itemsCount;
        }

        /**
          * For internal use only.
          * @private
          */

    }, {
        key: 'getCellIndexAt',
        value: function getCellIndexAt(x, y) {
            if (!this.cellWidth) this.getDimensions();

            var cursor = DomUtils.getCursorPosition({ clientX: x, clientY: y }, this.getContent(), this.getScroller());
            var monthCell = this.getMonthCellAt(cursor.x, cursor.y);
            if (monthCell) {
                var index = monthCell.getCellIndexAt(x, y);
                var globalIndex = index + monthCell.index * monthCell.cells.count();
                if (this.cells.items()[globalIndex]) return globalIndex;
            }
            return null;
        }

        /**
        * Gets the cell that holds the specified point.
        * @param {Number} [x] The X-coordinate of the point.
        * @param {Number} [y] The Y-coordinate of the point.
        * @returns {Object} The cell that holds the point.
        */

    }, {
        key: 'getCellAt',
        value: function getCellAt(x, y) {
            var i = this.getCellIndexAt(x, y);
            return this.cells.items()[i];
        }

        /**
        * Gets the month cell with the given coordinates.
        * @param {Number} [x] The X-coordinate of the point.
        * @param {Number} [y] The Y-coordinate of the point.
        * @returns {Object} The month cell.
        */

    }, {
        key: 'getMonthCellAt',
        value: function getMonthCellAt(x, y) {
            var r = Math.floor(y / this.monthRowHeight);
            var c = Math.floor(x / this.calculatedMonthCellWidth);
            return this.monthCells.items()[r * this._settings.monthsPerRow + c];
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'firstVisibleCellOfMonth',
        value: function firstVisibleCellOfMonth(index) {
            if (this.cells.items()[index] == null) return null;
            var monthCell = this.monthCells.items()[this.cells.items()[index].monthCellIndex];
            var cell = monthCell.cells.items()[monthCell.firstVisibleCell];
            return this.cells.items().indexOf(cell);
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'lastVisibleCellOfMonth',
        value: function lastVisibleCellOfMonth(index) {
            if (this.cells.items()[index] == null) return null;
            var monthCell = this.monthCells.items()[this.cells.items()[index].monthCellIndex];
            var cell = monthCell.cells.items()[monthCell.lastVisibleCell];
            return this.cells.items().indexOf(cell);
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'lastMonthVisibleCell',
        value: function lastMonthVisibleCell(index) {
            var month = this.monthCells.items()[this.cells.items()[index].monthCellIndex - 1];
            var cell = month.cells.items()[month.lastVisibleCell];
            if (cell != null) return this.cells.items().indexOf(cell);
        }
    }, {
        key: 'isValidCell',
        value: function isValidCell(index) {
            if (index == null) {
                return false;
            }

            if (index < this.firstVisibleCellOfMonth(index) || index > this.lastVisibleCellOfMonth(index)) {
                return false;
            }
            return true;
        }
    }, {
        key: 'getNextVisibleCell',
        value: function getNextVisibleCell(index, count) {
            var len = this.visibleCells.length;
            var cell = this.visibleCells.indexOf(index) + count;
            if (cell > len - 1) {
                cell = len - 1;
            }
            return this.visibleCells[cell];
        }
    }, {
        key: 'getIndexCell',
        value: function getIndexCell(index, findex) {
            var lv = this.lastVisibleCellOfMonth(findex);
            if (lv < index) return this.getNextVisibleCell(lv, index - lv + 1);
            return index;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getFirstRowCell',
        value: function getFirstRowCell(row) {
            var cell = this.rows.items()[row].cells.items()[0];
            var mc = this.monthCells.items()[this.rows.items()[row].monthCellIndex];
            if (cell.index > mc.lastVisibleCell) {
                return null;
            }
            if (cell.index > mc.firstVisibleCell) {
                return cell;
            } else {
                return mc.cells.items()[mc.firstVisibleCell];
            }
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getLastRowCell',
        value: function getLastRowCell(row) {
            var cell = this.rows.items()[row].cells.items()[this.rows.items()[row].cells.count() - 1];
            var mc = this.monthCells.items()[this.rows.items()[row].monthCellIndex];

            if (cell.index < mc.lastVisibleCell) {
                return cell;
            } else {
                return mc.cells.items()[mc.lastVisibleCell];
            }
        }
    }, {
        key: 'getAllItemsInCell',
        value: function getAllItemsInCell(cell) {
            var result = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].monthCellIndex == cell.monthCellIndex) {
                    if (this.items[i].startCellIndex <= cell.index && this.items[i].lastCellIndex >= cell.index) {
                        if (this.items[i].row < this.itemsCount || this.items[i].row == -1) {
                            result.push(this.items[i]);
                        }
                    }
                }
            }
            return result;
        }
    }, {
        key: 'onThemeChanged',
        value: function onThemeChanged(oldValue, newValue) {
            var rows = this.getRows();
            for (var i = 0; i < rows.length; i++) {
                DomUtils.removeCssClass(rows[i], oldValue);
                DomUtils.addCssClass(rows[i], newValue);
            }
        }

        /*Rendering*/

    }, {
        key: 'drawHeader',
        value: function drawHeader() {
            var result = null;

            var header = document.createElement("div");
            header.className = "mfp-header";
            result = header;

            if (this.settings.headerStyle != MainHeaderStyle.None) {

                var title = document.createElement("div");
                title.className = "mfp-title";
                header.appendChild(title);

                var a = document.createElement("a");
                a.className = "mfp-link";
                title.appendChild(a);

                if ((this._settings.headerStyle & MainHeaderStyle.Title) == MainHeaderStyle.Title) {
                    a.innerHTML = this._date.toString(this._settings.titleFormat, this.formatInfo).trim() + this._settings.titleSeparator + this._endTime.toString(this._settings.titleFormat, this.formatInfo).trim();
                } else a.innerHTML = "&nbsp;";

                if ((this._settings.headerStyle & MainHeaderStyle.Buttons) == MainHeaderStyle.Buttons) {
                    var b = this.drawHeaderButtons(title);
                }
            }

            return result;
        }
    }, {
        key: 'drawHeaderButtons',
        value: function drawHeaderButtons(parent) {
            var b = document.createElement("a");
            var s = document.createElement("span");
            b.appendChild(s);
            parent.appendChild(b);
            DomUtils.addCssClass(b, "mfp-button");
            DomUtils.addCssClass(b, "mfp-button-prev-2");

            if (this.calendar.showTooltips) {
                b.title = DateTime.addYears(this._date, -1).toString(this.formatInfo.dateFormats.yearMonth, this.formatInfo);
            }

            b = document.createElement("a");
            var s = document.createElement("span");
            b.appendChild(s);
            parent.appendChild(b);
            DomUtils.addCssClass(b, "mfp-button");
            DomUtils.addCssClass(b, "mfp-button-next-2");

            if (this.calendar.showTooltips) {
                b.title = DateTime.addYears(this._date, 1).toString(this.formatInfo.dateFormats.yearMonth, this.formatInfo);
            }
        }
    }, {
        key: 'drawContent',
        value: function drawContent() {
            var result = null;

            var content = document.createElement("div");
            content.className = "mfp-content-wrap";
            result = content;

            var t = document.createElement("div");
            t.className = "mfp-wrap";
            t.style.height = this._realRows / this._settings.visibleRows * 100 + "%";

            content.appendChild(t);

            var k = 0;
            for (var i = 0; i < this._realRows; i++) {

                var tr = document.createElement("div");
                tr.style.flex = "1 1 " + 100 / this._realRows + "%";
                t.appendChild(tr);

                for (var j = 0; j < this._cols; j++) {
                    if (k < this.monthCells.count()) {
                        var c = document.createElement("div");
                        c.className = "mfp-month-view";
                        if (this.calendar.theme) DomUtils.addCssClass(c, this.calendar.theme);

                        var d = this.monthCells.items()[k].draw();
                        c.appendChild(d);
                        tr.appendChild(c);
                        k += 1;
                    } else {
                        var c = document.createElement("div");
                        c.style.width = "100%";
                        c.innerHTML = "&nbsp;";
                        tr.appendChild(c);
                    }
                }
            }

            return result;
        }
    }, {
        key: 'rows',
        get: function get$$1() {
            var result = new List();
            this.monthCells.forEach(function (t) {
                result.addRange(t._rows.items());
            }, this);
            return result;
        }
    }, {
        key: 'cells',
        get: function get$$1() {
            var result = new List();
            this.monthCells.forEach(function (t) {
                result.addRange(t.cells.items());
            }, this);
            return result;
        }
    }, {
        key: 'visibleCells',
        get: function get$$1() {
            var result = [];
            this.cells.forEach(function (t) {
                if (t.visible) result.push(t.globalIndex);
            }, this);
            return result;
        }
    }, {
        key: 'cssClass',
        get: function get$$1() {
            return "mfp-month-range-view";
        }
    }]);
    return MonthRangeCell;
}(Cell);

/** 
* @namespace MindFusion.Scheduling
*/

var Unit = function () {
    function Unit(value, type) {
        classCallCheck(this, Unit);

        this.value = value;
        this.type = type;
    }

    createClass(Unit, [{
        key: "toString",
        value: function toString() {
            var t = "px";

            if (this.type === UnitType.Percent) t = "%";

            return (this.value || 0) + t;
        }
    }, {
        key: "isEmpty",
        get: function get$$1() {
            return this.value == null;
        }
    }], [{
        key: "pixel",
        value: function pixel(value) {
            return new Unit(value, UnitType.Pixel);
        }
    }, {
        key: "percentage",
        value: function percentage(value) {
            return new Unit(value, UnitType.Percent);
        }
    }, {
        key: "empty",
        value: function empty() {
            return new Unit(null, UnitType.Pixel);
        }
    }]);
    return Unit;
}();

var UnitType = {
    Pixel: 1,
    Percent: 2
};

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* For internal use only.
* @private
*/

var WeekRangeCell = function (_Cell) {
    inherits(WeekRangeCell, _Cell);

    function WeekRangeCell(calendar) {
        classCallCheck(this, WeekRangeCell);

        var _this = possibleConstructorReturn(this, (WeekRangeCell.__proto__ || Object.getPrototypeOf(WeekRangeCell)).call(this, calendar));

        _this.unit = TimeUnit.Day;

        _this._settings = _this.calendar.weekRangeSettings;

        _this.rows = new List();

        _this.initVars();
        return _this;
    }

    createClass(WeekRangeCell, [{
        key: 'initVars',
        value: function initVars() {
            this.rowCellsCount = this.settings.viewStyle === WeekRangeViewStyle.WeekPerRow ? 7 : 2;

            if (this.calendar.date > this.calendar.endDate) this.calendar.endDate = this.calendar.date;

            this._firstVisibleDate = this.calendar.getWeekFirstDate(this.calendar.date);
            this._endDate = this.calendar.endDate;

            // WeekPerRow
            if (this.settings.viewStyle === WeekRangeViewStyle.WeekPerRow) {
                this._daysPerWeek = 7;
                this._endDate = DateTime.addDays(this._endDate, 1);
                this._rows = this.settings.visibleRows;
            }
            // SingleWeek
            if (this.settings.viewStyle === WeekRangeViewStyle.SingleWeek) {
                this._daysPerWeek = 2;
                this._endDate = DateTime.addDays(this._endDate, 1);
                this._rows = 4;
            }

            var days = DateTime.daysBetween(this._firstVisibleDate, this._endDate);
            this._realRows = Math.ceil(days / this._daysPerWeek);

            var sb = this._firstVisibleDate.toString(this.settings.titleFormat, this.formatInfo);
            sb += this.settings.titleSeparator;
            sb += this._endDate.toString(this.settings.titleFormat, this.formatInfo);
            this._titleText = sb;

            this._rowHeight = new Unit(Math.round(100 / this._realRows, 2), UnitType.Percent).toString();

            this.startTime = this._firstVisibleDate;
            this.endTime = this._endDate;

            this.createRows();
        }
    }, {
        key: 'getDimensions',
        value: function getDimensions() {
            var getBounds = DomUtils.getBounds;

            this.cellWidth = this.cells.items()[0].title.offsetWidth;
            this.calculatedCellWidth = getBounds(this.getRows()[0]).width / this.rowCellsCount;

            this.weekRowHeight = getBounds(this.getRows()[0]).height;
            this.headerHeight = getBounds(DomUtils.firstRealChild(this.getBgCells()[0])).height;
            this.offsetLeft = this.dayBorderLeft || 0;

            this.dragOffsetLeft = getBounds(this.calendar.getElement()).x;
            this.dragWidth = this.cellWidth;

            this.itemsCount = Math.floor((this.weekRowHeight - this.headerHeight) / (this.calendar.itemSettings.size + this.calendar.itemSettings.spacing));
            if (this._settings.maxItems) this.itemsCount = Math.min(this._settings.maxItems, this.itemsCount);

            this.dragOffsetLeft = getBounds(this.calendar.getElement()).x;
            this.dragWidth = this.cellWidth;

            if (this.items) {
                this.getHiddenItems();

                if (this.calendar.itemSettings.showItems) {
                    this.getCues();
                    this.createCues();
                }
            }
        }

        /* Dom */

    }, {
        key: 'getRows',
        value: function getRows() {
            if (!this.Dom.rows) {
                this.Dom.rows = this.calendar.getElement().querySelectorAll('div.mfp-week');
            }
            return this.Dom.rows;
        }
    }, {
        key: 'getBgCells',
        value: function getBgCells() {
            if (!this.Dom.bgCells) {
                this.Dom.bgCells = this.calendar.getElement().querySelectorAll('div.mfp-bg-cell');
            }
            return this.Dom.bgCells;
        }

        /* endDom */

    }, {
        key: 'detach',
        value: function detach() {
            this.getHeader().removeEventListener("click", this.headerClickHandler);
        }
    }, {
        key: 'attach',
        value: function attach() {

            if (this._realRows > this._rows) {
                var h = Unit.percentage(Math.ceil(100 / this._rows) * this._realRows).toString();
                this.getContent().children[0].style.height = h;
                this.getContent().style.overflowY = "scroll";
            }

            var bgTables = this.getContent().querySelectorAll("div.mfp-bg-row");
            var itemTables = this.getContent().querySelectorAll("table.mfp-item-table");

            for (var i = 0; i < this.rows.count(); i++) {
                var row = this.rows.items()[i];
                row.bgTable = bgTables[i];
                row.itemTable = itemTables[i];

                var bgCells = row.bgTable.querySelectorAll("div.mfp-bg-cell");

                for (var k = 0, m = row.cells.count(); k < m; k++) {
                    var cell = row.cells.items()[k];
                    cell.bgCell = bgCells[k];
                    cell.title = bgCells[k] ? bgCells[k].childNodes[0] : undefined;
                }
            }

            this.clear();
            this.init();

            this.getHeader().addEventListener("click", this.headerClickHandler);
        }
    }, {
        key: 'updateItem',
        value: function updateItem(appointment, addToItems) {
            var item = appointment.item;
            //invisible items
            if (!item.visible) {
                return appointment;
            }

            var parts = [];
            var removed = [];
            if (!this.hasVisibleParts(item)) {
                removed.push(appointment);
            } else if (this.isComposite(item)) {
                var ist = DateTime.maxDate(item.startTime, this.itemsStartTime, false);
                var iet = DateTime.minDate(item.endTime, this.itemsEndTime, true);
                var rows = this.getTimeRows(ist, iet);

                for (var j = rows.start, m = rows.end; j <= m; j++) {
                    var st = DateTime.maxDate(item.startTime, this.rows.items()[j].itemsStartTime, false);
                    var et = DateTime.minDate(item.endTime, this.rows.items()[j].itemsEndTime, true);
                    if (st.equals(et)) continue;
                    var partIndex = 0;

                    if (st.compareTo(item.startTime) === 1) // right arrow
                        partIndex = 1;
                    if (et.compareTo(item.endTime) === -1) // left arrow
                        partIndex = -1;
                    if (st.compareTo(item.startTime) === 1 && et.compareTo(item.endTime) === -1) // both arrows
                        partIndex = 0;

                    var scell = this.getTimeCell(st, false);
                    var lcell = this.getTimeCell(et, true);
                    var partData = {
                        prototype: appointment,
                        type: 'part',
                        cellIndex: scell.index,
                        cellsLength: lcell.index - scell.index + 1,
                        colIndex: j,
                        isPartial: true,
                        partIndex: partIndex,
                        lastCellIndex: lcell.index,
                        startCellIndex: scell.index
                    };
                    var part = new Appointment(partData);
                    part.composite = true;
                    parts.push(part);
                    removed.push(appointment);
                }
            } else {
                var cell = this.getTimeCell(item.startTime, false);
                var lcell;
                if (item.startTime._date.valueOf() === item.endTime._date.valueOf()) {
                    lcell = cell;
                } else {
                    lcell = this.getTimeCell(item.endTime, true);
                }
                appointment.lastCellIndex = lcell.index;
                appointment.startCellIndex = cell.index;
                appointment.cellsLength = lcell.index - cell.index + 1;
                if (appointment.cellsLength < 1) {
                    appointment.cellsLength = 1;
                }
                appointment.cellIndex = cell.index;
                appointment.colIndex = cell.rowIndex;
                appointment.updateVisual();
            }

            //this._calendar._itemSelection.removeItem(appointment);
            for (var i = 0; i < removed.length; i++) {
                this.removeAppointment(removed[i]);
            }

            if (addToItems !== false) this.items = this.items.concat(parts);

            for (var i = 0; i < parts.length; i++) {
                parts[i].updateVisual();
            }

            //return value is only used for recurrent composite items
            if (parts.length > 0) return parts;
            parts.push(appointment);
            return parts;
        }
    }, {
        key: 'hasVisibleParts',
        value: function hasVisibleParts(item) {
            if (item.startTime._date.valueOf() >= this.rows.items()[0].itemsStartTime._date.valueOf() && item.startTime._date.valueOf() < this.rows.items()[this.rows.count() - 1].itemsEndTime._date.valueOf()) return true;
            if (item.endTime._date.valueOf() > this.rows.items()[0].itemsStartTime._date.valueOf() && item.endTime._date.valueOf() < this.rows.items()[this.rows.count() - 1].itemsEndTime._date.valueOf()) return true;
            if (item.startTime._date.valueOf() <= this.rows.items()[0].itemsStartTime._date.valueOf() && item.endTime._date.valueOf() >= this.rows.items()[0].itemsEndTime._date.valueOf()) return true;
            return false;
        }
    }, {
        key: 'isComposite',
        value: function isComposite(item) {
            if (item.startTime._date.valueOf() === item.endTime._date.valueOf()) {
                return false;
            }
            var fcell = this.getTimeCell(item.startTime, false);
            var ecell = this.getTimeCell(item.endTime, true);
            if (fcell === null || ecell === null) return true;
            if (fcell.startTime._date.valueOf() < this.rows.items()[0].itemsStartTime._date.valueOf()) return true;
            if (ecell.endTime._date.valueOf() > this.rows.items()[this.rows.count() - 1].itemsEndTime._date.valueOf()) return true;
            if (fcell.rowIndex === ecell.rowIndex) return false;
            return true;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getFirstRowCell',
        value: function getFirstRowCell(row) {
            return this.cells.items()[row * this.rowCellsCount];
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getLastRowCell',
        value: function getLastRowCell(row) {
            return this.cells.items()[(row + 1) * this.rowCellsCount - 1];
        }
    }, {
        key: 'getTimeRows',
        value: function getTimeRows(start, end) {
            var fcell = this.getTimeCell(start, false);
            var ecell = this.getTimeCell(end, true);
            var startRow = fcell === null ? 0 : fcell.rowIndex;
            var endRow = ecell === null ? this.rows.length - 1 : ecell.rowIndex;
            return { start: startRow, end: endRow };
        }

        /**
        * Gets the cell that corresponds to the specified time.
        * @param {Object} [time] The time to search for.
        * @param {Boolean} [isEndTime] true if the index of the first interval is returned when the time is the boundary between two consecutive intervals;
        false if the index of the second interval is contained.
        * @returns {Object} The cell that holds the specified time.
        */

    }, {
        key: 'getTimeCell',
        value: function getTimeCell(time, isEndTime) {
            if (time.valueOf() < this.startTime.valueOf()) return null;
            if (time.valueOf() > this.endTime.valueOf()) return null;
            var t = DateTime.setTimeOfDay(this.startTime, time);
            var i = DateTime.daysBetween(this.startTime, t);

            if (i > this.cells.count()) return null;
            if (i === this.cells.count()) {
                if (isEndTime && time.equals(this.cells.items()[i - 1].endTime)) return this.cells.items()[i - 1];else return null;
            }
            if (isEndTime && time.equals(this.cells.items()[i].startTime) && i > 0) i -= 1;
            return this.cells.items()[i];
        }
    }, {
        key: 'getTimeCells',
        value: function getTimeCells(startTime, endTime, isEndTime) {
            var startCell = null;
            var endCell = null;

            if (startTime.valueOf() < this.startTime.valueOf()) {
                startCell = this.cells[0];
            } else if (startTime.valueOf() > this.endTime.valueOf()) {
                return [];
            } else {
                startCell = this.getTimeCell(startTime, false);
            }
            if (endTime !== null && typeof endTime !== "undefined" && typeof endTime._date !== "undefined") {
                if (endTime.valueOf() > this.endTime.valueOf()) {
                    endCell = this.cells.items()[this.cells.count() - 1];
                } else if (endTime.valueOf() < this.startTime.valueOf()) {
                    return [];
                } else {
                    endCell = this.getTimeCell(endTime, isEndTime);
                }
            } else {
                endCell = startCell;
            }

            if (startCell && endCell) {
                var result = [];
                var cells = this.cells.items().slice(startCell.index, endCell.index + 1);
                for (var i = 0, l = cells.length; i < l; i++) {
                    if (cells[i].bgCell) {
                        result.push(cells[i]);
                    }
                }
                return result;
            }
            return [];
        }
    }, {
        key: 'clear',
        value: function clear() {
            DomUtils.removeNodes(this.getContent().querySelectorAll('.mfp-item-wrap'));
            DomUtils.removeNodes(this.getContent().querySelectorAll('.mfp-item-row'));
        }
    }, {
        key: 'init',
        value: function init() {
            if (!this.cellWidth) this.getDimensions();

            this.getAllItems();

            this.itemsToPut = this.items.slice(0);

            for (var i = 0, l = this.rows.count(); i < l; i++) {
                this.createItemsTable(this.rows.items()[i]);
            }
            for (var i = 0; i < this.itemsToPut.length; i++) {
                var item = this.items[this.items.indexOf(this.itemsToPut[i])];
                item.cell = null;
                item.row = -1;
                item.hidden = true;
            }

            this.placeItems();

            if (this.calendar.itemSettings.showItems) {
                this.getCues();
                this.createCues();
            }
        }
    }, {
        key: 'createItemsTable',
        value: function createItemsTable(row) {
            var items = this.getItemsInRow(row);
            for (var i = 0, l = this.itemsCount; i < l; i++) {
                var trow = document.createElement('tr');
                trow.className = 'mfp-item-row';
                var day = 0;
                while (day < this.rowCellsCount) {
                    var items = this.getItemsInCell(row.cells.items()[day], this.itemsToPut);
                    var item = null;
                    if (items.length > 0) item = items[0];
                    if (item !== null) {
                        var tcell = document.createElement('td');
                        tcell.className = 'mfp-item-cell';
                        tcell.colSpan = item.cellsLength;
                        tcell.style.paddingLeft = this.padding + 'px';
                        tcell.style.paddingRight = this.padding + 'px';
                        day += item.cellsLength - 1;
                        item.cell = tcell;
                        item.row = i;
                        this.itemsToPut.splice(this.itemsToPut.indexOf(item), 1);
                    } else {
                        var tcell = document.createElement('td');
                        tcell.className = 'mfp-item-cell';
                    }
                    trow.appendChild(tcell);
                    day += 1;
                }
                row.itemTable.getElementsByTagName("TBODY")[0].appendChild(trow);
            }
        }
    }, {
        key: 'getItemsInRow',
        value: function getItemsInRow(row) {
            var items = [];
            for (var i = 0, l = this.itemsToPut.length; i < l; i++) {
                if (this.itemsToPut[i].startCellIndex >= row.index * 7 && this.itemsToPut[i].startCellIndex < row.index * 7 + 7) items.push(this.itemsToPut[i]);
            }
            return items;
        }
    }, {
        key: 'getItemsInCell',
        value: function getItemsInCell(cell, items) {
            var result = [];
            for (var i = 0, l = items.length; i < l; i++) {
                if (items[i].startCellIndex === cell.index) result.push(items[i]);
            }
            return result;
        }
    }, {
        key: 'getAllItemsInCell',
        value: function getAllItemsInCell(cell) {
            var result = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].startCellIndex <= cell.index && this.items[i].lastCellIndex >= cell.index) {
                    if (this.items[i].row < this.itemsCount || this.items[i].row === -1) {
                        result.push(this.items[i]);
                    }
                }
            }
            return result;
        }

        /**
            * Gets the cell that contains the specified coordinates.
            * @param {Number} [x] The X-ccordinate of the point.
            * @param {Number} [y] The Y-ccordinate of the point.
            * @returns {Object} The cell that contains the specified coordinate.
            */

    }, {
        key: 'getCellAt',
        value: function getCellAt(x, y) {
            var i = this.getCellIndexAt(x, y);
            return this.cells.items()[i];
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getCellIndexAt',
        value: function getCellIndexAt(x, y) {
            if (!this.weekRowHeight) this.getDimensions();
            var cursor = DomUtils.getCursorPosition({ clientX: x, clientY: y }, this.getContent(), this.getScroller());
            var r = Math.floor(cursor.y / this.weekRowHeight);
            var c = Math.floor(cursor.x / this.calculatedCellWidth);
            if (c >= this.rowCellsCount || c < 0 || r >= this.rows.length || r < 0) {
                return null;
            }
            return r * this.rowCellsCount + c;
        }
    }, {
        key: 'createRows',
        value: function createRows() {

            var rowStart = this._firstVisibleDate;
            var rowEnd = this._endDate;
            var realStart = rowStart;
            var realEnd = rowEnd;

            this.itemsStartTime = realStart;
            this.itemsEndTime = this._endDate;

            var j = 0;

            var newRow = null;

            for (var row = 0; row < this._realRows; row++) {
                rowStart = DateTime.addDays(this._firstVisibleDate, row * this._daysPerWeek);
                rowEnd = DateTime.addDays(rowStart, this._daysPerWeek);
                newRow = new ViewRow(rowStart, rowEnd, rowStart, rowEnd);
                newRow.index = row;

                if (newRow.startTime < realStart) {
                    newRow.itemsStartTime = realStart;
                }
                if (newRow.endTime > realEnd) {
                    newRow.itemsEndTime = realEnd;
                }

                this.rows.add(newRow);

                for (var k = 0, m = this.rowCellsCount; k < m; k++) {
                    var cellStartTime = DateTime.addDays(newRow.startTime, k);
                    var cellEndTime = DateTime.addDays(newRow.startTime, k + 1);

                    var cell = new ViewCell();
                    cell.index = j;
                    cell.cellIndex = k;
                    cell.rowIndex = row;
                    cell.startTime = cellStartTime;
                    cell.endTime = cellEndTime;
                    newRow.cells.add(cell);
                    j += 1;
                }
            }

            this.firstVisibleCell = this.getTimeCell(this.itemsStartTime, false).index;
            this.lastVisibleCell = this.getTimeCell(this.itemsEndTime, true).index;
        }

        /*interactions */

    }, {
        key: 'endSelection',
        value: function endSelection(e, start, end) {

            var st = this.cells.items()[start].startTime;
            var et = this.cells.items()[end].endTime;

            var item = new DummyItem(st, et, '', true, this._calendar);
            get(WeekRangeCell.prototype.__proto__ || Object.getPrototypeOf(WeekRangeCell.prototype), 'endSelection', this).call(this, item);
        }
    }, {
        key: 'endItemDrag',
        value: function endItemDrag(e) {
            var cell = this.getCellAt(e.clientX, e.clientY);
            var startCell = this.cells.items()[this.itemData.startCellIndex];
            if (!cell) {
                cell = startCell;
            }

            if (cell.index < this.firstVisibleCell) {
                cell = this.cells[this.firstVisibleCell];
            } else if (cell.index > this.lastVisibleCell) {
                cell = this.cells[this.lastVisibleCell];
            }

            var item = this.itemData.item;
            var app = this.itemData.appointment;

            var startTime = DateTime.setTimeOfDay(item.startTime, cell.startTime);
            var endTime = app.getEndTime(startTime);

            get(WeekRangeCell.prototype.__proto__ || Object.getPrototypeOf(WeekRangeCell.prototype), 'endItemDrag', this).call(this, { startTime: startTime, endTime: endTime });
        }
    }, {
        key: 'endItemResize',
        value: function endItemResize(e) {
            var startCell = this.itemData.itemStartCell;
            var endCell = this.itemData.itemLastCell;

            var cell = this.getCellAt(e.clientX, e.clientY);
            if (!cell) {
                startCell = endCell = null;
            }

            var item = this.itemData.item;
            var app = this.itemData.appointment;

            var startTime = startCell != null ? DateTime.setTimeOfDay(item.startTime, startCell.startTime) : item.startTime;
            var endTime = endCell != null ? endCell.endTime : item.endTime;

            get(WeekRangeCell.prototype.__proto__ || Object.getPrototypeOf(WeekRangeCell.prototype), 'endItemResize', this).call(this, { startTime: startTime, endTime: endTime });
        }
        /*end interactions */

        /* render */

    }, {
        key: 'drawHeader',
        value: function drawHeader() {
            var result = null;

            var header = document.createElement("div");
            header.className = "mfp-header";
            result = header;

            var title = document.createElement("div");
            title.className = "mfp-title";
            header.appendChild(title);

            if ((this._settings.headerStyle & MainHeaderStyle.Title) === MainHeaderStyle.Title) {
                var a = document.createElement("a");
                a.className = "mfp-link";
                title.appendChild(a);

                if (this._titleText) a.innerText = this._titleText;else a.innerHTML = "&nbsp;";
            }
            if (this._realRows > this._rows) {
                var d = document.createElement("div");
                d.className = "mfp-scrollfix";
                d.innerHTML = "&nbsp;";
                title.appendChild(d);
            }

            if (this.settings.viewStyle === WeekRangeViewStyle.WeekPerRow && this.settings.dayNamesHeaderStyle === HorizontalHeaderStyle.Top) {
                var title = document.createElement("div");
                title.className = "mfp-header-weekdays";
                header.appendChild(title);

                var days = document.createElement("div");
                days.className = "mfp-weekdays-wrap";
                title.appendChild(days);

                var day = 0;
                var dayName = null;
                for (var i = 0; i < this._daysPerWeek; i++) {
                    day = +this.formatInfo.firstDayOfWeek + i;
                    dayName = this.calendar.getDayName(day, this.settings.dayOfWeekFormat);

                    var d = document.createElement("div");
                    d.className = "mfp-weekday";
                    if (this.calendar.showTooltips) d.title = this.calendar.getDayName(day, DayOfWeekFormat.Full);
                    days.appendChild(d);
                    if (dayName !== "") d.innerHTML = dayName;else d.innerHTML = "&nbsp;";
                }

                if (this._realRows > this._rows) {
                    var d = document.createElement("div");
                    d.className = "mfp-scrollfix";
                    d.innerHTML = "&nbsp;";
                    title.appendChild(d);
                }
            }
            return result;
        }
    }, {
        key: 'drawContent',
        value: function drawContent() {
            var result = null;

            var content = document.createElement("div");
            content.className = "mfp-content";
            result = content;

            var wrapper = document.createElement("div");
            wrapper.className = "mfp-wrap";

            content.appendChild(wrapper);

            var pointDate = this._firstVisibleDate.date;
            var weekClass = "";

            for (var row = 0; row < this._realRows; row++) {
                weekClass = "mfp-week";
                // if (row === 0) weekClass += " mfp-top-row";
                // if (row === this._realRows - 1) weekClass += " mfp-bottom-row";

                var r = document.createElement("div");
                r.className = weekClass;
                r.style.height = this._rowHeight;
                wrapper.appendChild(r);

                var t = this.drawBackgroundTable(pointDate, row);
                r.appendChild(t);

                var t = this.drawItemTable(pointDate, row);
                r.appendChild(t);

                pointDate = DateTime.addDays(pointDate, this._daysPerWeek);
            }

            return result;
        }
    }, {
        key: 'drawBackgroundTable',
        value: function drawBackgroundTable(startDate, row) {
            var result = null;

            var r = document.createElement("div");
            r.className = "mfp-bg-row";
            result = r;

            for (var day = 0; day < this._daysPerWeek; day++) {
                var isEmpty = false;
                var dayClass = "mfp-bg-cell";

                if (startDate._date.valueOf() >= this._endDate._date.valueOf()) isEmpty = true;

                var dayOfWeek = startDate.dayOfWeek;
                if (dayOfWeek === DayOfWeek.Saturday || dayOfWeek === DayOfWeek.Sunday) dayClass += " mfp-weekend-cell";

                var d;
                if (!isEmpty) {
                    d = this.drawWeekDay(startDate);
                    d.className = dayClass;
                } else {
                    d = document.createElement("div");
                    d.className = dayClass + " mfp-empty-cell";
                    // d.innerHTML = "&nbsp;";
                }

                r.appendChild(d);
                startDate = DateTime.addDays(startDate, 1);
            }

            return result;
        }
    }, {
        key: 'drawWeekDay',
        value: function drawWeekDay(day) {
            var result = null;

            var dayOfMonth = DateTime.getDayOfMonth(day);
            var month = DateTime.getMonth(day);

            var t = document.createElement("div");
            result = t;

            var title = document.createElement("div");
            title.className = "mfp-bg-cell-header";
            t.appendChild(title);

            if (month === 0 && dayOfMonth === 1) title.innerText = day.toString(this.settings.firstDayOfYearFormat, this.formatInfo);else if (month !== 0 && dayOfMonth === 1) title.innerText = day.toString(this.settings.firstDayOfMonthFormat, this.formatInfo);else title.innerText = day.toString(this.settings.generalFormat, this.formatInfo);

            return result;
        }
    }, {
        key: 'drawItemTable',
        value: function drawItemTable(startDate, rowIndex) {
            var result = null;
            var pointDate = startDate.date;

            var t = document.createElement("table");
            t.cellPadding = 0;
            t.cellSpacing = 0;
            t.className = "mfp-item-table";
            result = t;

            var tb = document.createElement("tbody");
            t.appendChild(tb);

            var tr = document.createElement("tr");
            tb.appendChild(tr);

            for (var day = 0; day < this._daysPerWeek; day++) {
                var td = document.createElement("td");
                if (this.calendar.showTooltips) td.title = pointDate.toString(this.formatInfo.dateFormats.longDate, this.formatInfo);
                tr.appendChild(td);

                if (pointDate._date.valueOf() < this._endDate._date.valueOf()) {
                    var d = document.createElement("div");
                    d.className = "mfp-cell-header";
                    d.innerHTML = "&nbsp;";
                    td.appendChild(d);
                }
                pointDate = DateTime.addDays(pointDate, 1);
            }

            return result;
        }
    }, {
        key: 'cells',
        get: function get$$1() {
            var result = new List();
            this.rows.forEach(function (t) {
                result.addRange(t.cells.items());
            }, this);
            return result;
        }
    }, {
        key: 'cssClass',
        get: function get$$1() {
            return "mfp-week-view";
        }
    }]);
    return WeekRangeCell;
}(Cell);

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* For internal use only.
* @private
*/

var ViewColumn = function () {
    function ViewColumn(index, date, start, end) {
        classCallCheck(this, ViewColumn);

        this._index = index;
        this._date = date;
        this._startTime = start;
        this._endTime = end;

        this.cells = new List();
    }

    createClass(ViewColumn, [{
        key: 'index',
        get: function get$$1() {
            return this._index;
        }
    }, {
        key: 'startTime',
        get: function get$$1() {
            return this._startTime;
        }
    }, {
        key: 'endTime',
        get: function get$$1() {
            return this._endTime;
        }
    }, {
        key: 'date',
        get: function get$$1() {
            return this._date;
        }
    }, {
        key: 'headerCell',
        get: function get$$1() {
            return this._headerCell;
        },
        set: function set$$1(value) {
            this._headerCell = value;
        }
    }, {
        key: 'cells',
        get: function get$$1() {
            return this._cells;
        },
        set: function set$$1(value) {
            this._cells = value;
        }
    }, {
        key: 'timeRange',
        get: function get$$1() {
            return new TimeRange(this.startTime, this.endTime);
        }
    }]);
    return ViewColumn;
}();

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* For internal use only.
* @private
*/

var Timetable = function (_Cell) {
    inherits(Timetable, _Cell);

    function Timetable(calendar) {
        classCallCheck(this, Timetable);

        var _this = possibleConstructorReturn(this, (Timetable.__proto__ || Object.getPrototypeOf(Timetable)).call(this, calendar));

        _this._settings = _this.calendar.timetableSettings;

        _this._columns = new List();

        _this.initVars();

        _this._dragging = false;
        _this._resizing = false;
        _this._selecting = false;
        _this._selectionPaused = false;

        _this.items = [];
        return _this;
    }

    createClass(Timetable, [{
        key: 'initVars',
        value: function initVars() {

            if (this.settings.dates.count() === 0) {
                var d = this.calendar.date;
                this.settings.dates.add(new DateTime(Date.UTC(d.year, d.month, d.day, 0, 0, 0)));
            }

            this._groupColumns = 0;
            this._dateColumns = this.settings.dates.count();
            if (this.calendar.realGroupType !== GroupType.None) this._groupColumns = this.calendar.groupResources.count();

            this._totalColumns = this._groupColumns == 0 ? this._dateColumns : this._dateColumns * this._groupColumns;

            var columnTime = TimeSpan.fromMinutes(this.settings.realEndTime - this.settings.startTime);
            this._totalCells = Math.floor(columnTime.ticks / this.settings.cellTime.ticks);
            if (columnTime.ticks % this.settings.cellTime.ticks !== 0) this._totalCells++;

            if (this.settings.cellTime.minutes > 0 && this.settings.cellTime.minutes <= 60 && this.settings.cellTime.minutes - this.settings.cellTime.minutes === 0 && this.settings.startTime % 60 === 0) {
                this._canGroupHour = 60 % this.settings.cellTime.minutes === 0;
                if (columnTime.minutes % 60 !== 0) this._canGroupHour = false;
            } else this._canGroupHour = false;

            this.createColumns();
        }
    }, {
        key: 'createColumn',
        value: function createColumn(date, index, resource) {
            var d = date.clone();

            var col = new ViewColumn(index, d, DateTime.addMinutes(d, this.settings.startTime), DateTime.addMinutes(d, this.settings.endTime));
            col.resource = resource;

            var headerCell = new ViewCell();
            headerCell.startTime = d;
            headerCell.endTime = DateTime.addTicksToDate(d, DateTime.MillisPerDay);
            headerCell.resource = resource;
            headerCell.index = index;
            headerCell.columnIndex = index;
            headerCell.isHeader = true;

            col.headerCell = headerCell;

            return col;
        }
    }, {
        key: 'createColumns',
        value: function createColumns() {

            this._columns = new ObservableCollection();

            var i = 0;

            if (this._groupColumns > 0) {
                if (this.settings.reverseGrouping) {
                    for (var resourceIndex = 0; resourceIndex < this._groupColumns; resourceIndex++) {
                        for (var dateIndex = 0; dateIndex < this._dateColumns; dateIndex++) {
                            var col = this.createColumn(this.settings.dates.items()[dateIndex], i, this.resources[resourceIndex]);
                            this._columns.add(col);
                            i++;
                        }
                    }
                } else {
                    for (var dateIndex = 0; dateIndex < this._dateColumns; dateIndex++) {
                        for (var resourceIndex = 0; resourceIndex < this._groupColumns; resourceIndex++) {
                            var col = this.createColumn(this.settings.dates.items()[dateIndex], i, this.resources[resourceIndex]);
                            this._columns.add(col);
                            i++;
                        }
                    }
                }
            } else {
                this.settings.dates.forEach(function (t) {
                    var d = new DateTime(Date.UTC(t.year, t.month, t.day, 0, 0, 0));
                    var col = this.createColumn(t, i, null);
                    this._columns.add(col);
                    i++;
                }, this);
            }

            this.startTime = this.itemsStartTime = this._columns.items()[0].startTime;
            this.endTime = this.itemsEndTime = this._columns.items()[this._columns.count() - 1].endTime;

            this.headerItemsStartTime = this.headerCells.items()[0].startTime;
            this.headerItemsEndTime = this.headerCells.items()[this.headerCells.count() - 1].endTime;

            this.rowsCount = this._totalCells;
            for (var i = 0, l = this._totalColumns; i < l; i++) {
                this.skipNext = 0;
                this.skipped = false;
                var col = this._columns.items()[i];

                for (var k = 0, m = this._totalCells; k < m; k++) {

                    if (this.skipNext > 0 && k <= this.skipNext) {
                        var cst = this.addUnits(col.startTime, k % this.rowsCount);
                        var cet = this.addUnits(col.startTime, k % this.rowsCount + 1);
                    } else {
                        var startTime = this.addUnits(col.startTime, k % this.rowsCount);
                        var endTime = this.addUnits(col.startTime, k % this.rowsCount + 1);
                    }
                    if (endTime._date.valueOf() > col.endTime._date.valueOf()) {
                        endTime = this._columns.items()[i].endTime;
                    }
                    var cell = new ViewCell();
                    cell.startTime = startTime;
                    cell.endTime = endTime;
                    cell.resource = this.resources != null && this.grouped ? col.resource : null;
                    cell.index = k + this.rowsCount * i;
                    cell.columnIndex = i;
                    col.cells.add(cell);
                }
            }
        }

        /* Dom */

    }, {
        key: 'getScroller',
        value: function getScroller() {
            if (!this.Dom.scroller) {
                this.Dom.scroller = this.calendar.getElement().querySelector("div.mfp-scroll-container");
            }
            return this.Dom.scroller;
        }
    }, {
        key: 'getContainer',
        value: function getContainer() {
            return this.getElement();
        }
    }, {
        key: 'getHeaderItemsCells',
        value: function getHeaderItemsCells() {
            if (!this.Dom.headerItemsCells) {
                this.Dom.headerItemsCells = this.getHeader().querySelectorAll("td.mfp-item-cell");
            }
            return this.Dom.headerItemsCells;
        }
    }, {
        key: 'getTimelineHeader',
        value: function getTimelineHeader() {
            if (!this.Dom.timeline) {
                this.Dom.timeline = this.calendar.getElement().querySelector("div.mfp-header-timeline");
            }
            return this.Dom.timeline;
        }
    }, {
        key: 'getGroupHeader',
        value: function getGroupHeader() {
            if (!this.Dom.groupHeader) {
                this.Dom.groupHeader = this.calendar.getElement().querySelector("tr.mfp-group-row");
            }
            return this.Dom.groupHeader;
        }
    }, {
        key: 'getContent',
        value: function getContent() {
            if (!this.Dom.content) {
                this.Dom.content = this.calendar.getElement().querySelector("div.mfp-content");
            }
            return this.Dom.content;
        }
    }, {
        key: 'getRows',
        value: function getRows() {
            return this.calendar.getElement().querySelectorAll('div.week');
        }
    }, {
        key: 'getBgCells',
        value: function getBgCells() {
            return this.calendar.getElement().querySelectorAll('div.mfp-cell-wrap');
        }
    }, {
        key: 'detach',
        value: function detach() {
            this.getHeader().removeEventListener("click", this.headerClickHandler);
            if (this.getGroupHeader()) this.getGroupHeader().removeEventListener("click", this.headerClickHandler);
            if (this.getTimelineHeader()) this.getTimelineHeader().removeEventListener("click", this.headerClickHandler);

            var buttons = this.getHeader().querySelectorAll("a.mfp-button");
            for (var i = 0; i < buttons.length; i++) {
                buttons[i].removeEventListener('click', this.buttonClickHandler);
            }
        }
    }, {
        key: 'attach',
        value: function attach() {
            var bgTables = this.getElement().querySelectorAll("div.mfp-column");
            var headerCells = this.getHeaderItemsCells();

            for (var i = 0; i < this._columns.count(); i++) {
                var col = this._columns.items()[i];
                col.bgTable = bgTables[i];
                col.headerCell.bgCell = headerCells[i];

                var bgCells = col.bgTable.querySelectorAll("div.mfp-cell-wrap");

                for (var k = 0, m = col.cells.count(); k < m; k++) {
                    var cell = col.cells.items()[k];
                    cell.bgCell = bgCells[k];
                }
            }

            this.clear();
            this.init();

            this.getHeader().addEventListener("click", this.headerClickHandler);
            if (this.getGroupHeader()) this.getGroupHeader().addEventListener("click", this.headerClickHandler);
            if (this.getTimelineHeader()) this.getTimelineHeader().addEventListener("click", this.headerClickHandler);

            var buttons = this.getHeader().querySelectorAll("a.mfp-button");
            for (var i = 0; i < buttons.length; i++) {
                buttons[i].addEventListener('click', this.buttonClickHandler);
            }
        }
    }, {
        key: 'getCellAt',
        value: function getCellAt(x, y, resource) {
            var cursor = DomUtils.getCursorPosition({ clientX: x, clientY: y });
            var isInHeader = DomUtils.isPointInBounds(cursor, this.getHeaderBounds());
            var i = this.getCellIndexAt(x, y, resource);
            if (isInHeader) return this.headerCells.items()[i];else return this.cells.items()[i];
        }
    }, {
        key: 'getCellIndexAt',
        value: function getCellIndexAt(x, y, resource) {
            if (!this.cellWidth) this.getDimensions();

            var cursor = DomUtils.getCursorPosition({ clientX: x, clientY: y });
            var isInSchedule = DomUtils.isPointInBounds(cursor, this.getScheduleBounds());
            var isInHeader = DomUtils.isPointInBounds(cursor, this.getHeaderBounds());
            var point = null;
            var cell = null;
            if (isInHeader) {
                point = DomUtils.getPointInBounds(cursor, this.getHeaderBounds());
                cell = this.headerCells.items()[parseInt((point.x + this.getScroller().scrollLeft) / this.cellWidth)];

                if (cell) {
                    if (this.grouped && resource && cell.resource != resource) {
                        var colIndex = this.getColumnIndexByTime(cell.startTime._date.valueOf(), false, resource);
                        var cell = this.headerCells.items()[colIndex];
                    }
                    return cell.index;
                }
            } else if (isInSchedule) {
                point = DomUtils.getPointInBounds(cursor, this.getScheduleBounds());
                if (point.y >= this.cellHeight * this.rowsCount) return null;
                point.x += this.getScroller().scrollLeft;
                var col = parseInt(point.x / this.cellWidth);
                var row = parseInt(point.y / this.cellHeight);
                cell = this.cells.items()[col * this.rowsCount + row];

                if (cell) {
                    if (this.grouped && resource && cell.resource != resource) {
                        var colIndex = this.getColumnIndexByTime(cell.startTime._date.valueOf(), false, resource);
                        var cell = this.getTimeCell(cell.startTime, false, colIndex);
                    }
                    return cell.index;
                }
            }
            return null;
        }
    }, {
        key: 'getColumnIndexByTime',
        value: function getColumnIndexByTime(time, isEndTime, resource) {
            if (time != null && time.getTime != null) time = time.getTime();
            for (var i = 0, l = this._columns.count(); i < l; i++) {
                var c = this._columns.items()[i];
                if (resource === c.resource) {
                    var colStart = c.headerCell.startTime._date.valueOf();
                    var colEnd = c.headerCell.endTime._date.valueOf();
                    if (time >= colStart && time <= colEnd && isEndTime) return i;
                    if (time >= colStart && time < colEnd) return i;
                }
            }
            return -1;
        }
    }, {
        key: 'addUnits',
        value: function addUnits(date, count) {
            var result;
            var r = new DateTime(DateTime.addMilliseconds2(new Date(date._date.valueOf()), count * this.settings.cellTime.milliseconds));
            result = DateTime.addMilliseconds(date, count * this.settings.cellTime.milliseconds);
            if (result._date.valueOf() < r._date.valueOf()) {
                return r;
            }
            if (result._date.getHours() - r._date.getHours() > 1) {
                this.skipNext = 3600000 + count * this.settings.cellTime.milliseconds;
            } else {
                if (this.skipNext > 0) {
                    this.skipped = true;
                }
                if (this.skipNext === 0 && this.skipped) {
                    result._date.setHours(result._date.getHours() - 1);
                }
                this.skipNext = 0;
            }
            return result;
        }
    }, {
        key: 'getScheduleBounds',
        value: function getScheduleBounds() {
            return DomUtils.getBounds(this.getContent());
        }
    }, {
        key: 'getHeaderBounds',
        value: function getHeaderBounds() {
            var header = this.getHeader();

            if (!header) return null;
            var titles = header.querySelectorAll("div.mfp-title");
            if (titles.length === 0) return { x: 0, y: 0, width: 0, height: 0 };
            var bounds = DomUtils.getBounds(titles[0]);

            var titleRow = header.querySelector("tr.mfp-header-row");
            if (titleRow) {
                var height = titleRow.offsetHeight;
                bounds.y += height;
                bounds.height -= height;
            }
            return bounds;
        }
    }, {
        key: 'getAllItemsInCell',
        value: function getAllItemsInCell(cell) {
            var result = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.isItemInColumn(this.items[i].item, this.columns.items()[cell.columnIndex])) {
                    if (this.items[i].startCellIndex <= cell.index && this.items[i].lastCellIndex >= cell.index) {
                        result.push(this.items[i]);
                    }
                }
            }
            return result;
        }

        /* Interactions */

    }, {
        key: 'startSelect',
        value: function startSelect(e) {
            var cursor = DomUtils.getCursorPosition(e);
            var isInHeader = DomUtils.isPointInBounds(cursor, this.getHeaderBounds());

            var cell = this.getCellIndexAt(e.clientX, e.clientY, this.calendar.selectManager.resource);
            this.startCol = this.endCol = this.cells.items()[cell].columnIndex;
            this.startCell = cell;

            if (isInHeader) {
                this.startCol = this.endCol = cell;
                var cell = cell * this.rowsCount;
                this.startCell = cell;
            }
            this.calendar.selectManager.start = cell;
            this.calendar.selectManager.end = cell;
            if (isInHeader) {
                this.calendar.selectManager.end = cell + this.rowsCount - 1;
            }
            this.calendar.selectManager.isInHeader = isInHeader;
        }
    }, {
        key: 'doSelect',
        value: function doSelect(e) {
            if (this.calendar.selectManager.start != null) {
                var cursor = DomUtils.getCursorPosition(e);
                var isInHeader = DomUtils.isPointInBounds(cursor, this.getHeaderBounds());

                if (isInHeader) {
                    var col = this.getCellIndexAt(e.clientX, e.clientY);
                    if (col != null) {
                        if (this.calendar.selectManager.resource && this._columns.items()[col].resource !== this.calendar.selectManager.resource) return;

                        this.endCol = col;
                        var sc = Math.min(this.startCol, this.endCol);
                        var ec = Math.max(this.startCol, this.endCol);
                        var start = sc * this.rowsCount;
                        var end = ec * this.rowsCount + this.rowsCount - 1;

                        this.calendar.selectManager.start = start;
                        this.calendar.selectManager.end = end;
                        this.calendar.selectManager.isInHeader = true;
                    }
                } else {
                    var cell = this.getCellIndexAt(e.clientX, e.clientY);
                    if (cell != null) {
                        if (this.calendar.selectManager.resource && this.cells.items()[cell].resource !== this.calendar.selectManager.resource) return;
                    }

                    if (this.calendar.selectManager.isInHeader) {
                        this.calendar.selectManager.start = this.startCell;
                    }

                    cell = this.getCellIndexAt(e.clientX, e.clientY, this.calendar.selectManager.resource);
                    if (cell != null) {
                        this.endCol = this.cells.items()[cell].columnIndex;

                        var start = this.calendar.selectManager.start;
                        var end = cell;
                        this.calendar.selectManager.start = start;
                        this.calendar.selectManager.end = end;
                        this.calendar.selectManager.isInHeader = false;
                    }
                }
            }
        }
    }, {
        key: 'endSelection',
        value: function endSelection(e, start, end, resource) {
            var cursor = DomUtils.getCursorPosition(e);
            var isInHeader = DomUtils.isPointInBounds(cursor, this.getHeaderBounds());

            var st = this.cells.items()[start].startTime;
            var et = this.cells.items()[end].endTime;

            if (isInHeader) {
                var st = this.headerCells.items()[this.cells.items()[start].columnIndex].startTime;
                var et = this.headerCells.items()[this.cells.items()[end].columnIndex].endTime;
            }
            var item = new DummyItem(st, et, '', isInHeader, this.calendar, resource);
            get(Timetable.prototype.__proto__ || Object.getPrototypeOf(Timetable.prototype), 'endSelection', this).call(this, item);
        }
    }, {
        key: 'updateDrag',
        value: function updateDrag(appointment, cell, e) {
            if (cell) {
                var cursor = DomUtils.getCursorPosition(e);
                var isInHeader = DomUtils.isPointInBounds(cursor, this.getHeaderBounds());
                var milestone = appointment.isMilestone;

                if (this.headerCells.contains(cell) && !appointment.isHeader) {
                    appointment.item._allDayEvent = true;
                    appointment.isHeader = true;
                    appointment.cellsLength = 1;
                    appointment.item._startTime = cell.startTime;
                    appointment.item._endTime = cell.endTime;
                    appointment.length = appointment.getLength(appointment.item);
                    appointment.recreateVisual();
                    this.itemData.startTimeOffset2 = 0;
                    this.itemData.endTimeOffset2 = 0;
                } else if (!this.headerCells.contains(cell) && appointment.isHeader) {
                    appointment.item._allDayEvent = false;
                    appointment.isHeader = false;
                    appointment.cellsLength = 1;
                    appointment.item._startTime = cell.startTime;
                    appointment.item._endTime = cell.endTime;
                    appointment.length = appointment.getLength(appointment.item);
                    appointment.recreateVisual();
                    this.itemData.startTimeOffset2 = 0;
                    this.itemData.endTimeOffset2 = 0;
                } else {
                    if (appointment.partIndex === 1) {
                        appointment.item._endTime = DateTime.addTicksToDate(cell.endTime, this.itemData.endTimeOffset2);
                        appointment.item._startTime = DateTime.addTicksToDate(appointment.item.endTime, -appointment.length);
                    } else {
                        appointment.item._startTime = DateTime.addTicksToDate(cell.startTime, this.itemData.startTimeOffset2);
                        if (milestone) appointment.item._endTime = appointment.item.startTime;else appointment.item._endTime = DateTime.addTicksToDate(appointment.item.startTime, appointment.length);
                    }
                }

                appointment.item.setResource(cell.resource);
                appointment.removeParts();

                if (isInHeader) var parts = this.updateHeaderItem(appointment);else var parts = this.updateDayItem(appointment);

                for (var k = 0, l = parts.length; k < l; k++) {
                    if (parts[k] !== undefined) this.placeItem(parts[k]);
                }
                appointment = parts[appointment.partIndex === 1 ? parts.length - 1 : 0];

                this.dragContainer.data.appointment = appointment;
                this.dragContainer.data.item = appointment.item;
                this.updateLayout();
            }
        }
    }, {
        key: 'endItemDrag',
        value: function endItemDrag(e, resource) {

            var item = this.itemData.item;
            var app = this.itemData.appointment;

            var cell = this.getCellAt(e.clientX, e.clientY, resource);

            if (cell) {
                var startTime = this.itemData.item.startTime.clone();
                var endTime = this.itemData.item.endTime.clone();
                var resource = cell.resource;

                this.itemData.item._startTime = this.itemData.startTime;
                this.itemData.item._endTime = this.itemData.endTime;
                this.itemData.item.setResource(this.itemData.itemStartCell.resource);

                get(Timetable.prototype.__proto__ || Object.getPrototypeOf(Timetable.prototype), 'endItemDrag', this).call(this, { startTime: startTime, endTime: endTime, resource: resource });
            } else {
                this.cancelInteraction(ItemModifyAction.Drag);
            }
        }

        /**
              * For internal use only.
              * @private
              * Called upon finishing a resize interaction.
              */

    }, {
        key: 'endItemResize',
        value: function endItemResize(e) {

            var item = this.itemData.item;
            var app = this.itemData.appointment;
            var resource = this.itemData.itemStartCell.resource;

            var cell = this.getCellAt(e.clientX, e.clientY, resource);
            if (cell) {
                var startTime = this.itemData.item.startTime.clone();
                var endTime = this.itemData.item.endTime.clone();
                var resource = cell.resource;

                this.itemData.item._startTime = this.itemData.startTime;
                this.itemData.item._endTime = this.itemData.endTime;
                this.itemData.item.setResource(this.itemData.itemStartCell.resource);

                get(Timetable.prototype.__proto__ || Object.getPrototypeOf(Timetable.prototype), 'endItemResize', this).call(this, { startTime: startTime, endTime: endTime, resource: resource });
            } else {
                this.cancelInteraction(ItemModifyAction.Resize);
            }
        }
    }, {
        key: 'cancelInteraction',
        value: function cancelInteraction(action) {

            var prototype = this.calendar.getAppointmentById(this.itemData.item.id, this.itemData.item.occurrenceIndex);

            if (prototype.isHeader != this.itemData.isHeader) {
                prototype.isHeader = this.itemData.isHeader;
                prototype.item._allDayEvent = this.itemData.isHeader;
                prototype.length = this.itemData.length;
                prototype.recreateVisual();
            }

            var startTime = this.itemData.startTime;
            var endTime = this.itemData.endTime;
            var resource = this.itemData.itemStartCell.resource;

            if (action == ItemModifyAction.Drag) get(Timetable.prototype.__proto__ || Object.getPrototypeOf(Timetable.prototype), 'endItemDrag', this).call(this, { startTime: startTime, endTime: endTime, resource: resource });else get(Timetable.prototype.__proto__ || Object.getPrototypeOf(Timetable.prototype), 'endItemResize', this).call(this, { startTime: startTime, endTime: endTime, resource: resource });
        }

        /**
          * For internal use only.
          * @private
          * Updates appointment and layout during resize operation.
          */

    }, {
        key: 'updateResize',
        value: function updateResize(appointment, cell, e) {
            var cursor = DomUtils.getCursorPosition(e);
            var isInHeader = DomUtils.isPointInBounds(cursor, this.getHeaderBounds());
            var ci = cell.index;
            var si = this.resizeStartCell.index;
            var ei = this.resizeLastCell.index;

            if (this.itemData.handle === 'start') {
                if (ci < si) {
                    var s = cell;
                    var e = this.resizeLastCell;
                } else {
                    if (ci < ei) {
                        var s = cell;
                        var e = this.resizeLastCell;
                    } else {
                        var s = this.resizeLastCell;
                        var e = cell;
                    }
                }
            }

            if (this.itemData.handle === 'end') {
                if (ci > ei) {
                    var s = this.resizeStartCell;
                    var e = cell;
                } else {
                    if (ci > si) {
                        var s = this.resizeStartCell;
                        var e = cell;
                    } else {
                        var s = cell;
                        var e = this.resizeStartCell;
                    }
                }
            }

            var startCell;
            if (!s.isHeader && !e.isHeader || s.isHeader && e.isHeader) startCell = s.index < e.index ? s : e;else if (!s.isHeader) startCell = s.columnIndex <= e.index ? s : e;else if (!e.isHeader) startCell = s.index < e.columnIndex ? s : e;
            var endCell = startCell === s ? e : s;

            if (this.grouped && this.reverseGrouping && startCell.resource !== endCell.resource) {
                return;
            }

            if (this.itemData.handle === 'start') appointment.item._startTime = startCell.startTime;

            if (this.itemData.handle === 'end') appointment.item._endTime = endCell.endTime;

            if ((appointment.getLength(appointment.item) >= this.dayLength || isInHeader) && !appointment.isHeader) {
                appointment.item._allDayEvent = true;
                appointment.isHeader = true;
                appointment.cellsLength = 1;
                appointment.length = appointment.getLength(appointment.item);
                appointment.recreateVisual();
                isInHeader = true;
            }
            if (appointment.getLength(appointment.item) < this.dayLength && appointment.isHeader) {
                appointment.item._allDayEvent = false;
                appointment.isHeader = false;
                appointment.length = appointment.getLength(appointment.item);
                appointment.cellsLength = appointment.length / this.cellTime;
                appointment.recreateVisual();
                isInHeader = false;
            }
            appointment.item.setResource(this.itemData.itemStartCell.resource);
            appointment.removeParts();

            if (appointment.isHeader) var parts = this.updateHeaderItem(appointment);else var parts = this.updateDayItem(appointment);

            for (var i = 0, l = parts.length; i < l; i++) {
                this.placeItem(parts[i]);
            }
            if (this.itemData.handle === 'end') {
                appointment = parts[parts.length - 1];
            } else {
                appointment = parts[0];
            }
            this.resizeContainer.data.appointment = appointment;
            this.updateLayout();
        }

        /* Item placement */

    }, {
        key: 'getDimensions',
        value: function getDimensions() {
            this.cellWidth = this.getContent().offsetWidth / this._columns.count();
            this.cellHeight = this.getContent().children[0].children[0].offsetHeight;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'clear',
        value: function clear() {
            DomUtils.removeNodes(this.getElement().querySelectorAll('.mfp-item-wrap'));
            DomUtils.removeNodes(this.getContent().querySelectorAll('.mfp-item-cell'));
        }
    }, {
        key: 'init',
        value: function init() {
            if (!this.cellWidth) this.getDimensions();

            this.getAllItems();

            this.placeItems();
            this.updateLayout();

            if (this.calendar.itemSettings.showItems && this.settings.showDayHeader) {
                this.getCues();
                this.createCues();
            }
        }
    }, {
        key: 'placeItems',
        value: function placeItems() {
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].isHeader && !this.settings.showDayHeader) continue;
                this.placeItem(this.items[i]);
            }
        }
    }, {
        key: 'placeItem',
        value: function placeItem(appointment) {
            var wrapper = this.getItemCell(appointment);
            if (wrapper != null) {

                // Remove empty text string
                if (wrapper.nodeName.toUpperCase() === "TD" && wrapper.innerHTML === "&nbsp;") wrapper.innerHTML = "";

                wrapper.appendChild(appointment.element.parentNode);
            }
            if (appointment.isHeader) {
                appointment.element.style.margin = this.calendar.itemSettings.spacing + 'px';
                if (this.calendar.itemSettings.spacing > 0) {
                    appointment.element.style.marginBottom = '0px';
                }
            } else {
                appointment.updateTimeIndicator();
                appointment.element.style.height = appointment.cellsLength * this.cellHeight + 'px';
                if (this.calendar.itemSettings.spacing > 0) {
                    appointment.element.childNodes[0].style.marginRight = this.calendar.itemSettings.spacing + 'px';
                }
            }
        }

        /*Cell.getCues override */

    }, {
        key: 'getCues',
        value: function getCues() {
            this.cues = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                var item = this.items[i];
                if (!item.isHeader) {
                    continue;
                }

                var row = this.getHeaderItemRow(item);

                if (row >= this.settings.maxItems) {
                    var cells = this.getItemCueCells(item);
                    for (var k = 0; k < cells.length; k++) {
                        if (this.cues.indexOf(cells[k]) === -1) this.cues.push(cells[k]);
                    }
                    item.hidden = true;
                    item.element.parentNode.style.visibility = 'hidden';
                    item.element.parentNode.style.display = 'none';
                } else {
                    item.hidden = false;
                    item.element.parentNode.style.visibility = 'visible';
                    item.element.parentNode.style.display = 'block';
                }
            }
        }
    }, {
        key: 'getHeaderItemRow',
        value: function getHeaderItemRow(appointment) {
            if (!appointment.isHeader) {
                return -1;
            }
            var w = this.getItemCell(appointment).querySelectorAll(".mfp-item-wrap");
            for (var i = 0, l = w.length; i < l; i++) {
                if (w[i] == DomUtils.getParent(appointment.element, "mfp-item-wrap")) return i;
            }
            return -1;
        }
    }, {
        key: 'getItemCell',
        value: function getItemCell(appointment) {
            var wrapper = null;
            var cellIndex = appointment.cellIndex;
            if (appointment.isHeader) {
                var headerCells = this.getHeaderItemsCells();
                if (cellIndex >= 0 && cellIndex < headerCells.length) wrapper = headerCells[cellIndex];
            } else {
                if (cellIndex >= 0 && cellIndex < this.cells.count()) {
                    var cell = this.cells.items()[cellIndex].bgCell;
                    var itemCells = cell.querySelectorAll(".mfp-item-cell");
                    if (itemCells.length === 0) {
                        wrapper = document.createElement("div");
                        wrapper.className = "mfp-item-cell";
                        cell.appendChild(wrapper);
                    } else wrapper = itemCells[0];
                }
            }
            return wrapper;
        }
    }, {
        key: 'updateLayout',
        value: function updateLayout() {
            var appointments = this.items;
            var appointment = null;
            var columns = [];

            // Gets all visible schedule items in columns
            for (var i = 0, l = appointments.length; i < l; i++) {
                appointment = appointments[i];
                if (!appointment.isHeader) {
                    var colIndex = parseInt(appointment.cellIndex / this.rowsCount);
                    if (columns[colIndex] == null) columns[colIndex] = [];
                    columns[colIndex].push(appointment);
                }
            }

            for (var colIndex = 0, colLength = columns.length; colIndex < colLength; colIndex++) {
                var dayItems = columns[colIndex];
                if (!dayItems) {
                    continue;
                }
                dayItems.sort(this.calendar.sortAppointments);

                var usedCells = [];
                for (var i = 0; i < this.rowsCount; i++) {
                    usedCells.push([null]);
                }var cellIndex = 0,
                    itemEnd = 0;
                var offsetIndex = 0;
                var canSetItem = true;

                // Sets schedule appointments offset, left and width
                for (var j = 0, dLen = dayItems.length; j < dLen; j++) {
                    var part = dayItems[j];
                    cellIndex = part.cellIndex % this.rowsCount;
                    itemEnd = cellIndex + part.cellsLength - 1;
                    offsetIndex = 0;
                    do {
                        canSetItem = true;

                        // Adds new column with null values
                        if (usedCells[0].length <= offsetIndex) {
                            for (var i = 0; i < this.rowsCount; i++) {
                                usedCells[i].push(null);
                            }
                        }

                        for (var i = cellIndex; i <= itemEnd; i++) {
                            if (usedCells[i][offsetIndex] != null) {
                                canSetItem = false;
                                offsetIndex++;
                                break;
                            }
                        }

                        if (canSetItem) {
                            part.intLeft = offsetIndex;
                            for (var i = cellIndex; i <= itemEnd; i++) {
                                usedCells[i][offsetIndex] = part.element;
                            }
                        }
                    } while (!canSetItem);
                }

                var ids = [];
                var rowIds = [];
                var startIndex = -1;
                var endIndex = -1;
                var found = false;
                var max = 0;

                for (var i = 0, luc = usedCells.length; i < luc; i++) {

                    var row = usedCells[i];
                    rowIds = new Array();

                    for (var j = 0, columnCount = row.length; j < columnCount; j++) {
                        var partElement = row[j];
                        if (partElement != null && rowIds.indexOf(partElement) === -1) rowIds.push(partElement);
                    }

                    if (rowIds.length > 0) {

                        if (startIndex === -1) {
                            // if ids set not started then start it and adds all ids
                            startIndex = i;
                            for (var j = 0; j < rowIds.length; j++) {
                                if (ids.indexOf(rowIds[j]) === -1) ids.push(rowIds[j]);
                            }
                        } else {
                            // if ids set is started then check some of them is in the ids list
                            found = false;
                            for (var j = 0; j < rowIds.length; j++) {
                                if (ids.indexOf(rowIds[j]) > -1) {
                                    found = true;
                                    break;
                                }
                            }

                            // if some id is found then adds all ids to ids array
                            if (found) {
                                for (var j = 0; j < rowIds.length; j++) {
                                    if (ids.indexOf(rowIds[j]) === -1) ids.push(rowIds[j]);
                                }
                            } else {
                                endIndex = i;
                                i--;
                            }
                        }
                    } else {
                        if (startIndex > -1) {
                            endIndex = i;
                            i--;
                        }
                    }

                    // if set is complete then calculate items left and width
                    if (i == luc - 1 && startIndex > -1 && endIndex == -1) endIndex = i + 1;

                    if (startIndex > -1 && endIndex > -1) {

                        // Get items count
                        var max = 0,
                            tMax = 0;
                        for (var mIndex = startIndex; mIndex < endIndex; mIndex++) {
                            var row = usedCells[mIndex];
                            tMax = 0;
                            for (var bl = 0; bl < row.length; bl++) {
                                if (row[bl] != null) {
                                    tMax++;
                                }
                            }
                            if (tMax > max) max = tMax;
                        }

                        if (max > 0) {

                            for (var p = 0; p < ids.length; p++) {
                                var item = null;
                                for (var n = 0; n < dayItems.length; n++) {
                                    if (ids[p] == dayItems[n].element) {
                                        item = dayItems[n];
                                        break;
                                    }
                                }if (item == null) continue;

                                var width = parseInt(100 / max);
                                var left = width * item.intLeft;
                                var st = item.element.style;
                                if (left > 0) st.left = left + "%";else st.left = "auto";
                                st.width = width + "%";
                                delete item.intLeft;
                            }
                        }

                        // Go to the next set of items
                        ids = [];
                        startIndex = -1;
                        endIndex = -1;
                    }
                }
            }
        }

        /**
            * For internal use only.
            * @private
            * Updates appointment data after creation/modification.
            * Used for header items.
            */

    }, {
        key: 'updateHeaderItem',
        value: function updateHeaderItem(appointment, addToItems) {
            var item = appointment.item;

            if (!item.visible) {
                return appointment;
            }

            var parts = [];
            var removed = [];

            var columns = this.getItemColumns(item);
            if (columns.length === 0) {
                return [];
            }
            var groupColumns = this.getItemGroupColumns(item);
            appointment.groupColumnIndex = groupColumns;

            if (!this.hasVisibleParts(item)) {
                removed.push(appointment);
            } else if (this.isComposite(item)) {
                var ist = DateTime.maxDate(item.startTime, this.headerItemsStartTime, false);
                var iet = DateTime.minDate(item.endTime, this.headerItemsEndTime, true);

                // has time parts but not group parts
                if (groupColumns.length === 1) {
                    for (var j = 0, m = columns.length - 1; j <= m; j++) {
                        var st = DateTime.maxDate(item.startTime, this._columns.items()[columns[j]].headerCell.startTime, false);
                        var et = DateTime.minDate(item.endTime, this._columns.items()[columns[j]].headerCell.endTime, true);
                        if (st.equals(et)) continue;

                        var partIndex = 0;

                        if (st.compareTo(item.startTime) === 1) partIndex = 1;
                        if (et.compareTo(item.endTime) === -1) partIndex = -1;
                        if (st.compareTo(item.startTime) === 1 && et.compareTo(item.endTime) === -1) partIndex = 0;

                        var scell = this.headerCells.items()[columns[j]];
                        var lcell = this.headerCells.items()[columns[j]];
                        var partData = {
                            prototype: appointment,
                            type: 'part',
                            cellIndex: scell.index,
                            cellsLength: lcell.index - scell.index + 1,
                            colIndex: scell.rowIndex,
                            isPartial: true,
                            partIndex: partIndex,
                            isHeader: true,
                            lastCellIndex: lcell.index,
                            startCellIndex: scell.index,
                            groupColumnIndex: appointment.groupColumnIndex
                        };
                        var part = new Appointment(partData);
                        part.composite = true;
                        parts.push(part);
                        removed.push(appointment);
                    }
                }
                // has time parts and group parts
                else if (groupColumns.length > 1) {
                        for (var i = 0, l = groupColumns.length; i < l; i++) {
                            var st = DateTime.maxDate(item.startTime, this._columns.items()[groupColumns[i]].headerCell.startTime, false);
                            var et = DateTime.minDate(item.endTime, this._columns.items()[groupColumns[i]].headerCell.endTime, true);
                            if (st.equals(et)) continue;

                            var partIndex = 0;

                            if (st.compareTo(item.startTime) === 1) partIndex = 1;
                            if (et.compareTo(item.endTime) === -1) partIndex = -1;
                            if (st.compareTo(item.startTime) === 1 && et.compareTo(item.endTime) === -1) partIndex = 0;

                            var scell = this.headerCells.items()[groupColumns[i]];
                            var lcell = this.headerCells.items()[groupColumns[i]];
                            var partData = {
                                prototype: appointment,
                                type: 'part',
                                cellIndex: scell.index,
                                cellsLength: lcell.index - scell.index + 1,
                                colIndex: scell.rowIndex,
                                isPartial: true,
                                partIndex: partIndex,
                                isHeader: true,
                                lastCellIndex: lcell.index,
                                startCellIndex: scell.index,
                                groupColumnIndex: appointment.groupColumnIndex[i]
                            };
                            var part = new Appointment(partData);
                            part.composite = true;
                            parts.push(part);
                            removed.push(appointment);
                        }
                    }
            }
            // has group parts but not time parts
            else if (groupColumns.length > 1) {
                    for (var i = 0, l = groupColumns.length; i < l; i++) {
                        var cell = this.headerCells.items()[groupColumns[i]];
                        var lcell = cell;
                        var partData = {
                            prototype: appointment,
                            type: 'part',
                            cellIndex: cell.index,
                            cellsLength: lcell.index - cell.index + 1,
                            colIndex: groupColumns[i],
                            isPartial: true,
                            partIndex: undefined,
                            isHeader: true,
                            lastCellIndex: lcell.index,
                            startCellIndex: cell.index,
                            groupColumnIndex: appointment.groupColumnIndex[i]
                        };
                        var part = new Appointment(partData);
                        part.composite = true;
                        parts.push(part);
                        removed.push(appointment);
                    }
                }
                // doesn't have parts
                else if (groupColumns.length === 1) {
                        var cell = this.headerCells.items()[columns[0]];
                        var lcell = cell;

                        appointment.lastCellIndex = lcell.index;
                        appointment.startCellIndex = cell.index;
                        appointment.cellsLength = lcell.index - cell.index + 1;
                        if (appointment.cellsLength < 1) {
                            appointment.cellsLength = 1;
                        }
                        appointment.cellIndex = cell.index;
                        appointment.colIndex = cell.rowIndex;
                        appointment.partIndex = undefined;
                        appointment.updateVisual();
                    }

            for (var i = 0; i < removed.length; i++) {
                this.removeAppointment(removed[i]);
            }

            if (addToItems !== false) this.items = this.items.concat(parts);

            for (var i = 0; i < parts.length; i++) {
                parts[i].updateVisual();
            }

            //return value is only used for recurrent composite items
            if (parts.length > 0) return parts;
            parts.push(appointment);
            return parts;
        }
    }, {
        key: 'updateDayItem',
        value: function updateDayItem(appointment, addToItems) {
            var item = appointment.item;
            if (!item.visible) {
                return appointment;
            }

            var parts = [];
            var removed = [];

            var columns = this.getItemColumns(item);
            if (columns.length === 0) {
                return [];
            }
            var groupColumns = this.getItemGroupColumns(item);
            appointment.groupColumnIndex = groupColumns;

            if (!this.hasVisibleParts(item)) {
                removed.push(appointment);
            } else if (this.isComposite(item)) {

                //has time parts but not group parts
                if (groupColumns.length === 1) {
                    for (var j = 0, m = columns.length - 1; j <= m; j++) {
                        var st = DateTime.maxDate(item.startTime, this._columns.items()[columns[j]].startTime, false);
                        var et = DateTime.minDate(item.endTime, this._columns.items()[columns[j]].endTime, true);
                        if (st.equals(et)) continue;

                        var partIndex = 0;

                        if (st.compareTo(item.startTime) === 1) partIndex = 1;
                        if (et.compareTo(item.endTime) === -1) partIndex = -1;
                        if (st.compareTo(item.startTime) === 1 && et.compareTo(item.endTime) === -1) partIndex = 0;

                        var scell = this.getTimeCell(st, false, columns[0]);
                        var lcell = this.getTimeCell(et, true, columns[0]);
                        // could happen for recurrent items if the view dates are not consecutive
                        if (scell === undefined || lcell === undefined) {
                            continue;
                        }
                        var partData = {
                            prototype: appointment,
                            type: 'part',
                            cellIndex: scell.index,
                            cellsLength: lcell.index - scell.index + 1,
                            colIndex: scell.rowIndex,
                            isPartial: true,
                            partIndex: partIndex,
                            lastCellIndex: lcell.index,
                            startCellIndex: scell.index,
                            groupColumnIndex: appointment.groupColumnIndex
                        };
                        var part = new Appointment(partData);
                        part.composite = true;
                        parts.push(part);
                        removed.push(appointment);
                    }
                }
                //has time parts and group parts
                else if (groupColumns.length > 1) {
                        for (var i = 0, l = groupColumns.length; i < l; i++) {
                            var st = DateTime.maxDate(item.startTime, this._columns.items()[groupColumns[i]].startTime, false);
                            var et = DateTime.minDate(item.endTime, this._columns.items()[groupColumns[i]].endTime, true);
                            if (st.equals(et)) continue;

                            var partIndex = 0;

                            if (st.compareTo(item.startTime) === 1) partIndex = 1;
                            if (et.compareTo(item.endTime) === -1) partIndex = -1;
                            if (st.compareTo(item.startTime) === 1 && et.compareTo(item.endTime) === -1) partIndex = 0;

                            var scell = this.getTimeCell(st, false, groupColumns[i]);
                            var lcell = this.getTimeCell(et, true, groupColumns[i]);
                            var partData = {
                                prototype: appointment,
                                type: 'part',
                                cellIndex: scell.index,
                                cellsLength: lcell.index - scell.index + 1,
                                colIndex: scell.rowIndex,
                                isPartial: true,
                                partIndex: partIndex,
                                lastCellIndex: lcell.index,
                                startCellIndex: scell.index,
                                groupColumnIndex: appointment.groupColumnIndex[i]
                            };
                            var part = new Appointment(partData);
                            part.composite = true;
                            parts.push(part);
                            removed.push(appointment);
                        }
                    }
            }
            //has group parts but not time parts
            else if (groupColumns.length > 1) {
                    for (var i = 0, l = groupColumns.length; i < l; i++) {
                        var cell = this.getTimeCell(item.startTime, false, groupColumns[i]);
                        if (item.startTime._date.valueOf() === item.endTime._date.valueOf()) {
                            var lcell = cell;
                        } else {
                            var lcell = this.getTimeCell(item.endTime, true, groupColumns[i]);
                        }
                        var partData = {
                            prototype: appointment,
                            type: 'part',
                            cellIndex: cell.index,
                            cellsLength: lcell.index - cell.index + 1,
                            colIndex: appointment.groupColumnIndex[i],
                            isPartial: true,
                            partIndex: undefined,
                            lastCellIndex: lcell.index,
                            startCellIndex: cell.index,
                            groupColumnIndex: appointment.groupColumnIndex[i]
                        };
                        var part = new Appointment(partData);
                        part.composite = true;
                        parts.push(part);
                        removed.push(appointment);
                    }
                }
                //doesn't have parts
                else if (groupColumns.length === 1) {
                        var cell = this.getTimeCell(item.startTime, false, columns[0]);
                        if (item.startTime._date.valueOf() === item.endTime._date.valueOf()) {
                            var lcell = cell;
                        } else {
                            var lcell = this.getTimeCell(item.endTime, true, columns[0]);
                        }
                        appointment.lastCellIndex = lcell.index;
                        appointment.startCellIndex = cell.index;
                        appointment.cellsLength = lcell.index - cell.index + 1;
                        if (appointment.cellsLength < 1) {
                            appointment.cellsLength = 1;
                        }
                        appointment.cellIndex = cell.index;
                        appointment.colIndex = cell.rowIndex;
                        appointment.partIndex = undefined;
                        appointment.updateVisual();
                    }

            for (var i = 0; i < removed.length; i++) {
                this.removeAppointment(removed[i]);
            }

            if (addToItems !== false) this.items = this.items.concat(parts);

            for (var i = 0; i < parts.length; i++) {
                parts[i].updateVisual();
            }

            //return value is only used for recurrent composite items
            if (parts.length > 0) return parts;
            parts.push(appointment);
            return parts;
        }

        /**
              * For internal use only.
              * @private
              */

    }, {
        key: 'updateItem',
        value: function updateItem(appointment, addToItems) {
            if (appointment.isHeader) return this.updateHeaderItem(appointment, addToItems);else return this.updateDayItem(appointment, addToItems);
        }
    }, {
        key: 'getColumnsByResource',
        value: function getColumnsByResource(resource) {
            var result = [];
            for (var i = 0, l = this._columns.count(); i < l; i++) {
                if (resource === this._columns.items()[i].resource) {
                    result.push(this._columns.items()[i]);
                }
            }
            return result;
        }
    }, {
        key: 'getItemStartColumn',
        value: function getItemStartColumn(item) {
            var itemStart = item.startTime.getDate().valueOf();
            for (var i = 0, l = this._columns.count(); i < l; i++) {
                var columnStart = this._columns.items()[i].date.valueOf();
                if (itemStart <= columnStart) {
                    if (this.grouped) {
                        if (item.hasResource(this._columns.items()[i].resource)) {
                            return i;
                        }
                    } else {
                        return i;
                    }
                }
            }
        }
    }, {
        key: 'getItemEndColumn',
        value: function getItemEndColumn(item, resource) {
            var index = this._columns.count() - 1;
            var itemEnd = item.endTime.getDate().valueOf();
            var columns = this.getColumnsByResource(resource);
            for (var i = 0, l = columns.length; i < l; i++) {
                var columnStart = columns[i].date.valueOf();

                if (itemEnd === columnStart) {
                    if (item.endTime._date.valueOf() > columns[i].startTime._date.valueOf()) {
                        return columns[i].index;
                    } else if (i > 0) {
                        return columns[i - 1].index;
                    } else {
                        return null;
                    }
                }
                if (itemEnd > columnStart) {
                    index = columns[i].index;
                }
            }
            return index;
        }

        /**
               * Gets the cell that corresponds to the specified time.
               * @param {Object} [time] The time to search for.
               * @param {Boolean} [isEndTime] true if the index of the first interval is returned when the time is the boundary between two consecutive intervals;
               false if the index of the second interval is contained.
               * @returns {Object} The cell that holds the specified time.
               */

    }, {
        key: 'getTimeCell',
        value: function getTimeCell(time, isEndTime, col) {
            if (col.length != undefined) col = col[0];

            if (col < 0 || col > this._columns.count() - 1) return null;
            if (time._date.valueOf() < this.dates[0].startTime._date.valueOf()) return null;
            if (time._date.valueOf() > this.dates[this.dates.length - 1].endTime._date.valueOf()) return null;
            var resource = null;
            if (col != null && this.resources != null && this.grouped) resource = this._columns.items()[col].resource;

            for (var i = 0, l = this._columns.count(); i < l; i++) {
                if (resource === this._columns.items()[i].resource) {
                    if (time._date.valueOf() >= this._columns.items()[i].startTime._date.valueOf() && (time._date.valueOf() < this._columns.items()[i].endTime._date.valueOf() || isEndTime && time._date.valueOf() === this._columns.items()[i].endTime._date.valueOf())) {

                        var index = i * this.rowsCount + Math.floor(DateTime.millisecondsBetween(time, this._columns.items()[i].startTime) / this.settings.cellTime.milliseconds);
                        if (index > this._columns.items()[i].cells.items()[this._columns.items()[i].cells.count() - 1].index) {
                            if (isEndTime && time.equals(this._columns.items()[i].cells.items()[this._columns.items()[i].cells.count() - 1].endTime)) return this.cells.items()[index - 1];else return null;
                        }
                        if (isEndTime && DateTime.isSameDate(time, this.cells.items()[index].startTime) && index > 0) {
                            index -= 1;
                        }
                        return this.cells.items()[index];
                    }
                }
            }
            return this.cells.items()[index];
        }

        /**
         * For internal use only.
         * @private
         * Returns an array of cells that correspond to the specified time and column.
         */

    }, {
        key: 'getTimeCells',
        value: function getTimeCells(startTime, endTime, isEndTime, col) {
            var startCell = null;
            var endCell = null;

            if (col.length != undefined) col = col[0];

            if (col < 0 || col > this._columns.count() - 1) return null;
            var resource = this._columns.items()[col].resource;
            var cells = this._columns.items()[col].cells;

            if (startTime.valueOf() < this.startTime.valueOf()) {
                startCell = cells.items()[0];
            } else if (startTime.valueOf() > this.endTime.valueOf()) {
                return [];
            } else {
                startCell = this.getTimeCell(startTime, false, col);
            }
            if (endTime !== null && typeof endTime !== "undefined" && typeof endTime._date !== "undefined") {
                if (endTime.valueOf() > this.endTime.valueOf()) {
                    endCell = cells.items()[cells.count() - 1];
                } else if (endTime.valueOf() < this.startTime.valueOf()) {
                    return [];
                } else {
                    endCell = this.getTimeCell(endTime, isEndTime, col);
                }
            } else {
                endCell = startCell;
            }

            if (startCell != null && endCell != null) {
                var result = [];
                if (startCell === endCell) {
                    result.push(startCell);
                } else {
                    for (var i = startCell.index; i < endCell.index; i++) {
                        var cell = this.cells.items()[i];
                        if (resource == null || resource && this.columns.items()[cell.columnIndex].resource == resource) {
                            result.push(cell);
                        }
                    }
                }
                return result;
            }
            return [];
        }

        /**
            * For internal use only.
            * @private
            * Returns an array of all column indexes the specified appointment belongs to.
            * Both group and time parts are included.
            */

    }, {
        key: 'getItemColumns',
        value: function getItemColumns(item) {
            var start = this.getItemStartColumn(item);
            if (start === undefined) {
                return [];
            }
            var resource = this._columns.items()[start].resource;
            var end = this.getItemEndColumn(item, resource);
            if (end == null || end < start) {
                end = start;
            }

            var result = [];
            for (var i = start; i <= end; i++) {
                if (this.grouped) {
                    if (this._columns.items()[i].resource === resource) {
                        if (result.indexOf(i) === -1) {
                            result.push(i);
                        }
                    }
                } else {
                    if (result.indexOf(i) === -1) {
                        result.push(i);
                    }
                }
            }
            return result;
        }

        /**
        * For internal use only.
        * @private
        * Returns an array of all group column indexes the specified appointment belongs to.
        * Only group parts are included.
        */

    }, {
        key: 'getItemGroupColumns',
        value: function getItemGroupColumns(item) {
            var result = [];
            var resource = null;

            if (!this.grouped || this.resources == null) {
                result.push(0);
            } else {
                for (var i = 0, l = this._columns.count(); i < l; i++) {
                    if (this.isItemInColumn(item, this._columns.items()[i])) {
                        if (item.hasResource(this._columns.items()[i].resource)) {
                            if (!this._columns.items()[i].resource.equals(resource)) {
                                result.push(i);
                                resource = this._columns.items()[i].resource;
                            }
                        }
                    }
                }
            }

            return result;
        }

        /**
        * For internal use only.
        * @private
        * Checks if the appointment belongs to the column.
        */

    }, {
        key: 'isItemInColumn',
        value: function isItemInColumn(item, column) {
            if (item.startTime >= column.startTime && item.startTime < column.endTime) return true;
            if (item.endTime > column.startTime && item.endTime <= column.endTime) return true;
            if (item.startTime < column.startTime && item.endTime >= column.endTime) return true;
            return false;
        }

        /**
        * For internal use only.
        * @private
        * Checks if the appointment belongs to more than one column.
        */

    }, {
        key: 'isComposite',
        value: function isComposite(item) {
            if (item.startTime._date.valueOf() == item.endTime._date.valueOf()) {
                return false;
            }
            if (item.allDayEvent) {
                if (item.startTime._date.valueOf() < this.headerItemsStartTime._date.valueOf()) return true;
                if (item.endTime._date.valueOf() > this.headerItemsEndTime._date.valueOf()) return true;

                var cols = this.getItemColumns(item);
                if (cols.length > 1) return true;
            } else {

                if (item.startTime._date.valueOf() < this.itemsStartTime._date.valueOf()) return true;
                if (item.endTime._date.valueOf() > this.itemsEndTime._date.valueOf()) return true;

                var cols = this.getItemColumns(item);
                if (cols.length > 1) return true;
                var startCell = this.getTimeCell(item.startTime, false, cols[0]);
                if (startCell == null) return true;
                var endCell = this.getTimeCell(item.endTime, true, cols[0]);
                if (endCell == null) return true;
            }

            return false;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'hasVisibleParts',
        value: function hasVisibleParts(item) {
            if (this.grouped && this.getItemGroupColumns(item).length == 0) return false;
            if (item.startTime._date.valueOf() >= this._columns.items()[0].startTime._date.valueOf() && item.startTime._date.valueOf() < this._columns.items()[this._columns.count() - 1].endTime._date.valueOf()) return true;
            if (item.endTime._date.valueOf() > this._columns.items()[0].startTime._date.valueOf() && item.endTime._date.valueOf() < this._columns.items()[this._columns.count() - 1].endTime._date.valueOf()) return true;
            if (item.startTime._date.valueOf() <= this._columns.items()[0].startTime._date.valueOf() && item.endTime._date.valueOf() >= this._columns.items()[0].endTime._date.valueOf()) return true;
            return false;
        }
    }, {
        key: 'getItemsInCell',
        value: function getItemsInCell(cell, items) {
            var result = [];
            for (var i = 0, l = items.length; i < l; i++) {
                if (items[i].startCellIndex == cell.index) result.push(items[i]);
            }
            return result;
        }
    }, {
        key: 'getHeaderType',
        value: function getHeaderType(element) {
            var h = this.getGroupHeader();
            if (h) {
                if (h.contains(element)) return HeaderType.Group;
            }

            h = this.getTimelineHeader();
            if (h) {
                if (h.contains(element)) return HeaderType.Timeline;
            }
            return get(Timetable.prototype.__proto__ || Object.getPrototypeOf(Timetable.prototype), 'getHeaderType', this).call(this, element);
        }

        /*Rendering*/

    }, {
        key: 'drawHeader',
        value: function drawHeader() {
            var result = null;
            var output = this.calendar.renderer;

            var header = document.createElement("div");
            header.className = "mfp-header";
            result = header;

            var corner = document.createElement("div");
            corner.className = "mfp-corner";
            corner.innerHTML = "&nbsp;";
            header.appendChild(corner);

            var d = this.drawColumnHeaders();
            header.appendChild(d);

            var fix = document.createElement("div");
            fix.className = "mfp-scrollfix";
            fix.innerHTML = "&nbsp;";
            header.appendChild(fix);

            return result;
        }
    }, {
        key: 'drawColumnHeaders',
        value: function drawColumnHeaders() {
            var result = null;
            var output = this.calendar.renderer;

            var header = document.createElement("div");
            header.className = "mfp-title";
            result = header;

            var table = document.createElement("table");
            table.className = "mfp-title-table";
            table.cellSpacing = 0;
            table.cellPadding = 0;
            header.appendChild(table);

            if (this._groupColumns > 0 && this.settings.reverseGrouping) {
                var g = this.drawGroupHeaders();
                table.appendChild(g);
            }

            if ((this.settings.headerStyle & MainHeaderStyle.Title) == MainHeaderStyle.Title) {
                var d = this.drawDateHeaders();
                table.appendChild(d);
            }

            if (this._groupColumns > 0 && !this.settings.reverseGrouping) {
                var g = this.drawGroupHeaders();
                table.appendChild(g);
            }

            if (this.settings.showDayHeader) {
                var tr = document.createElement("tr");
                tr.className = "mfp-item-row";
                table.appendChild(tr);

                for (var columnIndex = 0; columnIndex < this._totalColumns; columnIndex++) {

                    var td = document.createElement("td");
                    td.className = "mfp-item-cell";
                    td.innerHTML = "&nbsp;";
                    tr.appendChild(td);
                }

                var tr = document.createElement("tr");
                tr.className = "mfp-empty-row";
                table.appendChild(tr);

                for (var columnIndex = 0; columnIndex < this._totalColumns; columnIndex++) {
                    var td = document.createElement("td");
                    //  td.innerHTML = "&nbsp;"
                    tr.appendChild(td);
                }
            }

            if ((this.settings.headerStyle & MainHeaderStyle.Buttons) == MainHeaderStyle.Buttons) {
                var b = this.drawHeaderButtons();
                header.appendChild(b);
            }
            return result;
        }
    }, {
        key: 'drawDateHeaders',
        value: function drawDateHeaders() {
            var result = null;

            if (this._groupColumns > 0 && this.settings.reverseGrouping) {

                var tr = document.createElement("tr");
                tr.className = "mfp-group-row";
                result = tr;

                for (var group = 0; group < this._groupColumns; group++) {
                    for (var i = 0; i < this._dateColumns; i++) {
                        var td = document.createElement("td");
                        // td.className = "text";

                        if (this.calendar.showTooltips) td.title = this.settings.dates.items()[i].toString(this.formatInfo.dateFormats.longDate, this.formatInfo);

                        td.innerHTML = this.settings.dates.items()[i].toString(this.settings.titleFormat, this.formatInfo);
                        tr.appendChild(td);
                    }
                }
            } else {
                var tr = document.createElement("tr");
                tr.className = "mfp-header-row";
                result = tr;

                for (var i = 0; i < this._dateColumns; i++) {
                    var td = document.createElement("td");
                    // td.className = "text";

                    if (this.calendar.showTooltips) td.title = this.settings.dates.items()[i].toString(this.formatInfo.dateFormats.longDate, this.formatInfo);

                    if (this._groupColumns > 0) td.colSpan = this._groupColumns;

                    td.innerHTML = this.settings.dates.items()[i].toString(this.settings.titleFormat, this.formatInfo);
                    tr.appendChild(td);
                }
            }
            return result;
        }
    }, {
        key: 'drawHeaderButtons',
        value: function drawHeaderButtons() {
            var result = null;

            var d = document.createElement("div");
            d.className = "mfp-button-wrap";
            result = d;

            var b1 = document.createElement("a");
            DomUtils.addCssClass(b1, "mfp-button");
            DomUtils.addCssClass(b1, "mfp-button-prev");
            if (this.calendar.showTooltips) {
                b1.title = this.getButtonTooltip(-1);
            }
            var s = document.createElement("span");
            b1.appendChild(s);
            d.appendChild(b1);

            var b2 = document.createElement("a");
            DomUtils.addCssClass(b2, "mfp-button");
            DomUtils.addCssClass(b2, "mfp-button-next");
            if (this.calendar.showTooltips) {
                b2.title = this.getButtonTooltip(1);
            }
            s = document.createElement("span");
            b2.appendChild(s);
            d.appendChild(b2);

            return result;
        }
    }, {
        key: 'getButtonTooltip',
        value: function getButtonTooltip(f) {
            var s = "";

            for (var i = 0; i < this.settings.dates.count(); i++) {
                //s += this.settings.dates.items()[i].addDays(f * this.settings.scrollStep).toString(this.formatInfo.dateFormats.longDate, this.formatInfo);
                s += i !== this.settings.dates.count() - 1 ? "\n" : "";
            }

            return s;
        }
    }, {
        key: 'drawGroupHeaders',
        value: function drawGroupHeaders() {
            var result = null;

            var groupName = null;

            if (this._groupColumns > 0 && this.settings.reverseGrouping) {
                var tr = document.createElement("tr");
                tr.className = "mfp-header-row";
                result = tr;
                for (var i = 0; i < this._groupColumns; i++) {
                    groupName = this.calendar.getResourceName(this.calendar.groupResources.items()[i]);

                    var th = document.createElement("td");
                    th.className = "text";
                    if (this._groupColumns > 0) th.colSpan = this._dateColumns;

                    th.innerHTML = groupName || "&nbsp;";
                    tr.appendChild(th);
                }
            } else {
                var tr = document.createElement("tr");
                tr.className = "mfp-group-row";
                result = tr;
                for (var i = 0; i < this._dateColumns; i++) {
                    for (var group = 0; group < this._groupColumns; group++) {
                        groupName = this.calendar.getResourceName(this.calendar.groupResources.items()[group]);

                        var th = document.createElement("td");
                        th.className = "text";
                        th.innerHTML = groupName || "&nbsp;";

                        tr.appendChild(th);
                    }
                }
            }
            return result;
        }
    }, {
        key: 'drawContent',
        value: function drawContent() {

            var result = null;
            var output = this.calendar.renderer;

            var s = document.createElement("div");
            s.className = "mfp-scroll-container";
            result = s;

            var content = document.createElement("div");
            content.className = "mfp-content-wrap";
            s.appendChild(content);

            var t = this.drawTimeline(output);
            content.appendChild(t);

            // Days cell
            var schedule = document.createElement("div");
            schedule.className = "mfp-content";
            content.appendChild(schedule);

            var rowClass = "";

            for (var clIndx = 0; clIndx < this._totalColumns; clIndx++) {
                var column = document.createElement("div");
                column.className = "mfp-column";
                schedule.appendChild(column);

                for (var rIndx = 0; rIndx < this._totalCells; rIndx++) {
                    rowClass = "mfp-cell-wrap";
                    if (clIndx == 0) rowClass += " left";
                    if (clIndx == this._totalColumns - 1) rowClass += " right";
                    if (rIndx == 0) rowClass += " top";
                    if (rIndx == this._totalCells - 1) rowClass += " bottom";

                    var d = document.createElement("div");
                    column.appendChild(d);
                    d.className = rowClass;
                    d.style.zIndex = this._totalCells - rIndx;
                    d.style.height = this.settings.cellSize + "px";

                    var c = document.createElement("div");

                    c.className = "mfp-cell";

                    d.appendChild(c);
                }
            }

            return result;
        }
    }, {
        key: 'drawTimeline',
        value: function drawTimeline() {
            var result = null;

            var d;
            var endT = TimeSpan.fromMinutes(this.settings.realEndTime);

            var t = document.createElement("div");
            t.className = "mfp-header-timeline";
            t.cellPadding = 0;
            t.cellSpacing = 0;
            result = t;

            var ts = TimeSpan.fromMinutes(this.settings.startTime);
            var minutesCellCount = Math.round(60 / this.settings.cellTime.minutes);

            if (this.settings.groupHours && this._canGroupHour) {

                var isAMPM = false;

                while (ts.ticks < endT.ticks) {
                    isAMPM = false;
                    d = new DateTime(ts.milliseconds);

                    // hour cell
                    var c1 = document.createElement("div");
                    c1.className = "mfp-hour";
                    c1.style.height = this.settings.cellSize + "px";
                    t.appendChild(c1);

                    if (this.calendar.showTooltips) c1.title = d.toString(this.formatInfo.dateFormats.longTime, this.formatInfo);

                    var s = document.createElement("span");

                    if (this.settings.twelveHourFormat) s.innerHTML = d.toString("h ", this.formatInfo).trim();else s.innerHTML = d.toString("H ", this.formatInfo).trim();

                    var c = document.createElement("div");
                    c.className = "mfp-group-time";
                    c1.appendChild(c);

                    // first minute cell
                    var c2 = document.createElement("div");

                    if (this.settings.twelveHourFormat && ts.subtract(this.settings.cellTime).hours !== ts.hours && (ts.hours == 0 || ts.hours == 12) || ts.equals(TimeSpan.fromMinutes(this.settings.startTime)) && this.settings.showAM) {
                        isAMPM = true;
                        c2.className = "mfp-AMPM";
                    } else {
                        c2.className = "mfp-minute";
                    }

                    if (this.calendar.showTooltips) c2.title = d.toString(this.formatInfo.dateFormats.longTime, this.formatInfo);

                    if (isAMPM) c2.innerHTML = d.toString("tt", this.formatInfo).trim();else c2.innerHTML = this.getMinutesText(d);

                    c.appendChild(c2);

                    ts = ts.add(this.settings.cellTime);
                    d = new DateTime(ts.milliseconds);

                    // other minute cells
                    for (var i = 1; i < minutesCellCount; i++) {

                        var c3 = document.createElement("div");
                        c3.className = "mfp-minute";
                        if (this.calendar.showTooltips) c3.title = new DateTime(ts.milliseconds).toString(this.formatInfo.dateFormats.longTime, this.formatInfo);

                        c.appendChild(c3);

                        if (this.settings.showMinutes) c3.innerHTML = this.getMinutesText(new DateTime(ts.milliseconds));else c3.innerHTML = "&nbsp;";

                        ts = ts.add(this.settings.cellTime);
                        d = new DateTime(ts.milliseconds);
                    }

                    c1.appendChild(s);
                }
            } else {
                while (ts.ticks < endT.ticks) {
                    d = new DateTime(ts.milliseconds);

                    var c = document.createElement("div");
                    c.className = "mfp-time";
                    t.appendChild(c);

                    if (this.calendar.showTooltips) c.title = d.toString(this.formatInfo.dateFormats.longTime, this.formatInfo);
                    var h = d.toString(this.settings.generalFormat, this.formatInfo).trim();
                    c.style.height = this.settings.cellSize + "px";
                    c.innerHTML = h;

                    ts = ts.add(this.settings.cellTime);
                    d = new DateTime(ts.milliseconds);
                }
            }

            return result;
        }
    }, {
        key: 'getMinutesText',
        value: function getMinutesText(time) {
            return time.toString("mm", this.formatInfo).trim();
        }
        /*End Render*/

    }, {
        key: 'cells',
        get: function get$$1() {
            var result = new List();
            this._columns.forEach(function (t) {
                result.addRange(t.cells.items());
            }, this);
            return result;
        }
    }, {
        key: 'headerCells',
        get: function get$$1() {
            var result = new List();
            this._columns.forEach(function (t) {
                result.add(t.headerCell);
            }, this);
            return result;
        }
    }, {
        key: 'dates',
        get: function get$$1() {
            var result = [];
            this._columns.forEach(function (t) {
                if (result.indexOf(t.date) === -1) result.push(t);
            }, this);
            return result;
        }
    }, {
        key: 'groupResources',
        get: function get$$1() {
            if (this.grouped && this.settings.reverseGrouping) {
                var result = [];
                this._columns.forEach(function (t) {
                    result.push(t.resource);
                }, this);
                return result;
            }
            return this.calendar.groupResources.items();
        }
    }, {
        key: 'orientation',
        get: function get$$1() {
            return Orientation.Vertical;
        }
    }, {
        key: 'cssClass',
        get: function get$$1() {
            return "mfp-timetable-view";
        }
    }, {
        key: 'cueCells',
        get: function get$$1() {
            var row = this.getHeader().querySelector(".mfp-empty-row");
            if (row) return row.childNodes;
            return [];
        }
    }]);
    return Timetable;
}(Cell);

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* For internal use only.
* @private
*/

var HorizontalTimetable = function (_Cell) {
    inherits(HorizontalTimetable, _Cell);

    function HorizontalTimetable(calendar) {
        classCallCheck(this, HorizontalTimetable);

        var _this = possibleConstructorReturn(this, (HorizontalTimetable.__proto__ || Object.getPrototypeOf(HorizontalTimetable)).call(this, calendar));

        _this._settings = _this.calendar.timetableSettings;

        _this._columns = new List();

        _this.initVars();

        _this._dragging = false;
        _this._resizing = false;
        _this._selecting = false;
        _this._selectionPaused = false;

        _this.items = [];
        return _this;
    }

    createClass(HorizontalTimetable, [{
        key: 'initVars',
        value: function initVars() {

            if (this.settings.dates.count() === 0) {
                var d = this.calendar.date;
                this.settings.dates.add(new DateTime(Date.UTC(d.year, d.month, d.day, 0, 0, 0)));
            }

            this._groupColumns = 0;
            this._dateColumns = this.settings.dates.count();
            if (this.calendar.realGroupType !== GroupType.None) this._groupColumns = this.calendar.groupResources.count();

            this._totalColumns = this._groupColumns == 0 ? this._dateColumns : this._dateColumns * this._groupColumns;

            var columnTime = TimeSpan.fromMinutes(this.settings.realEndTime - this.settings.startTime);
            this._totalCells = Math.floor(columnTime.ticks / this.settings.cellTime.ticks);
            if (columnTime.ticks % this.settings.cellTime.ticks !== 0) this._totalCells++;

            if (this.settings.cellTime.minutes > 0 && this.settings.cellTime.minutes <= 60 && this.settings.cellTime.minutes - this.settings.cellTime.minutes === 0 && this.settings.startTime % 60 === 0) {
                this._canGroupHour = 60 % this.settings.cellTime.minutes === 0;
                if (columnTime.minutes % 60 !== 0) this._canGroupHour = false;
            } else this._canGroupHour = false;

            this.createColumns();
        }
    }, {
        key: 'createColumn',
        value: function createColumn(date, index, resource) {
            var d = date.clone();

            var col = new ViewColumn(index, d, DateTime.addMinutes(d, this.settings.startTime), DateTime.addMinutes(d, this.settings.endTime));
            col.resource = resource;

            var headerCell = new ViewCell();
            headerCell.startTime = d;
            headerCell.endTime = DateTime.addTicksToDate(d, DateTime.MillisPerDay);
            headerCell.resource = resource;
            headerCell.index = index;
            headerCell.columnIndex = index;
            headerCell.isHeader = true;

            col.headerCell = headerCell;

            return col;
        }
    }, {
        key: 'createColumns',
        value: function createColumns() {

            this._columns = new ObservableCollection();

            var i = 0;

            if (this._groupColumns > 0) {
                if (this.settings.reverseGrouping) {
                    for (var resourceIndex = 0; resourceIndex < this._groupColumns; resourceIndex++) {
                        for (var dateIndex = 0; dateIndex < this._dateColumns; dateIndex++) {
                            var col = this.createColumn(this.settings.dates.items()[dateIndex], i, this.resources[resourceIndex]);
                            this._columns.add(col);
                            i++;
                        }
                    }
                } else {
                    for (var dateIndex = 0; dateIndex < this._dateColumns; dateIndex++) {
                        for (var resourceIndex = 0; resourceIndex < this._groupColumns; resourceIndex++) {
                            var col = this.createColumn(this.settings.dates.items()[dateIndex], i, this.resources[resourceIndex]);
                            this._columns.add(col);
                            i++;
                        }
                    }
                }
            } else {
                this.settings.dates.forEach(function (t) {
                    var d = new DateTime(Date.UTC(t.year, t.month, t.day, 0, 0, 0));
                    var col = this.createColumn(t, i, null);
                    this._columns.add(col);
                    i++;
                }, this);
            }

            this.startTime = this.itemsStartTime = this._columns.items()[0].startTime;
            this.endTime = this.itemsEndTime = this._columns.items()[this._columns.count() - 1].endTime;

            this.headerItemsStartTime = this.headerCells.items()[0].startTime;
            this.headerItemsEndTime = this.headerCells.items()[this.headerCells.count() - 1].endTime;

            this.rowsCount = this._totalCells;
            for (var i = 0, l = this._totalColumns; i < l; i++) {
                this.skipNext = 0;
                this.skipped = false;
                var col = this._columns.items()[i];

                for (var k = 0, m = this._totalCells; k < m; k++) {

                    if (this.skipNext > 0 && k <= this.skipNext) {
                        var cst = this.addUnits(col.startTime, k % this.rowsCount);
                        var cet = this.addUnits(col.startTime, k % this.rowsCount + 1);
                    } else {
                        var startTime = this.addUnits(col.startTime, k % this.rowsCount);
                        var endTime = this.addUnits(col.startTime, k % this.rowsCount + 1);
                    }
                    if (endTime._date.valueOf() > col.endTime._date.valueOf()) {
                        endTime = this._columns.items()[i].endTime;
                    }
                    var cell = new ViewCell();
                    cell.startTime = startTime;
                    cell.endTime = endTime;
                    cell.resource = this.resources != null && this.grouped ? col.resource : null;
                    cell.index = k + this.rowsCount * i;
                    cell.columnIndex = i;
                    col.cells.add(cell);
                }
            }
        }

        /* Dom */

    }, {
        key: 'getScroller',
        value: function getScroller() {
            if (!this.Dom.scroller) {
                this.Dom.scroller = this.calendar.getElement().querySelector("div.mfp-scroll-container");
            }
            return this.Dom.scroller;
        }
    }, {
        key: 'getContainer',
        value: function getContainer() {
            return this.getElement();
        }
    }, {
        key: 'getHeaderItemsCells',
        value: function getHeaderItemsCells() {
            if (!this.Dom.headerItemsCells) {
                this.Dom.headerItemsCells = this.getHeader().querySelectorAll("td.mfp-item-cell");
            }
            return this.Dom.headerItemsCells;
        }
    }, {
        key: 'getTimelineHeader',
        value: function getTimelineHeader() {
            if (!this.Dom.timeline) {
                this.Dom.timeline = this.calendar.getElement().querySelector("div.mfp-header-timeline");
            }
            return this.Dom.timeline;
        }
    }, {
        key: 'getGroupHeader',
        value: function getGroupHeader() {
            if (!this.Dom.groupHeader) {
                this.Dom.groupHeader = this.getHeader().querySelector("td.mfp-group-row");
            }
            return this.Dom.groupHeader;
        }
    }, {
        key: 'getContent',
        value: function getContent() {
            if (!this.Dom.content) {
                this.Dom.content = this.calendar.getElement().querySelector("div.mfp-content");
            }
            return this.Dom.content;
        }
    }, {
        key: 'getRows',
        value: function getRows() {
            return this.calendar.getElement().querySelectorAll('div.week');
        }
    }, {
        key: 'getBgCells',
        value: function getBgCells() {
            return this.calendar.getElement().querySelectorAll('div.mfp-cell-wrap');
        }
    }, {
        key: 'detach',
        value: function detach() {
            this.getHeader().removeEventListener("click", this.headerClickHandler);
            if (this.getGroupHeader()) this.getGroupHeader().removeEventListener("click", this.headerClickHandler);
            if (this.getTimelineHeader()) this.getTimelineHeader().removeEventListener("click", this.headerClickHandler);

            var buttons = this.getHeader().querySelectorAll("a.mfp-button");
            for (var i = 0; i < buttons.length; i++) {
                buttons[i].removeEventListener('click', this.buttonClickHandler);
            }
        }
    }, {
        key: 'attach',
        value: function attach() {
            var bgTables = this.getElement().querySelectorAll("div.mfp-column");
            var headerCells = this.getHeaderItemsCells();

            for (var i = 0; i < this._columns.count(); i++) {
                var col = this._columns.items()[i];
                col.bgTable = bgTables[i];
                col.headerCell.bgCell = headerCells[i];

                var bgCells = col.bgTable.querySelectorAll("div.mfp-cell-wrap");

                for (var k = 0, m = col.cells.count(); k < m; k++) {
                    var cell = col.cells.items()[k];
                    cell.bgCell = bgCells[k];
                }
            }

            this.clear();
            this.init();

            this.getHeader().addEventListener("click", this.headerClickHandler);
            if (this.getGroupHeader()) this.getGroupHeader().addEventListener("click", this.headerClickHandler);
            if (this.getTimelineHeader()) this.getTimelineHeader().addEventListener("click", this.headerClickHandler);

            var buttons = this.getHeader().querySelectorAll("a.mfp-button");
            for (var i = 0; i < buttons.length; i++) {
                buttons[i].addEventListener('click', this.buttonClickHandler);
            }
        }
    }, {
        key: 'getCellAt',
        value: function getCellAt(x, y, resource) {
            var cursor = DomUtils.getCursorPosition({ clientX: x, clientY: y });
            var isInHeader = DomUtils.isPointInBounds(cursor, this.getHeaderBounds());
            var i = this.getCellIndexAt(x, y, resource);
            if (isInHeader) return this.headerCells.items()[i];else return this.cells.items()[i];
        }
    }, {
        key: 'getCellIndexAt',
        value: function getCellIndexAt(x, y, resource) {
            if (!this.cellWidth) this.getDimensions();

            var cursor = DomUtils.getCursorPosition({ clientX: x, clientY: y });
            var isInSchedule = DomUtils.isPointInBounds(cursor, this.getScheduleBounds());
            var isInHeader = DomUtils.isPointInBounds(cursor, this.getHeaderBounds());
            var point = null;
            var cell = null;
            if (isInHeader) {
                point = DomUtils.getPointInBounds(cursor, this.getHeaderBounds());
                cell = this.headerCells.items()[parseInt(point.y / this.cellHeight)];

                if (cell) {
                    if (this.grouped && resource && cell.resource != resource) {
                        var colIndex = this.getColumnIndexByTime(cell.startTime._date.valueOf(), false, resource);
                        var cell = this.headerCells.items()[colIndex];
                    }
                    return cell.index;
                }
            } else if (isInSchedule) {
                point = DomUtils.getPointInBounds(cursor, this.getScheduleBounds());
                //  point.y += this.getScroller().scrollTop;
                if (point.y >= this.cellHeight * this.rowsCount) return null;
                //  point.x += this.getScroller().scrollLeft;
                var col = parseInt(point.x / this.cellWidth);
                var row = parseInt(point.y / this.cellHeight);
                cell = this.cells.items()[col + this.rowsCount * row];

                if (cell) {
                    if (this.grouped && resource && cell.resource != resource) {
                        var colIndex = this.getColumnIndexByTime(cell.startTime._date.valueOf(), false, resource);
                        var cell = this.getTimeCell(cell.startTime, false, colIndex);
                    }
                    return cell.index;
                }
            }
            return null;
        }
    }, {
        key: 'getColumnIndexByTime',
        value: function getColumnIndexByTime(time, isEndTime, resource) {
            if (time != null && time.getTime != null) time = time.getTime();
            for (var i = 0, l = this._columns.count(); i < l; i++) {
                var c = this._columns.items()[i];
                if (resource === c.resource) {
                    var colStart = c.headerCell.startTime._date.valueOf();
                    var colEnd = c.headerCell.endTime._date.valueOf();
                    if (time >= colStart && time <= colEnd && isEndTime) return i;
                    if (time >= colStart && time < colEnd) return i;
                }
            }
            return -1;
        }
    }, {
        key: 'addUnits',
        value: function addUnits(date, count) {
            var result;
            var r = new DateTime(DateTime.addMilliseconds2(new Date(date._date.valueOf()), count * this.settings.cellTime.milliseconds));
            result = DateTime.addMilliseconds(date, count * this.settings.cellTime.milliseconds);
            if (result._date.valueOf() < r._date.valueOf()) {
                return r;
            }
            if (result._date.getHours() - r._date.getHours() > 1) {
                this.skipNext = 3600000 + count * this.settings.cellTime.milliseconds;
            } else {
                if (this.skipNext > 0) {
                    this.skipped = true;
                }
                if (this.skipNext === 0 && this.skipped) {
                    result._date.setHours(result._date.getHours() - 1);
                }
                this.skipNext = 0;
            }
            return result;
        }
    }, {
        key: 'getScheduleBounds',
        value: function getScheduleBounds() {
            return DomUtils.getBounds(this.getContent());
        }
    }, {
        key: 'getHeaderBounds',
        value: function getHeaderBounds() {
            var header = this.getHeader();

            if (!header) return null;
            var titles = header.querySelectorAll("div.mfp-title");
            if (titles.length === 0) return { x: 0, y: 0, width: 0, height: 0 };
            var bounds = DomUtils.getBounds(titles[0]);

            var titleRow = header.querySelector("td.mfp-header-row");
            if (titleRow) {
                var width = titleRow.offsetWidth;
                bounds.x += width;
                bounds.width -= width;
            }
            return bounds;
        }
    }, {
        key: 'getAllItemsInCell',
        value: function getAllItemsInCell(cell) {
            var result = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.isItemInColumn(this.items[i].item, this.columns.items()[cell.columnIndex])) {
                    if (this.items[i].startCellIndex <= cell.index && this.items[i].lastCellIndex >= cell.index) {
                        result.push(this.items[i]);
                    }
                }
            }
            return result;
        }

        /* Interactions */

    }, {
        key: 'startSelect',
        value: function startSelect(e) {
            var cursor = DomUtils.getCursorPosition(e);
            var isInHeader = DomUtils.isPointInBounds(cursor, this.getHeaderBounds());

            var cell = this.getCellIndexAt(e.clientX, e.clientY, this.calendar.selectManager.resource);
            this.startCol = this.endCol = this.cells.items()[cell].columnIndex;
            this.startCell = cell;

            if (isInHeader) {
                this.startCol = this.endCol = cell;
                var cell = cell * this.rowsCount;
                this.startCell = cell;
            }
            this.calendar.selectManager.start = cell;
            this.calendar.selectManager.end = cell;
            if (isInHeader) {
                this.calendar.selectManager.end = cell + this.rowsCount - 1;
            }
            this.calendar.selectManager.isInHeader = isInHeader;
        }
    }, {
        key: 'doSelect',
        value: function doSelect(e) {
            if (this.calendar.selectManager.start != null) {
                var cursor = DomUtils.getCursorPosition(e);
                var isInHeader = DomUtils.isPointInBounds(cursor, this.getHeaderBounds());

                if (isInHeader) {
                    var col = this.getCellIndexAt(e.clientX, e.clientY);
                    if (col != null) {
                        if (this.calendar.selectManager.resource && this._columns.items()[col].resource !== this.calendar.selectManager.resource) return;

                        this.endCol = col;
                        var sc = Math.min(this.startCol, this.endCol);
                        var ec = Math.max(this.startCol, this.endCol);
                        var start = sc * this.rowsCount;
                        var end = ec * this.rowsCount + this.rowsCount - 1;

                        this.calendar.selectManager.start = start;
                        this.calendar.selectManager.end = end;
                        this.calendar.selectManager.isInHeader = true;
                    }
                } else {
                    var cell = this.getCellIndexAt(e.clientX, e.clientY);
                    if (cell != null) {
                        if (this.calendar.selectManager.resource && this.cells.items()[cell].resource !== this.calendar.selectManager.resource) return;
                    }

                    if (this.calendar.selectManager.isInHeader) {
                        this.calendar.selectManager.start = this.startCell;
                    }

                    cell = this.getCellIndexAt(e.clientX, e.clientY, this.calendar.selectManager.resource);
                    if (cell != null) {
                        this.endCol = this.cells.items()[cell].columnIndex;

                        var start = this.calendar.selectManager.start;
                        var end = cell;
                        this.calendar.selectManager.start = start;
                        this.calendar.selectManager.end = end;
                        this.calendar.selectManager.isInHeader = false;
                    }
                }
            }
        }
    }, {
        key: 'endSelection',
        value: function endSelection(e, start, end, resource) {
            var cursor = DomUtils.getCursorPosition(e);
            var isInHeader = DomUtils.isPointInBounds(cursor, this.getHeaderBounds());

            var st = this.cells.items()[start].startTime;
            var et = this.cells.items()[end].endTime;

            if (isInHeader) {
                var st = this.headerCells.items()[this.cells.items()[start].columnIndex].startTime;
                var et = this.headerCells.items()[this.cells.items()[end].columnIndex].endTime;
            }
            var item = new DummyItem(st, et, '', isInHeader, this.calendar, resource);
            get(HorizontalTimetable.prototype.__proto__ || Object.getPrototypeOf(HorizontalTimetable.prototype), 'endSelection', this).call(this, item);
        }
    }, {
        key: 'updateDrag',
        value: function updateDrag(appointment, cell, e) {
            if (cell) {
                var cursor = DomUtils.getCursorPosition(e);
                var isInHeader = DomUtils.isPointInBounds(cursor, this.getHeaderBounds());
                var milestone = appointment.isMilestone;

                if (this.headerCells.contains(cell) && !appointment.isHeader) {
                    appointment.item._allDayEvent = true;
                    appointment.isHeader = true;
                    appointment.cellsLength = 1;
                    appointment.item._startTime = cell.startTime;
                    appointment.item._endTime = cell.endTime;
                    appointment.length = appointment.getLength(appointment.item);
                    appointment.recreateVisual();
                    this.itemData.startTimeOffset2 = 0;
                    this.itemData.endTimeOffset2 = 0;
                } else if (!this.headerCells.contains(cell) && appointment.isHeader) {
                    appointment.item._allDayEvent = false;
                    appointment.isHeader = false;
                    appointment.cellsLength = 1;
                    appointment.item._startTime = cell.startTime;
                    appointment.item._endTime = cell.endTime;
                    appointment.length = appointment.getLength(appointment.item);
                    appointment.recreateVisual();
                    this.itemData.startTimeOffset2 = 0;
                    this.itemData.endTimeOffset2 = 0;
                } else {
                    if (appointment.partIndex === 1) {
                        appointment.item._endTime = DateTime.addTicksToDate(cell.endTime, this.itemData.endTimeOffset2);
                        appointment.item._startTime = DateTime.addTicksToDate(appointment.item.endTime, -appointment.length);
                    } else {
                        appointment.item._startTime = DateTime.addTicksToDate(cell.startTime, this.itemData.startTimeOffset2);
                        if (milestone) appointment.item._endTime = appointment.item.startTime;else appointment.item._endTime = DateTime.addTicksToDate(appointment.item.startTime, appointment.length);
                    }
                }

                appointment.item.setResource(cell.resource);
                appointment.removeParts();

                if (isInHeader) var parts = this.updateHeaderItem(appointment);else var parts = this.updateDayItem(appointment);

                for (var k = 0, l = parts.length; k < l; k++) {
                    if (parts[k] !== undefined) this.placeItem(parts[k]);
                }
                appointment = parts[appointment.partIndex === 1 ? parts.length - 1 : 0];

                this.dragContainer.data.appointment = appointment;
                this.dragContainer.data.item = appointment.item;
                this.updateLayout();
            }
        }
    }, {
        key: 'endItemDrag',
        value: function endItemDrag(e, resource) {

            var item = this.itemData.item;
            var app = this.itemData.appointment;

            var cell = this.getCellAt(e.clientX, e.clientY, resource);

            if (cell) {
                var startTime = this.itemData.item.startTime.clone();
                var endTime = this.itemData.item.endTime.clone();
                var resource = cell.resource;

                this.itemData.item._startTime = this.itemData.startTime;
                this.itemData.item._endTime = this.itemData.endTime;
                this.itemData.item.setResource(this.itemData.itemStartCell.resource);

                get(HorizontalTimetable.prototype.__proto__ || Object.getPrototypeOf(HorizontalTimetable.prototype), 'endItemDrag', this).call(this, { startTime: startTime, endTime: endTime, resource: resource });
            } else {
                this.cancelInteraction(ItemModifyAction.Drag);
            }
        }

        /**
              * For internal use only.
              * @private
              * Called upon finishing a resize interaction.
              */

    }, {
        key: 'endItemResize',
        value: function endItemResize(e) {

            var item = this.itemData.item;
            var app = this.itemData.appointment;
            var resource = this.itemData.itemStartCell.resource;

            var cell = this.getCellAt(e.clientX, e.clientY, resource);
            if (cell) {
                var startTime = this.itemData.item.startTime.clone();
                var endTime = this.itemData.item.endTime.clone();
                var resource = cell.resource;

                this.itemData.item._startTime = this.itemData.startTime;
                this.itemData.item._endTime = this.itemData.endTime;
                this.itemData.item.setResource(this.itemData.itemStartCell.resource);

                get(HorizontalTimetable.prototype.__proto__ || Object.getPrototypeOf(HorizontalTimetable.prototype), 'endItemResize', this).call(this, { startTime: startTime, endTime: endTime, resource: resource });
            } else {
                this.cancelInteraction(ItemModifyAction.Resize);
            }
        }
    }, {
        key: 'cancelInteraction',
        value: function cancelInteraction(action) {

            var prototype = this.calendar.getAppointmentById(this.itemData.item.id, this.itemData.item.occurrenceIndex);

            if (prototype.isHeader != this.itemData.isHeader) {
                prototype.isHeader = this.itemData.isHeader;
                prototype.item._allDayEvent = this.itemData.isHeader;
                prototype.length = this.itemData.length;
                prototype.recreateVisual();
            }

            var startTime = this.itemData.startTime;
            var endTime = this.itemData.endTime;
            var resource = this.itemData.itemStartCell.resource;

            if (action == ItemModifyAction.Drag) get(HorizontalTimetable.prototype.__proto__ || Object.getPrototypeOf(HorizontalTimetable.prototype), 'endItemDrag', this).call(this, { startTime: startTime, endTime: endTime, resource: resource });else get(HorizontalTimetable.prototype.__proto__ || Object.getPrototypeOf(HorizontalTimetable.prototype), 'endItemResize', this).call(this, { startTime: startTime, endTime: endTime, resource: resource });

            /*  prototype.item.startTime = startTime;
              prototype.item.endTime = endTime;
              prototype.item.setResource(resource);
                  prototype.removeParts();
              this.updateItem(prototype, false);
                  this._selecting = false;
              this._dragging = false;
                  this.itemData.appointment.element.style.cursor = 'pointer';
              this.getContent().style.cursor = 'default';
                  this.drag.dispose();
              this.dragContainer.dispose();
              this.itemData = null;*/
        }

        /**
          * For internal use only.
          * @private
          * Updates appointment and layout during resize operation.
          */

    }, {
        key: 'updateResize',
        value: function updateResize(appointment, cell, e) {
            var cursor = DomUtils.getCursorPosition(e);
            var isInHeader = DomUtils.isPointInBounds(cursor, this.getHeaderBounds());
            var ci = cell.index;
            var si = this.resizeStartCell.index;
            var ei = this.resizeLastCell.index;

            if (this.itemData.handle === 'start') {
                if (ci < si) {
                    var s = cell;
                    var e = this.resizeLastCell;
                } else {
                    if (ci < ei) {
                        var s = cell;
                        var e = this.resizeLastCell;
                    } else {
                        var s = this.resizeLastCell;
                        var e = cell;
                    }
                }
            }

            if (this.itemData.handle === 'end') {
                if (ci > ei) {
                    var s = this.resizeStartCell;
                    var e = cell;
                } else {
                    if (ci > si) {
                        var s = this.resizeStartCell;
                        var e = cell;
                    } else {
                        var s = cell;
                        var e = this.resizeStartCell;
                    }
                }
            }

            var startCell;
            if (!s.isHeader && !e.isHeader || s.isHeader && e.isHeader) startCell = s.index < e.index ? s : e;else if (!s.isHeader) startCell = s.columnIndex <= e.index ? s : e;else if (!e.isHeader) startCell = s.index < e.columnIndex ? s : e;
            var endCell = startCell === s ? e : s;

            if (this.grouped && this.reverseGrouping && startCell.resource !== endCell.resource) {
                return;
            }

            if (this.itemData.handle === 'start') appointment.item._startTime = startCell.startTime;

            if (this.itemData.handle === 'end') appointment.item._endTime = endCell.endTime;

            if ((appointment.getLength(appointment.item) >= this.dayLength || isInHeader) && !appointment.isHeader) {
                appointment.item._allDayEvent = true;
                appointment.isHeader = true;
                appointment.cellsLength = 1;
                appointment.length = appointment.getLength(appointment.item);
                appointment.recreateVisual();
                isInHeader = true;
            }
            if (appointment.getLength(appointment.item) < this.dayLength && appointment.isHeader) {
                appointment.item._allDayEvent = false;
                appointment.isHeader = false;
                appointment.length = appointment.getLength(appointment.item);
                appointment.cellsLength = appointment.length / this.cellTime;
                appointment.recreateVisual();
                isInHeader = false;
            }
            appointment.item.setResource(this.itemData.itemStartCell.resource);
            appointment.removeParts();

            if (appointment.isHeader) var parts = this.updateHeaderItem(appointment);else var parts = this.updateDayItem(appointment);

            for (var i = 0, l = parts.length; i < l; i++) {
                this.placeItem(parts[i]);
            }
            if (this.itemData.handle === 'end') {
                appointment = parts[parts.length - 1];
            } else {
                appointment = parts[0];
            }
            this.resizeContainer.data.appointment = appointment;
            this.updateLayout();
        }

        /* Item placement */

    }, {
        key: 'getDimensions',
        value: function getDimensions() {
            var cell = this.getContent().querySelectorAll("div.mfp-cell-wrap")[0];
            this.cellWidth = cell.offsetWidth;
            this.cellHeight = cell.offsetHeight;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'clear',
        value: function clear() {
            DomUtils.removeNodes(this.getElement().querySelectorAll('.mfp-item-wrap'));
            DomUtils.removeNodes(this.getContent().querySelectorAll('.mfp-item-cell'));
        }
    }, {
        key: 'init',
        value: function init() {
            if (!this.cellWidth) this.getDimensions();

            this.getAllItems();

            this.placeItems();
            this.updateLayout();

            if (this.calendar.itemSettings.showItems && this.settings.showDayHeader) {
                this.getCues();
                this.createCues();
            }
        }
    }, {
        key: 'placeItems',
        value: function placeItems() {
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].isHeader && !this.settings.showDayHeader) continue;
                this.placeItem(this.items[i]);
            }
        }
    }, {
        key: 'placeItem',
        value: function placeItem(appointment) {
            var wrapper = this.getItemCell(appointment);
            if (wrapper != null) {

                // Remove empty text string
                if (wrapper.nodeName.toUpperCase() === "TD" && wrapper.innerHTML === "&nbsp;") wrapper.innerHTML = "";

                wrapper.appendChild(appointment.element.parentNode);
            }
            if (appointment.isHeader) {
                appointment.element.style.margin = this.calendar.itemSettings.spacing + 'px';
                if (this.calendar.itemSettings.spacing > 0) {
                    appointment.element.style.marginRight = '0px';
                }
            } else {
                appointment.updateTimeIndicator();
                appointment.element.style.width = appointment.cellsLength * this.cellWidth + 'px';
                if (this.calendar.itemSettings.spacing > 0) {
                    appointment.element.childNodes[0].style.marginBottom = this.calendar.itemSettings.spacing + 'px';
                }
            }
        }

        /*Cell.getCues override */

    }, {
        key: 'getCues',
        value: function getCues() {
            this.cues = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                var item = this.items[i];
                if (!item.isHeader) {
                    continue;
                }

                var row = this.getHeaderItemRow(item);

                if (row >= this.settings.maxItems) {
                    var cells = this.getItemCueCells(item);
                    for (var k = 0; k < cells.length; k++) {
                        if (this.cues.indexOf(cells[k]) === -1) this.cues.push(cells[k]);
                    }
                    item.hidden = true;
                    item.element.parentNode.style.visibility = 'hidden';
                    item.element.parentNode.style.display = 'none';
                } else {
                    item.hidden = false;
                    item.element.parentNode.style.visibility = 'visible';
                    item.element.parentNode.style.display = 'block';
                }
            }
        }
    }, {
        key: 'getHeaderItemRow',
        value: function getHeaderItemRow(appointment) {
            if (!appointment.isHeader) {
                return -1;
            }
            var w = this.getItemCell(appointment).querySelectorAll(".mfp-item-wrap");
            for (var i = 0, l = w.length; i < l; i++) {
                if (w[i] == DomUtils.getParent(appointment.element, "mfp-item-wrap")) return i;
            }
            return -1;
        }
    }, {
        key: 'getItemCell',
        value: function getItemCell(appointment) {
            var wrapper = null;
            var cellIndex = appointment.cellIndex;
            if (appointment.isHeader) {
                var headerCells = this.getHeaderItemsCells();
                if (cellIndex >= 0 && cellIndex < headerCells.length) wrapper = headerCells[cellIndex];
            } else {
                if (cellIndex >= 0 && cellIndex < this.cells.count()) {
                    var cell = this.cells.items()[cellIndex].bgCell;
                    var itemCells = cell.querySelectorAll(".mfp-item-cell");
                    if (itemCells.length === 0) {
                        wrapper = document.createElement("div");
                        wrapper.className = "mfp-item-cell";
                        cell.appendChild(wrapper);
                    } else wrapper = itemCells[0];
                }
            }
            return wrapper;
        }
    }, {
        key: 'updateLayout',
        value: function updateLayout() {
            var appointments = this.items;
            var appointment = null;
            var columns = [];

            // Gets all visible schedule items in columns
            for (var i = 0, l = appointments.length; i < l; i++) {
                appointment = appointments[i];
                if (!appointment.isHeader) {
                    var colIndex = parseInt(appointment.cellIndex / this.rowsCount);
                    if (columns[colIndex] == null) columns[colIndex] = [];
                    columns[colIndex].push(appointment);
                }
            }

            for (var colIndex = 0, colLength = columns.length; colIndex < colLength; colIndex++) {
                var dayItems = columns[colIndex];
                if (!dayItems) {
                    continue;
                }
                dayItems.sort(this.calendar.sortAppointments);

                var usedCells = [];
                for (var i = 0; i < this.rowsCount; i++) {
                    usedCells.push([null]);
                }var cellIndex = 0,
                    itemEnd = 0;
                var offsetIndex = 0;
                var canSetItem = true;

                // Sets schedule appointments offset, left and width
                for (var j = 0, dLen = dayItems.length; j < dLen; j++) {
                    var part = dayItems[j];
                    cellIndex = part.cellIndex % this.rowsCount;
                    itemEnd = cellIndex + part.cellsLength - 1;
                    offsetIndex = 0;
                    do {
                        canSetItem = true;

                        // Adds new column with null values
                        if (usedCells[0].length <= offsetIndex) {
                            for (var i = 0; i < this.rowsCount; i++) {
                                usedCells[i].push(null);
                            }
                        }

                        for (var i = cellIndex; i <= itemEnd; i++) {
                            if (usedCells[i][offsetIndex] != null) {
                                canSetItem = false;
                                offsetIndex++;
                                break;
                            }
                        }

                        if (canSetItem) {
                            part.intLeft = offsetIndex;
                            for (var i = cellIndex; i <= itemEnd; i++) {
                                usedCells[i][offsetIndex] = part.element;
                            }
                        }
                    } while (!canSetItem);
                }

                var ids = [];
                var rowIds = [];
                var startIndex = -1;
                var endIndex = -1;
                var found = false;
                var max = 0;

                for (var i = 0, luc = usedCells.length; i < luc; i++) {

                    var row = usedCells[i];
                    rowIds = new Array();

                    for (var j = 0, columnCount = row.length; j < columnCount; j++) {
                        var partElement = row[j];
                        if (partElement != null && rowIds.indexOf(partElement) === -1) rowIds.push(partElement);
                    }

                    if (rowIds.length > 0) {

                        if (startIndex === -1) {
                            // if ids set not started then start it and adds all ids
                            startIndex = i;
                            for (var j = 0; j < rowIds.length; j++) {
                                if (ids.indexOf(rowIds[j]) === -1) ids.push(rowIds[j]);
                            }
                        } else {
                            // if ids set is started then check some of them is in the ids list
                            found = false;
                            for (var j = 0; j < rowIds.length; j++) {
                                if (ids.indexOf(rowIds[j]) > -1) {
                                    found = true;
                                    break;
                                }
                            }

                            // if some id is found then adds all ids to ids array
                            if (found) {
                                for (var j = 0; j < rowIds.length; j++) {
                                    if (ids.indexOf(rowIds[j]) === -1) ids.push(rowIds[j]);
                                }
                            } else {
                                endIndex = i;
                                i--;
                            }
                        }
                    } else {
                        if (startIndex > -1) {
                            endIndex = i;
                            i--;
                        }
                    }

                    // if set is complete then calculate items left and width
                    if (i == luc - 1 && startIndex > -1 && endIndex == -1) endIndex = i + 1;

                    if (startIndex > -1 && endIndex > -1) {

                        // Get items count
                        var max = 0,
                            tMax = 0;
                        for (var mIndex = startIndex; mIndex < endIndex; mIndex++) {
                            var row = usedCells[mIndex];
                            tMax = 0;
                            for (var bl = 0; bl < row.length; bl++) {
                                if (row[bl] != null) {
                                    tMax++;
                                }
                            }
                            if (tMax > max) max = tMax;
                        }

                        if (max > 0) {

                            for (var p = 0; p < ids.length; p++) {
                                var item = null;
                                for (var n = 0; n < dayItems.length; n++) {
                                    if (ids[p] == dayItems[n].element) {
                                        item = dayItems[n];
                                        break;
                                    }
                                }if (item == null) continue;

                                var width = parseInt(100 / max);
                                var left = width * item.intLeft;
                                var st = item.element.style;
                                if (left > 0) st.top = left + "%";else st.top = "auto";
                                st.height = width + "%";
                                delete item.intLeft;
                            }
                        }

                        // Go to the next set of items
                        ids = [];
                        startIndex = -1;
                        endIndex = -1;
                    }
                }
            }
        }

        /**
            * For internal use only.
            * @private
            * Updates appointment data after creation/modification.
            * Used for header items.
            */

    }, {
        key: 'updateHeaderItem',
        value: function updateHeaderItem(appointment, addToItems) {
            var item = appointment.item;

            if (!item.visible) {
                return appointment;
            }

            var parts = [];
            var removed = [];

            var columns = this.getItemColumns(item);
            if (columns.length === 0) {
                return [];
            }
            var groupColumns = this.getItemGroupColumns(item);
            appointment.groupColumnIndex = groupColumns;

            if (!this.hasVisibleParts(item)) {
                removed.push(appointment);
            } else if (this.isComposite(item)) {
                var ist = DateTime.maxDate(item.startTime, this.headerItemsStartTime, false);
                var iet = DateTime.minDate(item.endTime, this.headerItemsEndTime, true);

                // has time parts but not group parts
                if (groupColumns.length === 1) {
                    for (var j = 0, m = columns.length - 1; j <= m; j++) {
                        var st = DateTime.maxDate(item.startTime, this._columns.items()[columns[j]].headerCell.startTime, false);
                        var et = DateTime.minDate(item.endTime, this._columns.items()[columns[j]].headerCell.endTime, true);
                        if (st.equals(et)) continue;

                        var partIndex = 0;

                        if (st.compareTo(item.startTime) === 1) partIndex = 1;
                        if (et.compareTo(item.endTime) === -1) partIndex = -1;
                        if (st.compareTo(item.startTime) === 1 && et.compareTo(item.endTime) === -1) partIndex = 0;

                        var scell = this.headerCells.items()[columns[j]];
                        var lcell = this.headerCells.items()[columns[j]];
                        var partData = {
                            prototype: appointment,
                            type: 'part',
                            cellIndex: scell.index,
                            cellsLength: lcell.index - scell.index + 1,
                            colIndex: scell.rowIndex,
                            isPartial: true,
                            partIndex: partIndex,
                            isHeader: true,
                            lastCellIndex: lcell.index,
                            startCellIndex: scell.index,
                            groupColumnIndex: appointment.groupColumnIndex
                        };
                        var part = new Appointment(partData);
                        part.composite = true;
                        parts.push(part);
                        removed.push(appointment);
                    }
                }
                // has time parts and group parts
                else if (groupColumns.length > 1) {
                        for (var i = 0, l = groupColumns.length; i < l; i++) {
                            var st = DateTime.maxDate(item.startTime, this._columns.items()[groupColumns[i]].headerCell.startTime, false);
                            var et = DateTime.minDate(item.endTime, this._columns.items()[groupColumns[i]].headerCell.endTime, true);
                            if (st.equals(et)) continue;

                            var partIndex = 0;

                            if (st.compareTo(item.startTime) === 1) partIndex = 1;
                            if (et.compareTo(item.endTime) === -1) partIndex = -1;
                            if (st.compareTo(item.startTime) === 1 && et.compareTo(item.endTime) === -1) partIndex = 0;

                            var scell = this.headerCells.items()[groupColumns[i]];
                            var lcell = this.headerCells.items()[groupColumns[i]];
                            var partData = {
                                prototype: appointment,
                                type: 'part',
                                cellIndex: scell.index,
                                cellsLength: lcell.index - scell.index + 1,
                                colIndex: scell.rowIndex,
                                isPartial: true,
                                partIndex: partIndex,
                                isHeader: true,
                                lastCellIndex: lcell.index,
                                startCellIndex: scell.index,
                                groupColumnIndex: appointment.groupColumnIndex[i]
                            };
                            var part = new Appointment(partData);
                            part.composite = true;
                            parts.push(part);
                            removed.push(appointment);
                        }
                    }
            }
            // has group parts but not time parts
            else if (groupColumns.length > 1) {
                    for (var i = 0, l = groupColumns.length; i < l; i++) {
                        var cell = this.headerCells.items()[groupColumns[i]];
                        var lcell = cell;
                        var partData = {
                            prototype: appointment,
                            type: 'part',
                            cellIndex: cell.index,
                            cellsLength: lcell.index - cell.index + 1,
                            colIndex: groupColumns[i],
                            isPartial: true,
                            partIndex: undefined,
                            isHeader: true,
                            lastCellIndex: lcell.index,
                            startCellIndex: cell.index,
                            groupColumnIndex: appointment.groupColumnIndex[i]
                        };
                        var part = new Appointment(partData);
                        part.composite = true;
                        parts.push(part);
                        removed.push(appointment);
                    }
                }
                // doesn't have parts
                else if (groupColumns.length === 1) {
                        var cell = this.headerCells.items()[columns[0]];
                        var lcell = cell;

                        appointment.lastCellIndex = lcell.index;
                        appointment.startCellIndex = cell.index;
                        appointment.cellsLength = lcell.index - cell.index + 1;
                        if (appointment.cellsLength < 1) {
                            appointment.cellsLength = 1;
                        }
                        appointment.cellIndex = cell.index;
                        appointment.colIndex = cell.rowIndex;
                        appointment.partIndex = undefined;
                        appointment.updateVisual();
                    }

            for (var i = 0; i < removed.length; i++) {
                this.removeAppointment(removed[i]);
            }

            if (addToItems !== false) this.items = this.items.concat(parts);

            for (var i = 0; i < parts.length; i++) {
                parts[i].updateVisual();
            }

            //return value is only used for recurrent composite items
            if (parts.length > 0) return parts;
            parts.push(appointment);
            return parts;
        }
    }, {
        key: 'updateDayItem',
        value: function updateDayItem(appointment, addToItems) {
            var item = appointment.item;
            if (!item.visible) {
                return appointment;
            }

            var parts = [];
            var removed = [];

            var columns = this.getItemColumns(item);
            if (columns.length === 0) {
                return [];
            }
            var groupColumns = this.getItemGroupColumns(item);
            appointment.groupColumnIndex = groupColumns;

            if (!this.hasVisibleParts(item)) {
                removed.push(appointment);
            } else if (this.isComposite(item)) {

                //has time parts but not group parts
                if (groupColumns.length === 1) {
                    for (var j = 0, m = columns.length - 1; j <= m; j++) {
                        var st = DateTime.maxDate(item.startTime, this._columns.items()[columns[j]].startTime, false);
                        var et = DateTime.minDate(item.endTime, this._columns.items()[columns[j]].endTime, true);
                        if (st.equals(et)) continue;

                        var partIndex = 0;

                        if (st.compareTo(item.startTime) === 1) partIndex = 1;
                        if (et.compareTo(item.endTime) === -1) partIndex = -1;
                        if (st.compareTo(item.startTime) === 1 && et.compareTo(item.endTime) === -1) partIndex = 0;

                        var scell = this.getTimeCell(st, false, columns[0]);
                        var lcell = this.getTimeCell(et, true, columns[0]);
                        // could happen for recurrent items if the view dates are not consecutive
                        if (scell === undefined || lcell === undefined) {
                            continue;
                        }
                        var partData = {
                            prototype: appointment,
                            type: 'part',
                            cellIndex: scell.index,
                            cellsLength: lcell.index - scell.index + 1,
                            colIndex: scell.rowIndex,
                            isPartial: true,
                            partIndex: partIndex,
                            lastCellIndex: lcell.index,
                            startCellIndex: scell.index,
                            groupColumnIndex: appointment.groupColumnIndex
                        };
                        var part = new Appointment(partData);
                        part.composite = true;
                        parts.push(part);
                        removed.push(appointment);
                    }
                }
                //has time parts and group parts
                else if (groupColumns.length > 1) {
                        for (var i = 0, l = groupColumns.length; i < l; i++) {
                            var st = DateTime.maxDate(item.startTime, this._columns.items()[groupColumns[i]].startTime, false);
                            var et = DateTime.minDate(item.endTime, this._columns.items()[groupColumns[i]].endTime, true);
                            if (st.equals(et)) continue;

                            var partIndex = 0;

                            if (st.compareTo(item.startTime) === 1) partIndex = 1;
                            if (et.compareTo(item.endTime) === -1) partIndex = -1;
                            if (st.compareTo(item.startTime) === 1 && et.compareTo(item.endTime) === -1) partIndex = 0;

                            var scell = this.getTimeCell(st, false, groupColumns[i]);
                            var lcell = this.getTimeCell(et, true, groupColumns[i]);
                            var partData = {
                                prototype: appointment,
                                type: 'part',
                                cellIndex: scell.index,
                                cellsLength: lcell.index - scell.index + 1,
                                colIndex: scell.rowIndex,
                                isPartial: true,
                                partIndex: partIndex,
                                lastCellIndex: lcell.index,
                                startCellIndex: scell.index,
                                groupColumnIndex: appointment.groupColumnIndex[i]
                            };
                            var part = new Appointment(partData);
                            part.composite = true;
                            parts.push(part);
                            removed.push(appointment);
                        }
                    }
            }
            //has group parts but not time parts
            else if (groupColumns.length > 1) {
                    for (var i = 0, l = groupColumns.length; i < l; i++) {
                        var cell = this.getTimeCell(item.startTime, false, groupColumns[i]);
                        if (item.startTime._date.valueOf() === item.endTime._date.valueOf()) {
                            var lcell = cell;
                        } else {
                            var lcell = this.getTimeCell(item.endTime, true, groupColumns[i]);
                        }
                        var partData = {
                            prototype: appointment,
                            type: 'part',
                            cellIndex: cell.index,
                            cellsLength: lcell.index - cell.index + 1,
                            colIndex: appointment.groupColumnIndex[i],
                            isPartial: true,
                            partIndex: undefined,
                            lastCellIndex: lcell.index,
                            startCellIndex: cell.index,
                            groupColumnIndex: appointment.groupColumnIndex[i]
                        };
                        var part = new Appointment(partData);
                        part.composite = true;
                        parts.push(part);
                        removed.push(appointment);
                    }
                }
                //doesn't have parts
                else if (groupColumns.length === 1) {
                        var cell = this.getTimeCell(item.startTime, false, columns[0]);
                        if (item.startTime._date.valueOf() === item.endTime._date.valueOf()) {
                            var lcell = cell;
                        } else {
                            var lcell = this.getTimeCell(item.endTime, true, columns[0]);
                        }
                        appointment.lastCellIndex = lcell.index;
                        appointment.startCellIndex = cell.index;
                        appointment.cellsLength = lcell.index - cell.index + 1;
                        if (appointment.cellsLength < 1) {
                            appointment.cellsLength = 1;
                        }
                        appointment.cellIndex = cell.index;
                        appointment.colIndex = cell.rowIndex;
                        appointment.partIndex = undefined;
                        appointment.updateVisual();
                    }

            for (var i = 0; i < removed.length; i++) {
                this.removeAppointment(removed[i]);
            }

            if (addToItems !== false) this.items = this.items.concat(parts);

            for (var i = 0; i < parts.length; i++) {
                parts[i].updateVisual();
            }

            //return value is only used for recurrent composite items
            if (parts.length > 0) return parts;
            parts.push(appointment);
            return parts;
        }

        /**
              * For internal use only.
              * @private
              */

    }, {
        key: 'updateItem',
        value: function updateItem(appointment, addToItems) {
            if (appointment.isHeader) return this.updateHeaderItem(appointment, addToItems);else return this.updateDayItem(appointment, addToItems);
        }
    }, {
        key: 'getColumnsByResource',
        value: function getColumnsByResource(resource) {
            var result = [];
            for (var i = 0, l = this._columns.count(); i < l; i++) {
                if (resource === this._columns.items()[i].resource) {
                    result.push(this._columns.items()[i]);
                }
            }
            return result;
        }
    }, {
        key: 'getItemStartColumn',
        value: function getItemStartColumn(item) {
            var itemStart = item.startTime.getDate().valueOf();
            for (var i = 0, l = this._columns.count(); i < l; i++) {
                var columnStart = this._columns.items()[i].date.valueOf();
                if (itemStart <= columnStart) {
                    if (this.grouped) {
                        if (item.hasResource(this._columns.items()[i].resource)) {
                            return i;
                        }
                    } else {
                        return i;
                    }
                }
            }
        }
    }, {
        key: 'getItemEndColumn',
        value: function getItemEndColumn(item, resource) {
            var index = this._columns.count() - 1;
            var itemEnd = item.endTime.getDate().valueOf();
            var columns = this.getColumnsByResource(resource);
            for (var i = 0, l = columns.length; i < l; i++) {
                var columnStart = columns[i].date.valueOf();

                if (itemEnd === columnStart) {
                    if (item.endTime._date.valueOf() > columns[i].startTime._date.valueOf()) {
                        return columns[i].index;
                    } else if (i > 0) {
                        return columns[i - 1].index;
                    } else {
                        return null;
                    }
                }
                if (itemEnd > columnStart) {
                    index = columns[i].index;
                }
            }
            return index;
        }

        /**
               * Gets the cell that corresponds to the specified time.
               * @param {Object} [time] The time to search for.
               * @param {Boolean} [isEndTime] true if the index of the first interval is returned when the time is the boundary between two consecutive intervals;
               false if the index of the second interval is contained.
               * @returns {Object} The cell that holds the specified time.
               */

    }, {
        key: 'getTimeCell',
        value: function getTimeCell(time, isEndTime, col) {
            if (col.length != undefined) col = col[0];

            if (col < 0 || col > this._columns.count() - 1) return null;
            if (time._date.valueOf() < this.dates[0].startTime._date.valueOf()) return null;
            if (time._date.valueOf() > this.dates[this.dates.length - 1].endTime._date.valueOf()) return null;
            var resource = null;
            if (col != null && this.resources != null && this.grouped) resource = this._columns.items()[col].resource;

            for (var i = 0, l = this._columns.count(); i < l; i++) {
                if (resource === this._columns.items()[i].resource) {
                    if (time._date.valueOf() >= this._columns.items()[i].startTime._date.valueOf() && (time._date.valueOf() < this._columns.items()[i].endTime._date.valueOf() || isEndTime && time._date.valueOf() === this._columns.items()[i].endTime._date.valueOf())) {

                        var index = i * this.rowsCount + Math.floor(DateTime.millisecondsBetween(time, this._columns.items()[i].startTime) / this.settings.cellTime.milliseconds);
                        if (index > this._columns.items()[i].cells.items()[this._columns.items()[i].cells.count() - 1].index) {
                            if (isEndTime && time.equals(this._columns.items()[i].cells.items()[this._columns.items()[i].cells.count() - 1].endTime)) return this.cells.items()[index - 1];else return null;
                        }
                        if (isEndTime && DateTime.isSameDate(time, this.cells.items()[index].startTime) && index > 0) {
                            index -= 1;
                        }
                        return this.cells.items()[index];
                    }
                }
            }
            return this.cells.items()[index];
        }

        /**
         * For internal use only.
         * @private
         * Returns an array of cells that correspond to the specified time and column.
         */

    }, {
        key: 'getTimeCells',
        value: function getTimeCells(startTime, endTime, isEndTime, col) {
            var startCell = null;
            var endCell = null;

            if (col.length != undefined) col = col[0];

            if (col < 0 || col > this._columns.count() - 1) return null;
            var resource = this._columns.items()[col].resource;
            var cells = this._columns.items()[col].cells;

            if (startTime.valueOf() < this.startTime.valueOf()) {
                startCell = cells.items()[0];
            } else if (startTime.valueOf() > this.endTime.valueOf()) {
                return [];
            } else {
                startCell = this.getTimeCell(startTime, false, col);
            }
            if (endTime !== null && typeof endTime !== "undefined" && typeof endTime._date !== "undefined") {
                if (endTime.valueOf() > this.endTime.valueOf()) {
                    endCell = cells.items()[cells.count() - 1];
                } else if (endTime.valueOf() < this.startTime.valueOf()) {
                    return [];
                } else {
                    endCell = this.getTimeCell(endTime, isEndTime, col);
                }
            } else {
                endCell = startCell;
            }

            if (startCell != null && endCell != null) {
                var result = [];
                if (startCell === endCell) {
                    result.push(startCell);
                } else {
                    for (var i = startCell.index; i < endCell.index; i++) {
                        var cell = this.cells.items()[i];
                        if (resource == null || resource && this.columns.items()[cell.columnIndex].resource == resource) {
                            result.push(cell);
                        }
                    }
                }
                return result;
            }
            return [];
        }

        /**
            * For internal use only.
            * @private
            * Returns an array of all column indexes the specified appointment belongs to.
            * Both group and time parts are included.
            */

    }, {
        key: 'getItemColumns',
        value: function getItemColumns(item) {
            var start = this.getItemStartColumn(item);
            if (start === undefined) {
                return [];
            }
            var resource = this._columns.items()[start].resource;
            var end = this.getItemEndColumn(item, resource);
            if (end == null || end < start) {
                end = start;
            }

            var result = [];
            for (var i = start; i <= end; i++) {
                if (this.grouped) {
                    if (this._columns.items()[i].resource === resource) {
                        if (result.indexOf(i) === -1) {
                            result.push(i);
                        }
                    }
                } else {
                    if (result.indexOf(i) === -1) {
                        result.push(i);
                    }
                }
            }
            return result;
        }

        /**
        * For internal use only.
        * @private
        * Returns an array of all group column indexes the specified appointment belongs to.
        * Only group parts are included.
        */

    }, {
        key: 'getItemGroupColumns',
        value: function getItemGroupColumns(item) {
            var result = [];
            var resource = null;

            if (!this.grouped || this.resources == null) {
                result.push(0);
            } else {
                for (var i = 0, l = this._columns.count(); i < l; i++) {
                    if (this.isItemInColumn(item, this._columns.items()[i])) {
                        if (item.hasResource(this._columns.items()[i].resource)) {
                            if (!this._columns.items()[i].resource.equals(resource)) {
                                result.push(i);
                                resource = this._columns.items()[i].resource;
                            }
                        }
                    }
                }
            }

            return result;
        }

        /**
        * For internal use only.
        * @private
        * Checks if the appointment belongs to the column.
        */

    }, {
        key: 'isItemInColumn',
        value: function isItemInColumn(item, column) {
            if (item.startTime >= column.startTime && item.startTime < column.endTime) return true;
            if (item.endTime > column.startTime && item.endTime <= column.endTime) return true;
            if (item.startTime < column.startTime && item.endTime >= column.endTime) return true;
            return false;
        }

        /**
        * For internal use only.
        * @private
        * Checks if the appointment belongs to more than one column.
        */

    }, {
        key: 'isComposite',
        value: function isComposite(item) {
            if (item.startTime._date.valueOf() == item.endTime._date.valueOf()) {
                return false;
            }
            if (item.allDayEvent) {
                if (item.startTime._date.valueOf() < this.headerItemsStartTime._date.valueOf()) return true;
                if (item.endTime._date.valueOf() > this.headerItemsEndTime._date.valueOf()) return true;

                var cols = this.getItemColumns(item);
                if (cols.length > 1) return true;
            } else {

                if (item.startTime._date.valueOf() < this.itemsStartTime._date.valueOf()) return true;
                if (item.endTime._date.valueOf() > this.itemsEndTime._date.valueOf()) return true;

                var cols = this.getItemColumns(item);
                if (cols.length > 1) return true;
                var startCell = this.getTimeCell(item.startTime, false, cols[0]);
                if (startCell == null) return true;
                var endCell = this.getTimeCell(item.endTime, true, cols[0]);
                if (endCell == null) return true;
            }

            return false;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'hasVisibleParts',
        value: function hasVisibleParts(item) {
            if (this.grouped && this.getItemGroupColumns(item).length == 0) return false;
            if (item.startTime._date.valueOf() >= this._columns.items()[0].startTime._date.valueOf() && item.startTime._date.valueOf() < this._columns.items()[this._columns.count() - 1].endTime._date.valueOf()) return true;
            if (item.endTime._date.valueOf() > this._columns.items()[0].startTime._date.valueOf() && item.endTime._date.valueOf() < this._columns.items()[this._columns.count() - 1].endTime._date.valueOf()) return true;
            if (item.startTime._date.valueOf() <= this._columns.items()[0].startTime._date.valueOf() && item.endTime._date.valueOf() >= this._columns.items()[0].endTime._date.valueOf()) return true;
            return false;
        }
    }, {
        key: 'getItemsInCell',
        value: function getItemsInCell(cell, items) {
            var result = [];
            for (var i = 0, l = items.length; i < l; i++) {
                if (items[i].startCellIndex == cell.index) result.push(items[i]);
            }
            return result;
        }
    }, {
        key: 'getHeaderType',
        value: function getHeaderType(element) {
            var h = this.getGroupHeader();
            if (h) {
                if (h.contains(element)) return HeaderType.Group;
            }

            h = this.getTimelineHeader();
            if (h) {
                if (h.contains(element)) return HeaderType.Timeline;
            }
            return get(HorizontalTimetable.prototype.__proto__ || Object.getPrototypeOf(HorizontalTimetable.prototype), 'getHeaderType', this).call(this, element);
        }

        /*Rendering*/

    }, {
        key: 'drawHeader',
        value: function drawHeader() {
            var result = null;
            var output = this.calendar.renderer;

            var header = document.createElement("div");
            header.className = "mfp-header";
            result = header;

            var corner = document.createElement("div");
            corner.className = "mfp-corner";
            corner.innerHTML = "&nbsp;";
            header.appendChild(corner);

            var d = this.drawColumnHeaders();
            header.appendChild(d);

            var fix = document.createElement("div");
            fix.className = "mfp-scrollfix";
            fix.innerHTML = "&nbsp;";
            header.appendChild(fix);

            return result;
        }
    }, {
        key: 'drawColumnHeaders',
        value: function drawColumnHeaders() {
            var result = null;
            var output = this.calendar.renderer;

            var header = document.createElement("div");
            header.className = "mfp-title";
            result = header;

            if ((this.settings.headerStyle & MainHeaderStyle.Title) === MainHeaderStyle.Title) {
                var d = this.drawDateHeaders();
                header.appendChild(d);
            }

            if ((this.settings.headerStyle & MainHeaderStyle.Buttons) == MainHeaderStyle.Buttons) {
                var b = this.drawHeaderButtons();
                header.appendChild(b);
            }
            return result;
        }
    }, {
        key: 'drawDateHeaders',
        value: function drawDateHeaders() {
            var result = null;

            var table = document.createElement("table");
            table.className = "mfp-title-table";
            table.cellSpacing = 0;
            table.cellPadding = 0;
            result = table;

            // ReverseGrouping
            if (this._groupColumns > 0 && this.settings.reverseGrouping) {

                var htr = document.createElement("tr");
                htr.style.height = "100%";
                table.appendChild(htr);

                var td = document.createElement("td");
                td.rowSpan = this._dateColumns;
                td.className = "mfp-group-row";
                htr.appendChild(td);

                var gt = document.createElement("table");
                gt.cellPadding = 0;
                gt.cellSpacing = 0;
                gt.style.height = "100%";
                td.appendChild(gt);

                var groupName = "";
                for (var group = 0; group < this._groupColumns; group++) {
                    var tr = document.createElement("tr");
                    gt.appendChild(tr);

                    groupName = this.calendar.getResourceName(this.resources[group]);

                    var td = document.createElement("td");
                    td.innerHTML = groupName || "&nbsp;";
                    tr.appendChild(td);

                    if (group == 0) {
                        if (this.settings.showDayHeader) {

                            var td = document.createElement("td");
                            td.className = "mfp-header-row";
                            td.rowSpan = this._groupColumns;
                            tr.appendChild(td);

                            var ht = document.createElement("table");
                            ht.cellPadding = 0;
                            ht.cellSpacing = 0;
                            ht.style.height = "100%";
                            td.appendChild(ht);

                            for (var g = 0; g < this._groupColumns; g++) {
                                for (var i = 0; i < this._dateColumns; i++) {

                                    var tr = document.createElement("tr");
                                    ht.appendChild(tr);

                                    var td = document.createElement("td");
                                    tr.appendChild(td);

                                    if (this._groupColumns > 0) td.style.colspan = this._groupColumns;

                                    td.innerHTML = this.settings.dates.items()[i].toString(this.settings.titleFormat, this.formatInfo);
                                    if (this.calendar.showToolTips) td.title = this.settings.dates.items()[i].toString(this.formatInfo.longDate, this.formatInfo);
                                }
                            }

                            var td = document.createElement("td");
                            td.className = "mfp-item-row";
                            td.style.minWidth = this.calendar.itemSettings.size + "px";
                            td.rowSpan = this._groupColumns;
                            htr.appendChild(td);

                            var it = document.createElement("table");
                            it.cellPadding = 0;
                            it.cellSpacing = 0;
                            td.appendChild(it);

                            for (var columnIndex = 0; columnIndex < this._totalColumns; columnIndex++) {
                                var tr = document.createElement("tr");
                                tr.style.height = 100 / this._columns.count() + "%";
                                it.appendChild(tr);

                                var td = document.createElement("td");
                                td.className = "mfp-item-cell";
                                td.innerHTML = "&nbsp;";
                                tr.appendChild(td);
                            }

                            var td = document.createElement("td");
                            td.className = "mfp-empty-row";
                            td.style.minWidth = this.calendar.itemSettings.size + "px";
                            td.rowSpan = this._dateColumns;
                            htr.appendChild(td);

                            var et = document.createElement("table");
                            et.cellPadding = 0;
                            et.cellSpacing = 0;
                            et.style.height = "100%";
                            td.appendChild(et);

                            for (var columnIndex = 0; columnIndex < this._totalColumns; columnIndex++) {
                                var tr = document.createElement("tr");
                                et.appendChild(tr);

                                var td = document.createElement("td");
                                td.innerHTML = "&nbsp;";
                                tr.appendChild(td);
                            }
                        }
                    }
                }
            } else {
                for (var i = 0; i < this._dateColumns; i++) {

                    var htr = document.createElement("tr");
                    table.appendChild(htr);

                    var td = document.createElement("td");
                    td.className = "mfp-header-row";
                    if (this._groupColumns > 0) td.colSpan = this._groupColumns;
                    td.innerText = this.settings.dates.items()[i].toString(this.settings.titleFormat, this.formatInfo);
                    if (this.calendar.showToolTips) td.title = this.settings.dates.items()[i].toString(this.formatInfo.longDate, this.formatInfo);
                    htr.appendChild(td);

                    if (i == 0) {
                        if (this.settings.showDayHeader) {

                            if (this._groupColumns > 0 && !this.settings.reverseGrouping) {

                                var td = document.createElement("td");
                                td.className = "mfp-group-row";
                                td.rowSpan = this._dateColumns;
                                htr.appendChild(td);

                                var gt = document.createElement("table");
                                gt.cellPadding = 0;
                                gt.cellSpacing = 0;
                                gt.style.height = "100%";
                                td.appendChild(gt);

                                var groupName = "";
                                for (var k = 0; k < this._dateColumns; k++) {
                                    for (var group = 0; group < this._groupColumns; group++) {

                                        var tr = document.createElement("tr");
                                        gt.appendChild(tr);

                                        groupName = this.calendar.getResourceName(this.resources[group]);

                                        var td = document.createElement("td");
                                        td.innerHTML = groupName || '&nbsp';
                                        if (this.calendar.showToolTips) td.title = groupName;
                                        tr.appendChild(td);
                                    }
                                }
                            }

                            var td = document.createElement("td");
                            td.className = "mfp-item-row";
                            td.style.minWidth = this.calendar.itemSettings.size + "px";
                            td.rowSpan = this._dateColumns;
                            htr.appendChild(td);

                            var it = document.createElement("table");
                            it.cellPadding = 0;
                            it.cellSpacing = 0;
                            it.style.height = "100%";
                            td.appendChild(it);

                            for (var columnIndex = 0; columnIndex < this._totalColumns; columnIndex++) {
                                var tr = document.createElement("tr");
                                tr.style.height = 100 / this._columns.count() + "%";
                                it.appendChild(tr);

                                var td = document.createElement("td");
                                td.className = "mfp-item-cell";
                                td.innerHTML = "&nbsp;";
                                tr.appendChild(td);
                            }

                            var td = document.createElement("td");
                            td.className = "mfp-empty-row";
                            td.style.minWidth = this.calendar.itemSettings.size + "px";
                            td.rowSpan = this._dateColumns;
                            htr.appendChild(td);

                            var et = document.createElement("table");
                            et.cellPadding = 0;
                            et.cellSpacing = 0;
                            et.style.height = "100%";
                            td.appendChild(et);

                            for (var columnIndex = 0; columnIndex < this._totalColumns; columnIndex++) {
                                var tr = document.createElement("tr");
                                et.appendChild(tr);

                                var td = document.createElement("td");
                                td.innerHTML = "&nbsp;";
                                tr.appendChild(td);
                            }
                        }
                    }
                }
            }
            return result;
        }
    }, {
        key: 'drawHeaderButtons',
        value: function drawHeaderButtons() {
            var result = null;

            var d = document.createElement("div");
            d.className = "mfp-button-wrap";
            result = d;

            var b1 = document.createElement("a");
            DomUtils.addCssClass(b1, "mfp-button");
            DomUtils.addCssClass(b1, "mfp-button-prev");
            if (this.calendar.showTooltips) {
                b1.title = this.getButtonTooltip(-1);
            }
            var s = document.createElement("span");
            b1.appendChild(s);
            d.appendChild(b1);

            var b2 = document.createElement("a");
            DomUtils.addCssClass(b2, "mfp-button");
            DomUtils.addCssClass(b2, "mfp-button-next");
            if (this.calendar.showTooltips) {
                b2.title = this.getButtonTooltip(1);
            }
            s = document.createElement("span");
            b2.appendChild(s);
            d.appendChild(b2);

            return result;
        }
    }, {
        key: 'getButtonTooltip',
        value: function getButtonTooltip(f) {
            var s = "";

            for (var i = 0; i < this.settings.dates.count(); i++) {
                //s += this.settings.dates.items()[i].addDays(f * this.settings.scrollStep).toString(this.formatInfo.dateFormats.longDate, this.formatInfo);
                s += i !== this.settings.dates.count() - 1 ? "\n" : "";
            }

            return s;
        }
    }, {
        key: 'drawContent',
        value: function drawContent() {

            var result = null;
            var output = this.calendar.renderer;

            var s = document.createElement("div");
            s.className = "mfp-scroll-container";
            result = s;

            var content = document.createElement("div");
            content.className = "mfp-content-wrap";
            content.style.width = this._totalCells * this.settings.cellSize + "px";
            s.appendChild(content);

            // var timeline = document.createElement("div");
            // timeline.className = "mfp-header-timeline";
            // content.appendChild(timeline);

            var t = this.drawTimeline(output);
            content.appendChild(t);

            // Days cell
            var schedule = document.createElement("div");
            schedule.className = "mfp-content";
            content.appendChild(schedule);

            var rowClass = "";

            for (var clIndx = 0; clIndx < this._totalColumns; clIndx++) {

                var column = document.createElement("div");
                column.className = "mfp-column";
                schedule.appendChild(column);

                for (var rIndx = 0; rIndx < this._totalCells; rIndx++) {
                    rowClass = "mfp-cell-wrap";
                    if (clIndx == 0) rowClass += " left";
                    if (clIndx == this._totalColumns - 1) rowClass += " right";
                    if (rIndx == 0) rowClass += " top";
                    if (rIndx == this._totalCells - 1) rowClass += " bottom";

                    var d = document.createElement("div");
                    column.appendChild(d);
                    d.className = rowClass;
                    d.style.zIndex = this._totalCells - rIndx;
                    d.style.flex = "0 0 " + this.settings.cellSize + "px";

                    var c = document.createElement("div");

                    c.className = "mfp-cell";

                    d.appendChild(c);
                }
            }

            return result;
        }
    }, {
        key: 'drawTimeline',
        value: function drawTimeline() {
            var result = null;

            var d;
            var endT = TimeSpan.fromMinutes(this.settings.realEndTime);

            var t = document.createElement("div");
            t.className = "mfp-header-timeline";
            t.cellPadding = 0;
            t.cellSpacing = 0;
            result = t;

            var ts = TimeSpan.fromMinutes(this.settings.startTime);
            var minutesCellCount = Math.round(60 / this.settings.cellTime.minutes);

            if (this.settings.groupHours && this._canGroupHour) {

                var isAMPM = false;

                while (ts.ticks < endT.ticks) {
                    isAMPM = false;
                    d = new DateTime(ts.milliseconds);

                    // hour cell
                    var c1 = document.createElement("div");
                    c1.className = "mfp-hour";
                    t.appendChild(c1);

                    if (this.calendar.showTooltips) c1.title = d.toString(this.formatInfo.dateFormats.longTime, this.formatInfo);

                    var s = document.createElement("span");

                    if (this.settings.twelveHourFormat) s.innerHTML = d.toString("h ", this.formatInfo).trim();else s.innerHTML = d.toString("H ", this.formatInfo).trim();

                    c1.appendChild(s);

                    var c = document.createElement("div");
                    c.className = "mfp-group-time";
                    c1.appendChild(c);

                    // first minute cell
                    var c2 = document.createElement("div");

                    if (this.settings.twelveHourFormat && ts.subtract(this.settings.cellTime).hours !== ts.hours && (ts.hours == 0 || ts.hours == 12) || ts.equals(TimeSpan.fromMinutes(this.settings.startTime)) && this.settings.showAM) {
                        isAMPM = true;
                        c2.className = "mfp-AMPM";
                    } else {
                        c2.className = "mfp-minute";
                    }

                    if (this.calendar.showTooltips) c2.title = d.toString(this.formatInfo.dateFormats.longTime, this.formatInfo);

                    if (isAMPM) c2.innerHTML = d.toString("tt", this.formatInfo).trim();else c2.innerHTML = this.getMinutesText(d);

                    c.appendChild(c2);

                    ts = ts.add(this.settings.cellTime);
                    d = new DateTime(ts.milliseconds);

                    // other minute cells
                    for (var i = 1; i < minutesCellCount; i++) {

                        var c3 = document.createElement("div");
                        c3.className = "mfp-minute";
                        if (this.calendar.showTooltips) c3.title = new DateTime(ts.milliseconds).toString(this.formatInfo.dateFormats.longTime, this.formatInfo);

                        c.appendChild(c3);

                        if (this.settings.showMinutes) c3.innerHTML = this.getMinutesText(new DateTime(ts.milliseconds));else c3.innerHTML = "&nbsp;";

                        ts = ts.add(this.settings.cellTime);
                        d = new DateTime(ts.milliseconds);
                    }
                }
            } else {
                while (ts.ticks < endT.ticks) {
                    d = new DateTime(ts.milliseconds);

                    var c = document.createElement("div");
                    c.className = "mfp-time";
                    t.appendChild(c);

                    if (this.calendar.showTooltips) c.title = d.toString(this.formatInfo.dateFormats.longTime, this.formatInfo);
                    var h = d.toString(this.settings.generalFormat, this.formatInfo).trim();
                    c.innerHTML = h;

                    ts = ts.add(this.settings.cellTime);
                    d = new DateTime(ts.milliseconds);
                }
            }

            return result;
        }
    }, {
        key: 'getMinutesText',
        value: function getMinutesText(time) {
            return time.toString("mm", this.formatInfo).trim();
        }
        /*End Render*/

    }, {
        key: 'cells',
        get: function get$$1() {
            var result = new List();
            this._columns.forEach(function (t) {
                result.addRange(t.cells.items());
            }, this);
            return result;
        }
    }, {
        key: 'headerCells',
        get: function get$$1() {
            var result = new List();
            this._columns.forEach(function (t) {
                result.add(t.headerCell);
            }, this);
            return result;
        }
    }, {
        key: 'dates',
        get: function get$$1() {
            var result = [];
            this._columns.forEach(function (t) {
                if (result.indexOf(t.date) === -1) result.push(t);
            }, this);
            return result;
        }
    }, {
        key: 'groupResources',
        get: function get$$1() {
            if (this.grouped && this.settings.reverseGrouping) {
                var result = [];
                this._columns.forEach(function (t) {
                    result.push(t.resource);
                }, this);
                return result;
            }
            return this.calendar.groupResources.items();
        }
    }, {
        key: 'orientation',
        get: function get$$1() {
            return Orientation.Horizontal;
        }
    }, {
        key: 'cssClass',
        get: function get$$1() {
            return "mfp-horizontal-timetable-view";
        }
    }, {
        key: 'cueCells',
        get: function get$$1() {
            var row = this.getHeader().querySelector(".mfp-empty-row");
            if (row) return row.querySelectorAll("td");
            return [];
        }
    }]);
    return HorizontalTimetable;
}(Cell);

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* For internal use only.
* @private
*/

var HorizontalList = function (_Cell) {
    inherits(HorizontalList, _Cell);

    function HorizontalList(calendar) {
        classCallCheck(this, HorizontalList);

        var _this = possibleConstructorReturn(this, (HorizontalList.__proto__ || Object.getPrototypeOf(HorizontalList)).call(this, calendar));

        _this._settings = _this.calendar.listSettings;

        _this._rows = new List();

        _this.initVars();

        _this._dragging = false;
        _this._resizing = false;
        _this._selecting = false;
        _this._selectionPaused = false;

        _this.items = [];

        _this.Dom = {};
        return _this;
    }

    createClass(HorizontalList, [{
        key: 'initVars',
        value: function initVars() {
            var d = this.calendar.date.clone();

            switch (this.settings.cellUnits) {
                case TimeUnit.Second:
                    {
                        this._date = new DateTime(Date.UTC(d.year, d.month, d.day, d.hour, d.minute, d.second));
                        break;
                    }
                case TimeUnit.Minute:
                    {
                        this._date = new DateTime(Date.UTC(d.year, d.month, d.day, d.hour, d.minute, 0));
                        break;
                    }
                case TimeUnit.Hour:
                    {
                        this._date = new DateTime(Date.UTC(d.year, d.month, d.day, d.hour, 0, 0));
                        break;
                    }
                case TimeUnit.Week:
                    {
                        var fd = this.calendar.getWeekFirstDate(d);
                        this._date = new DateTime(Date.UTC(fd.year, fd.month, fd.day, 0, 0, 0));
                        break;
                    }
                case TimeUnit.Month:
                    {
                        this._date = new DateTime(Date.UTC(d.year, d.month, 1, 0, 0, 0));
                        break;
                    }
                case TimeUnit.Year:
                    {
                        this._date = new DateTime(Date.UTC(d.year, 1, 1, 0, 0, 0));
                        break;
                    }
                default:
                    {
                        this._date = new DateTime(Date.UTC(d.year, d.month, d.day, 0, 0, 0));
                        break;
                    }
            }

            this.calendar._date = this._date;

            var firstVisibleDate = this._date;

            switch (this.settings.cellUnits) {
                case TimeUnit.Second:
                    this._lastDate = DateTime.addSeconds(firstVisibleDate, this.settings.numberOfCells);
                    break;
                case TimeUnit.Minute:
                    this._lastDate = DateTime.addMinutes(firstVisibleDate, this.settings.numberOfCells);
                    break;
                case TimeUnit.Hour:
                    this._lastDate = DateTime.addHours(firstVisibleDate, this.settings.numberOfCells);
                    break;
                case TimeUnit.Day:
                    this._lastDate = DateTime.addDays(firstVisibleDate, this.settings.numberOfCells);
                    break;
                case TimeUnit.Week:
                    this._lastDate = DateTime.addDays(firstVisibleDate, this.settings.numberOfCells * 7);
                    break;
                case TimeUnit.Month:
                    this._lastDate = DateTime.addMonths(firstVisibleDate, this.settings.numberOfCells);
                    break;
                case TimeUnit.Year:
                    this._lastDate = DateTime.addYears(firstVisibleDate, this.settings.numberOfCells);
                    break;
            }

            this._groupColumns = 0;
            if (this.calendar.realGroupType !== GroupType.None) this._groupColumns = this.calendar.groupResources.count();
            this._totalColumns = this._groupColumns === 0 ? 1 : this._groupColumns;

            this.createCells();
        }

        /* Dom */

    }, {
        key: 'getContent',
        value: function getContent() {
            if (!this.Dom.content) {
                this.Dom.content = this.calendar.getElement().querySelector("div.mfp-scroller");
            }
            return this.Dom.content;
        }
    }, {
        key: 'getGroupHeader',
        value: function getGroupHeader() {
            if (!this.Dom.groupHeader) {
                this.Dom.groupHeader = this.calendar.getElement().querySelector("div.mfp-header-group");
            }
            return this.Dom.groupHeader;
        }
    }, {
        key: 'getRows',
        value: function getRows() {
            if (!this.Dom.rows) {
                this.Dom.rows = this.calendar.getElement().querySelectorAll('div.mfp-wrap');
            }
            return this.Dom.rows;
        }
    }, {
        key: 'getBgCells',
        value: function getBgCells() {
            if (!this.Dom.bgCells) {
                this.Dom.bgCells = this.calendar.getElement().querySelectorAll('div.mfp-bg-cell');
            }
            return this.Dom.bgCells;
        }
    }, {
        key: 'createCells',
        value: function createCells() {

            this.startTime = this.itemsStartTime = this._date;
            this.endTime = this.itemsEndTime = this._lastDate;

            var cst, cet;
            var cellStartTime, cellEndTime;

            this._columns = new List();
            for (var i = 0; i < this._totalColumns; i++) {
                var col = new ViewColumn(i, this._date, this._date, this._lastDate);
                col.resource = this.resources[i];
                this._columns.add(col);
            }

            this.rowCellsCount = this.settings.numberOfCells;

            var j = 0;
            for (var i = 0; i < this._totalColumns; i++) {
                var row = new ViewRow(this.startTime, this.endTime, this.startTime, this.endTime);
                row.index = i;

                for (var k = 0, m = this.rowCellsCount; k < m; k++) {
                    if (this.skipNext > 0 && k <= this.skipNext) {
                        cst = this.addUnits(this.startTime, k);
                        cet = this.addUnits(this.startTime, k + 1);
                    } else {
                        cellStartTime = this.addUnits(this.startTime, k);
                        cellEndTime = this.addUnits(this.startTime, k + 1);
                    }
                    var cell = new ViewCell();
                    cell.index = k;
                    cell.cellIndex = j;
                    cell.rowIndex = i;
                    cell.startTime = cellStartTime;
                    cell.endTime = cellEndTime;
                    cell.columnIndex = i;

                    if (this.grouped) {
                        cell.resource = this.resources == null ? null : this.resources[i];
                    }
                    row.cells.add(cell);
                    j += 1;
                }
                this._rows.add(row);
            }

            this.groupCols = [];

            var col = new ViewColumn(0, this._date, this._date, this._date);
            col.resource = this.resources == null ? null : this.resources[0];

            this.groupCols.push(col);

            if (this._totalColumns > 1) {
                var rcells = this.cells.items().slice(0);

                for (var i = 1, l = this._totalColumns; i < l; i++) {
                    var col = new ViewColumn(i, this._date, this._date, this._date);
                    col.resource = this.resources == null ? null : this.resources[i];
                    this.groupCols.push(col);
                }
            }
        }
    }, {
        key: 'detach',
        value: function detach() {
            if (this.getHeader()) {
                this.getHeader().removeEventListener("click", this.headerClickHandler);

                var buttons = this.getHeader().querySelectorAll("a.mfp-button");
                for (var i = 0; i < buttons.length; i++) {
                    buttons[i].removeEventListener('click', this.buttonClickHandler);
                }
            }
            if (this.getGroupHeader()) this.getGroupHeader().removeEventListener("click", this.headerClickHandler);
        }
    }, {
        key: 'attach',
        value: function attach() {
            var bgCells = this.getContent().querySelectorAll("div.mfp-bg-cell");
            var itemCells = this.getContent().querySelectorAll("div.mfp-item-cell");
            var cueCells = this.getContent().querySelectorAll(".mfp-item-table .mfp-cell-header");

            var j = 0;
            for (var i = 0; i < this._rows.count(); i++) {
                var row = this._rows.items()[i];

                for (var k = 0, m = row.cells.count(); k < m; k++) {
                    var cell = row.cells.items()[k];
                    cell.bgCell = bgCells[j];
                    cell.itemCell = itemCells[j];
                    cell.title = bgCells[j].childNodes[0];
                    cell.cueCell = cueCells[j];
                    j++;
                }
            }

            var itemTables = this.getContent().querySelectorAll(".mfp-item-table");

            for (var i = 0; i < this.groupCols.length; i++) {
                this.groupCols[i].itemTable = itemTables[i];
            }

            this.clear();
            this.init();

            if (this.getHeader()) {
                this.getHeader().addEventListener("click", this.headerClickHandler);

                var buttons = this.getHeader().querySelectorAll("a.mfp-button");
                for (var i = 0; i < buttons.length; i++) {
                    buttons[i].addEventListener('click', this.buttonClickHandler);
                }
            }
            if (this.getGroupHeader()) this.getGroupHeader().addEventListener("click", this.headerClickHandler);
        }
    }, {
        key: 'getCellAt',
        value: function getCellAt(x, y, resource) {
            var i = this.getCellIndexAt(x, y, resource);
            if (i >= this.cells.count()) {
                
            }
            return this.cells.items()[i];
        }
    }, {
        key: 'getCellIndexAt',
        value: function getCellIndexAt(x, y, resource) {
            if (!this.cellWidth) this.getDimensions();

            var cursor = DomUtils.getCursorPosition({ clientX: x, clientY: y - this.headerHeight }, this.getContent(), this.getScroller());
            var r = Math.floor(cursor.y / this.rowHeight);
            var c = Math.floor(cursor.x / this.cellWidth);

            if (r >= this._totalColumns || r < 0) {
                return null;
            }
            if (c >= this.settings.numberOfCells || c < 0) {
                return null;
            }
            var index = c + r * this.settings.numberOfCells;
            if (resource && this.cells.items()[index].resource != resource) {
                var cell = this.getTimeCell(this.cells.items()[index].startTime, false, this.resources.indexOf(resource));
                index = this.cells.indexOfItem(cell);
            }

            return index;
        }
    }, {
        key: 'getEndCell',
        value: function getEndCell(endIndex, resource) {
            endIndex = Math.min(endIndex, this.cells.count() - 1);
            var cell = this.cells.items()[endIndex];
            if (cell.resource == resource || resource == null) return cell.cellIndex;
            var groupCol = this.groupCols[this.resources.indexOf(resource)];
            var cells = this.getGroupCells(groupCol.index);
            if (cells.length == 0) {
                
            }
            return cells[cells.length - 1].cellIndex;
        }
    }, {
        key: 'getItemCueCells',
        value: function getItemCueCells(item) {
            var result = [];
            for (var i = item.startCellIndex; i <= item.lastCellIndex; i++) {
                var c = this.getGroupCells(item.groupColumnIndex)[i];
                result.push(c.cellIndex);
            }
            return result;
        }

        /**
               * For internal use only.
               * @private
               * Increases the specified date by the specified number of units.
               */

    }, {
        key: 'addUnits',
        value: function addUnits(date, count) {
            var result;
            switch (this.settings.cellUnits) {
                case TimeUnit.Second:
                    {
                        var r = new DateTime(DateTime.addSeconds2(new Date(date._date.valueOf()), count));
                        result = DateTime.addSeconds(date, count);
                        if (result < r) {
                            return r;
                        }
                        if (result._date.getHours() - r._date.getHours() > 1) {
                            this.skipNext = 3600 + count;
                        } else {
                            if (this.skipNext > 0) {
                                this.skipped = true;
                            }
                            if (this.skipNext == 0 && this.skipped) {
                                result._date.setHours(result._date.getHours() - 1);
                            }
                            this.skipNext = 0;
                        }
                        break;
                    }
                case TimeUnit.Minute:
                    {
                        var r = new DateTime(DateTime.addMinutes2(new Date(date._date.valueOf()), count));
                        result = DateTime.addMinutes(date, count);
                        if (result < r) {
                            return r;
                        }
                        if (result._date.getHours() - r._date.getHours() > 1) {
                            this.skipNext = 60 + count;
                        } else {
                            if (this.skipNext > 0) {
                                this.skipped = true;
                            }
                            if (this.skipNext == 0 && this.skipped) {
                                result._date.setHours(result._date.getHours() - 1);
                            }
                            this.skipNext = 0;
                        }
                        break;
                    }
                case TimeUnit.Hour:
                    {
                        var r = new DateTime(DateTime.addHours2(new Date(date._date.valueOf()), count));
                        result = DateTime.addHours(date, count);
                        if (result < r) {
                            return r;
                        }
                        if (result._date.getHours() - r._date.getHours() > 1) {
                            this.skipNext = 1 + count;
                        } else {
                            if (this.skipNext > 0) {
                                this.skipped = true;
                            }
                            if (this.skipNext == 0 && this.skipped) {
                                result._date.setHours(result._date.getHours() - 1);
                            }
                            this.skipNext = 0;
                        }
                        break;
                    }
                case TimeUnit.Day:
                    {
                        result = new DateTime(DateTime.addDays2(new Date(date._date.valueOf()), count));
                        break;
                    }
                case TimeUnit.Week:
                    {
                        result = new DateTime(DateTime.addWeeks2(new Date(date._date.valueOf()), count));
                        break;
                    }
                case TimeUnit.Month:
                    {
                        result = new DateTime(DateTime.addMonths2(new Date(date._date.valueOf()), count));
                        break;
                    }
                case TimeUnit.Year:
                    {
                        result = new DateTime(DateTime.addYears2(new Date(date._date.valueOf()), count));
                        break;
                    }
            }
            return result;
        }

        /**
              * For internal use only.
              * @private
              */

    }, {
        key: 'setTimeOfUnit',
        value: function setTimeOfUnit(time, day) {
            var result = 0;
            switch (this.settings.cellUnits) {
                case TimeUnit.Second:
                    result = DateTime.setTimeOfSecond(time, day);
                    break;
                case TimeUnit.Minute:
                    result = DateTime.setTimeOfMinute(time, day);
                    break;
                case TimeUnit.Hour:
                    result = DateTime.setTimeOfHour(time, day);
                    break;
                case TimeUnit.Day:
                    result = DateTime.setTimeOfDay(time, day);
                    break;
                case TimeUnit.Week:
                    result = DateTime.setDayOfWeek(time, day);
                    break;
                case TimeUnit.Month:
                    result = DateTime.setDayOfMonth(time, day);
                    break;
                case TimeUnit.Year:
                    result = DateTime.setDayOfYear(time, day);
                    break;
            }
            return result;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'unitsBetween',
        value: function unitsBetween(date1, date2) {
            var result = 0;
            switch (this.settings.cellUnits) {
                case TimeUnit.Second:
                    result = DateTime.secondsBetween(date1, date2);
                    break;
                case TimeUnit.Minute:
                    result = DateTime.minutesBetween(date1, date2);
                    break;
                case TimeUnit.Hour:
                    result = DateTime.hoursBetween(date1, date2);
                    break;
                case TimeUnit.Day:
                    result = DateTime.daysBetween(date1, date2);
                    break;
                case TimeUnit.Week:
                    result = DateTime.weeksBetween(date1, date2);
                    break;
                case TimeUnit.Month:
                    result = DateTime.monthsBetween(date1, date2);
                    break;
                case TimeUnit.Year:
                    result = DateTime.yearsBetween(date1, date2);
                    break;
            }
            return result;
        }

        /* Interactions */

    }, {
        key: 'endSelection',
        value: function endSelection(e, start, end, resource) {
            var st = this.cells.items()[start].startTime;
            var et = this.cells.items()[end].endTime;

            var item = new DummyItem(st, et, '', this.settings.cellUnits > 2, this.calendar, resource);

            get(HorizontalList.prototype.__proto__ || Object.getPrototypeOf(HorizontalList.prototype), 'endSelection', this).call(this, item);
        }

        // selectItem(e, data) {
        //     if (this._selectionPaused)
        //         return;

        //     this.calendar._itemSelection.selectSingle(data.item);
        //     this.calendar.preparePostback();
        //     this.itemData = data;
        //     this._dragging = false;
        //     this._resizing = false;
        //     this._selecting = true;

        //     data.startPos = DomUtils.getCursorPosition(e, this.getContent());

        //     if (!data.item.allowMove || data.item.locked) {
        //         return true;
        //     }
        //     if (e.target.className.indexOf('resize') > -1) {
        //         this.resize = new ResizeItem(this, data);
        //     }
        //     else if (!this.drag) {
        //         this.drag = new DragItem(this, data);
        //     }
        // }

    }, {
        key: 'endItemDrag',
        value: function endItemDrag(e, resource) {
            var cell = this.getCellAt(e.clientX, e.clientY, resource);
            var startCell = this.getGroupCells(this.itemData.appointment.groupColumnIndex)[this.itemData.startCellIndex];
            if (!cell) {
                cell = startCell;
            }

            var item = this.itemData.item;
            var app = this.itemData.appointment;
            app.row = cell;

            var startTime = this.setTimeOfUnit(item.startTime, cell.startTime);
            var endTime = app.getEndTime(startTime);
            var resource = cell.resource;

            get(HorizontalList.prototype.__proto__ || Object.getPrototypeOf(HorizontalList.prototype), 'endItemDrag', this).call(this, { startTime: startTime, endTime: endTime, resource: resource });
        }
    }, {
        key: 'endItemResize',
        value: function endItemResize(e) {

            var startCell = this.itemData.itemStartCell;
            var endCell = this.itemData.itemLastCell;

            var cell = this.getCellAt(e.clientX, e.clientY);
            if (!cell) {
                startCell = endCell = null;
            }

            var item = this.itemData.item;
            var app = this.itemData.appointment;

            var startTime;
            var resource;

            if (startCell != null) {
                startTime = DateTime.setTimeOfDay(item.startTime, startCell.startTime);
                resource = startCell.resource;
            } else {
                startTime = item.startTime;
                resource = this.getGroupCells(this.itemData.appointment.groupColumnIndex)[this.itemData.startCellIndex].resource;
            }

            var endTime = endCell != null ? endCell.endTime : item.endTime;

            get(HorizontalList.prototype.__proto__ || Object.getPrototypeOf(HorizontalList.prototype), 'endItemResize', this).call(this, { startTime: startTime, endTime: endTime, resource: resource });
        }

        /* Item placement */

    }, {
        key: 'getDimensions',
        value: function getDimensions() {
            var getBounds = DomUtils.getBounds;
            var row = this.getRows()[0];

            this.cellWidth = this.getContent().querySelector(".mfp-bg-cell-header").offsetWidth;
            this.rowHeight = getBounds(row).height;

            this.headerHeight = this.getHeader() ? getBounds(this.getHeader()).height : 0;

            var cellHeaderHeight = getBounds(DomUtils.firstRealChild(this.getBgCells()[0])).height;
            this.itemsCount = Math.floor((this.rowHeight - cellHeaderHeight) / (this.calendar.itemSettings.size + this.calendar.itemSettings.spacing));
            if (this.settings.maxItems) this.itemsCount = Math.min(this.settings.maxItems, this.itemsCount);

            this.dragWidth = this.cellWidth;

            var groupHeaderWidth = this.grouped ? getBounds(this.getGroupHeader()).width : 0;
            this.dragOffsetLeft = getBounds(this.calendar.getElement()).x + groupHeaderWidth;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'clear',
        value: function clear() {
            DomUtils.removeNodes(this.getContent().querySelectorAll('.mfp-item-wrap'));
            DomUtils.removeNodes(this.getContent().querySelectorAll('.mfp-item-row'));
        }
    }, {
        key: 'init',
        value: function init() {
            if (!this.cellWidth) this.getDimensions();

            this.getAllItems();

            for (var k = 0, m = this.groupCols.length; k < m; k++) {
                this.itemsToPut = this.getItemsToPut(k);

                for (var i = 0; i < this.itemsToPut.length; i++) {
                    this.itemsToPut[i].cell = null;
                    this.itemsToPut[i].row = -1;
                }

                this.createItemsTable(this._rows.items()[k], k);

                for (var i = 0; i < this.itemsToPut.length; i++) {
                    var item = this.items[this.items.indexOf(this.itemsToPut[i])];
                    item.cell = null;
                    item.row = -1;
                    item.hidden = true;
                }
            }

            this.placeItems();

            if (this.calendar.itemSettings.showItems) {
                this.getCues();
                this.createCues();
            }
        }
    }, {
        key: 'createItemsTable',
        value: function createItemsTable(row, groupCol) {
            var items = this.getItemsToPutInCol(groupCol);

            for (var i = 0, l = this.itemsCount; i < l; i++) {
                var trow = document.createElement('tr');
                trow.className = 'mfp-item-row';
                var day = 0;
                while (day < this.rowCellsCount) {
                    var items = this.getItemsInCell(row.cells.items()[day], this.itemsToPut);
                    var item = null;
                    if (items.length > 0) item = items[0];
                    if (item != null) {
                        var tcell = document.createElement('td');
                        tcell.className = 'mfp-item-cell';
                        tcell.colSpan = item.cellsLength;
                        day += item.cellsLength - 1;
                        item.cell = tcell;
                        item.row = i;
                        this.itemsToPut.splice(this.itemsToPut.indexOf(item), 1);
                    } else {
                        var tcell = document.createElement('td');
                        tcell.className = 'mfp-item-cell';
                    }
                    trow.appendChild(tcell);
                    day += 1;
                }

                this.groupCols[groupCol].itemTable.getElementsByTagName("TBODY")[0].appendChild(trow);
            }
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'updateItem',
        value: function updateItem(appointment, addToItems) {
            var item = appointment.item;
            appointment.groupColumnIndex = this.getItemCols(item);

            //invisible items
            if (!item.visible) {
                return appointment;
            }
            var appointment = appointment;

            var parts = [];
            var removed = [];
            if (!this.hasVisibleParts(item)) {
                removed.push(appointment);
            } else if (this.isComposite(item)) {
                var st = DateTime.maxDate(item.startTime, this.itemsStartTime, false);
                var et = DateTime.minDate(item.endTime, this.itemsEndTime, true);

                var partIndex = 0;
                if (st.compareTo(item.startTime) == 1) // right arrow
                    partIndex = 1;
                if (et.compareTo(item.endTime) == -1) // left arrow
                    partIndex = -1;
                if (st.compareTo(item.startTime) == 1 && et.compareTo(item.endTime) == -1) // both arrows
                    partIndex = 0;

                if (appointment.groupColumnIndex.length == 1) {
                    var scell = this.getTimeCell(st, false, appointment.groupColumnIndex);
                    var lcell = this.getTimeCell(et, true, appointment.groupColumnIndex);
                    var partData = {
                        prototype: appointment,
                        type: 'part',
                        cellIndex: scell.index,
                        cellsLength: lcell.index - scell.index + 1,
                        colIndex: 0,
                        isPartial: true,
                        partIndex: partIndex,
                        lastCellIndex: lcell.index,
                        startCellIndex: scell.index,
                        groupColumnIndex: appointment.groupColumnIndex
                    };
                    var part = new Appointment(partData);
                    part.composite = true;
                    parts.push(part);
                    removed.push(appointment);
                } else if (appointment.groupColumnIndex.length > 1) {
                    for (var i = 0, l = appointment.groupColumnIndex.length; i < l; i++) {
                        var scell = this.getTimeCell(st, false, appointment.groupColumnIndex[i]);
                        var lcell = this.getTimeCell(et, true, appointment.groupColumnIndex[i]);
                        var partData = {
                            prototype: appointment,
                            type: 'part',
                            cellIndex: scell.index,
                            cellsLength: lcell.index - scell.index + 1,
                            colIndex: scell.rowIndex,
                            isPartial: true,
                            partIndex: partIndex,
                            lastCellIndex: lcell.index,
                            startCellIndex: scell.index,
                            groupColumnIndex: appointment.groupColumnIndex[i]
                        };
                        var part = new Appointment(partData);
                        part.composite = true;
                        parts.push(part);
                        removed.push(appointment);
                    }
                }
            } else if (appointment.groupColumnIndex.length == 1) {
                var cell = this.getTimeCell(item.startTime, false, appointment.groupColumnIndex);
                if (item.startTime._date.valueOf() == item.endTime._date.valueOf()) {
                    var lcell = cell;
                } else {
                    var lcell = this.getTimeCell(item.endTime, true, appointment.groupColumnIndex);
                }
                appointment.lastCellIndex = lcell.index;
                appointment.startCellIndex = cell.index;
                appointment.cellsLength = lcell.index - cell.index + 1;
                if (appointment.cellsLength < 1) {
                    appointment.cellsLength = 1;
                }
                appointment.cellIndex = cell.index;
                appointment.colIndex = cell.rowIndex;
                appointment.updateVisual();
                //this.updateItemVisual(appointment);
            } else if (appointment.groupColumnIndex.length > 1) {
                for (var i = 0, l = appointment.groupColumnIndex.length; i < l; i++) {
                    var cell = this.getTimeCell(item.startTime, false, appointment.groupColumnIndex[i]);
                    if (item.startTime._date.valueOf() == item.endTime._date.valueOf()) {
                        var lcell = cell;
                    } else {
                        var lcell = this.getTimeCell(item.endTime, true, appointment.groupColumnIndex[i]);
                    }
                    var partData = {
                        prototype: appointment,
                        type: 'part',
                        cellIndex: cell.index,
                        cellsLength: lcell.index - cell.index + 1,
                        colIndex: appointment.groupColumnIndex[i],
                        isPartial: true,
                        partIndex: appointment.partIndex,
                        lastCellIndex: lcell.index,
                        startCellIndex: cell.index,
                        groupColumnIndex: appointment.groupColumnIndex[i]
                    };
                    var part = new Appointment(partData);
                    part.composite = true;
                    parts.push(part);
                    removed.push(appointment);
                }
            }

            for (var i = 0; i < removed.length; i++) {
                this.removeAppointment(removed[i]);
                // removed[i].dispose();
            }

            if (addToItems != false) this.items = this.items.concat(parts);

            for (var i = 0; i < parts.length; i++) {
                parts[i].updateVisual();
                //this.updateItemVisual(parts[i]);
            }

            //return value is only used for recurrent composite items
            if (parts.length > 0) return parts;
            parts.push(appointment);
            return parts;
        }

        /**
               * Gets the cell that corresponds to the specified time.
               * @param {Object} [time] The time to search for.
               * @param {Boolean} [isEndTime] true if the index of the first interval is returned when the time is the boundary between two consecutive intervals;
               false if the index of the second interval is contained.
               * @returns {Object} The cell that holds the specified time.
               */

    }, {
        key: 'getTimeCell',
        value: function getTimeCell(time, isEndTime, col) {

            if (col.length != undefined) col = col[0];

            var cells = this.getGroupCells(col);

            if (time.valueOf() < this.startTime.valueOf()) return null;
            if (time.valueOf() > this.endTime.valueOf()) return null;

            var t = this.setTimeOfUnit(this.startTime, time);
            var i = this.unitsBetween(this.startTime, t);

            if (this.skipNext > 0 && i > cells.length) {
                return cells[cells.length - 1];
            }

            if (i > cells.length) return null;
            if (i == cells.length) {
                if (isEndTime && time.equals(cells[i - 1].endTime)) return cells[i - 1];else return null;
            }
            if (isEndTime && DateTime.isSameDate(time, cells[i].startTime) && i > 0) {
                i -= 1;
            }

            return cells[i];
        }
    }, {
        key: 'getTimeCells',
        value: function getTimeCells(startTime, endTime, isEndTime, col) {
            var startCell = null;
            var endCell = null;

            if (col.length != undefined) col = col[0];

            if (col < 0 || col > this.groupCols.length - 1) return null;

            var cells = this.getGroupCells(col);

            if (startTime.valueOf() < this.startTime.valueOf()) {
                startCell = cells[0];
            } else if (startTime.valueOf() > this.endTime.valueOf()) {
                return [];
            } else {
                startCell = this.getTimeCell(startTime, false, col);
            }
            if (endTime !== null && typeof endTime !== "undefined" && typeof endTime._date !== "undefined") {
                if (endTime.valueOf() > this.endTime.valueOf()) {
                    endCell = cells.items()[cells.count() - 1];
                } else if (endTime.valueOf() < this.startTime.valueOf()) {
                    return [];
                } else {
                    endCell = this.getTimeCell(endTime, isEndTime, col);
                }
            } else {
                endCell = startCell;
            }

            if (startCell && endCell) {
                return cells.slice(startCell.index, endCell.index + 1);
            }
            return [];
        }

        /**
             * For internal use only.
             * @private
             */

    }, {
        key: 'isComposite',
        value: function isComposite(item) {
            if (item.startTime._date.valueOf() == item.endTime._date.valueOf()) {
                return false;
            }
            if (item.startTime._date.valueOf() < this._rows.items()[0].itemsStartTime._date.valueOf()) {
                return true;
            }
            if (item.endTime._date.valueOf() > this._rows.items()[this._rows.count() - 1].itemsEndTime._date.valueOf()) {
                return true;
            }
            return false;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'hasVisibleParts',
        value: function hasVisibleParts(item) {
            if (this.grouped && this.getItemCols(item).length == 0) return false;
            if (item.startTime._date.valueOf() >= this._rows.items()[0].itemsStartTime._date.valueOf() && item.startTime._date.valueOf() < this._rows.items()[this._rows.count() - 1].itemsEndTime._date.valueOf()) return true;
            if (item.endTime._date.valueOf() > this._rows.items()[0].itemsStartTime._date.valueOf() && item.endTime._date.valueOf() < this._rows.items()[this._rows.count() - 1].itemsEndTime._date.valueOf()) return true;
            if (item.startTime._date.valueOf() <= this._rows.items()[0].itemsStartTime._date.valueOf() && item.endTime._date.valueOf() >= this._rows.items()[0].itemsEndTime._date.valueOf()) return true;
            return false;
        }
    }, {
        key: 'checkElementBounds',
        value: function checkElementBounds(bounds, x, y, y2) {
            for (var i = 0; i < bounds.length; i++) {
                if (x == bounds[i].x) {
                    if (y >= bounds[i].y && y < bounds[i].y2 || y2 >= bounds[i].y && y2 < bounds[i].y2) return false;
                }
            }
            return true;
        }
    }, {
        key: 'getItemsInCell',
        value: function getItemsInCell(cell, items) {
            var result = [];
            for (var i = 0, l = items.length; i < l; i++) {
                if (items[i].startCellIndex == cell.index) result.push(items[i]);
            }
            return result;
        }
    }, {
        key: 'getAllItemsInCell',
        value: function getAllItemsInCell(cell) {
            var result = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].groupColumnIndex == cell.columnIndex) {
                    if (this.items[i].startCellIndex <= cell.index && this.items[i].lastCellIndex >= cell.index) {
                        if (this.items[i].row < this.itemsCount || this.items[i].row == -1) {
                            result.push(this.items[i]);
                        }
                    }
                }
            }
            return result;
        }
    }, {
        key: 'getItemsInCol',
        value: function getItemsInCol(index) {
            var result = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].groupColumnIndex == index && this.items[i].item.visible == true) {
                    result.push(this.items[i]);
                }
            }
            return result;
        }
    }, {
        key: 'getItemCols',
        value: function getItemCols(item) {
            var result = [];
            if (this.resources == null || !this.grouped) {
                result.push(0);
                return result;
            }
            for (var i = 0, l = this.resources.length; i < l; i++) {
                if (item.hasResource(this.resources[i])) {
                    result.push(i);
                }
            }
            return result;
        }
    }, {
        key: 'getItemCell',
        value: function getItemCell(item) {
            return this.cells.items()[item.cellIndex + item.groupColumnIndex * this._rows.count()];
        }
    }, {
        key: 'getGroupCells',
        value: function getGroupCells(col) {
            if (col.length) col = col[0];

            var cells = [];
            this.cells.forEach(function (t) {
                if (t.columnIndex == col) cells.push(t);
            });
            return cells;
        }
    }, {
        key: 'getItemRow',
        value: function getItemRow(row, col) {

            return this.getGroupCells(col)[row.index].itemCell;
        }
    }, {
        key: 'getItemHeight',
        value: function getItemHeight(item) {
            if (!this.rowHeight) {
                this.getDimensions();
            }
            return Math.floor(this.rowHeight * item.cellsLength);
        }
    }, {
        key: 'getItemsToPut',
        value: function getItemsToPut(groupCol) {
            var result = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].item.visible && this.items[i].groupColumnIndex == groupCol) {
                    result.push(this.items[i]);
                }
            }
            return result;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getItemsToPutInCol',
        value: function getItemsToPutInCol(groupCol) {
            var items = [];
            for (var i = 0, l = this.itemsToPut.length; i < l; i++) {
                if (this.itemsToPut[i].groupColumnIndex == groupCol) items.push(this.itemsToPut[i]);
            }
            return items;
        }
    }, {
        key: 'getItemsCountInRow',
        value: function getItemsCountInRow(row, groupCol) {
            var items = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].groupColumnIndex == groupCol && this.items[i].startCellIndex == row.index && this.items[i].cell != null && this.items[i].row != -1) items.push(this.items[i]);
                if (this.items[i].groupColumnIndex == groupCol && this.items[i].startCellIndex < row.index && this.items[i].lastCellIndex >= row.index && this.items[i].cell != null && this.items[i].row != -1) items.push(this.items[i]);
            }
            return items.length;
        }

        /*Rendering*/

    }, {
        key: 'draw',
        value: function draw() {

            this._element = document.createElement("div");

            if (this._groupColumns > 0) {
                var g = this.drawGroupHeader();
                this._element.appendChild(g);
            }

            var d1 = document.createElement("div");
            d1.className = "mfp-scroller";
            this._element.appendChild(d1);

            var d2 = document.createElement("div");
            d2.className = "mfp-wrapper";
            if (this.settings.numberOfCells > this.settings.visibleCells) {
                var w = Unit.percentage(Math.round(100 / this.settings.visibleCells * this.settings.numberOfCells, 2)).toString();
                d2.style.width = w;
            }
            d1.appendChild(d2);

            if (this.settings.headerStyle !== MainHeaderStyle.None) {
                var header = this.drawHeader();
                d2.appendChild(header);

                if ((this.settings.headerStyle & MainHeaderStyle.Buttons) === MainHeaderStyle.Buttons) {
                    var b = this.drawHeaderButtons();
                    header.appendChild(b);
                }
            }

            var content = this.drawContent();
            d2.appendChild(content);
            return this._element;
        }
    }, {
        key: 'drawGroupHeader',
        value: function drawGroupHeader() {

            var result = null;
            var groupName;

            var d = document.createElement("div");
            d.className = "mfp-header-group";
            result = d;

            var d1 = document.createElement("div");
            d.appendChild(d1);

            for (var k = 0; k < this._totalColumns; k++) {

                groupName = this.calendar.getResourceName(this.calendar.groupResources.items()[k]);

                var g = document.createElement("div");
                d.appendChild(g);

                var a = document.createElement("a");
                g.appendChild(a);
                a.innerHTML = groupName || "&nbsp;";
            }

            var d2 = document.createElement("div");
            d.appendChild(d2);

            return result;
        }
    }, {
        key: 'drawHeader',
        value: function drawHeader() {
            var result = null;

            var time = this._date.clone();

            var header = document.createElement("div");
            header.className = "mfp-header";
            result = header;

            if ((this.settings.headerStyle & MainHeaderStyle.Title) === MainHeaderStyle.Title) {
                for (var day = 0; day < this.settings.numberOfCells; day++) {
                    var d = document.createElement("div");
                    d.innerHTML = time.toString(this.settings.titleFormat, this.formatInfo);
                    header.appendChild(d);
                    time = this.addUnits(time, 1);
                }
            }

            return result;
        }
    }, {
        key: 'drawHeaderButtons',
        value: function drawHeaderButtons(parent) {
            var result = null;

            var d = document.createElement("div");
            d.className = "mfp-button-wrap";
            result = d;

            var b1 = document.createElement("a");
            DomUtils.addCssClass(b1, "mfp-button");
            DomUtils.addCssClass(b1, "mfp-button-prev");
            if (this.calendar.showTooltips) {
                b1.title = this.getHeaderButtonTooltip(-1);
            }
            var s = document.createElement("span");
            b1.appendChild(s);
            d.appendChild(b1);

            var b2 = document.createElement("a");
            DomUtils.addCssClass(b2, "mfp-button");
            DomUtils.addCssClass(b2, "mfp-button-next");
            if (this.calendar.showTooltips) {
                b2.title = this.getHeaderButtonTooltip(0);
            }
            s = document.createElement("span");
            b2.appendChild(s);
            d.appendChild(b2);

            return result;
        }
    }, {
        key: 'getHeaderButtonTooltip',
        value: function getHeaderButtonTooltip(step) {
            var time = step == -1 ? this._date : this._lastDate;

            var result = "";

            var d = this.formatInfo.dateFormats;

            switch (this.settings.cellUnits) {
                case TimeUnit.Second:
                    result = DateTime.addSeconds(time, step).toString(d.longTime, this.formatInfo);
                    break;
                case TimeUnit.Minute:
                    result = DateTime.addMinutes(time, step).toString(d.longTime, this.formatInfo);
                    break;
                case TimeUnit.Hour:
                    result = DateTime.addHours(time, step).toString(d.longTime, this.formatInfo);
                    break;
                case TimeUnit.Day:
                    result = DateTime.addDays(time, step).toString(d.longDate, this.formatInfo);
                    break;
                case TimeUnit.Week:
                    result = DateTime.addDays(time, step * 7).toString(d.longDate, this.formatInfo);
                    result += " - ";
                    result += time.toString(d.longDate, this.formatInfo);
                    break;
                case TimeUnit.Month:
                    result = DateTime.addMonths(time, step).toString(d.yearMonth, this.formatInfo);
                    break;
                case TimeUnit.Year:
                    result = DateTime.addYears(time, step).toString(d.yearMonth, this.formatInfo);
                    break;
            }

            return result;
        }
    }, {
        key: 'drawContent',
        value: function drawContent() {

            var result = null;
            var output = this.calendar.renderer;

            var content = document.createElement("div");
            content.className = "mfp-content";
            result = content;

            for (var k = 0; k < this._totalColumns; k++) {

                var r = document.createElement("div");
                r.style.height = Unit.percentage(Math.round(100 / this._totalColumns, 2)).toString();
                r.className = "mfp-wrap";
                content.appendChild(r);

                var t = this.drawBackgroundTable();
                r.appendChild(t);

                var t = this.drawItemTable();
                r.appendChild(t);
            }

            return result;
        }
    }, {
        key: 'drawBackgroundTable',
        value: function drawBackgroundTable() {
            var result = null;

            var startDate = this._date;

            var r = document.createElement("div");
            r.className = "mfp-bg-row";
            result = r;

            for (var k = 0; k < this.settings.numberOfCells; k++) {

                var d = this.drawDay(startDate);
                d.className = "mfp-bg-cell";

                var dayOfWeek = startDate.dayOfWeek;
                if (dayOfWeek === DayOfWeek.Saturday || dayOfWeek === DayOfWeek.Sunday) d.className += " mfp-weekend-cell";

                r.appendChild(d);

                startDate = this.addUnits(startDate, 1);
            }

            return result;
        }
    }, {
        key: 'drawDay',
        value: function drawDay(day) {
            var result = null;

            var dayOfMonth = DateTime.getDayOfMonth(day);
            var month = DateTime.getMonth(day);

            var t = document.createElement("div");
            result = t;

            var title = document.createElement("div");
            title.className = "mfp-bg-cell-header";
            t.appendChild(title);

            if (month == 1 && dayOfMonth == 1) title.innerHTML = day.toString(this.settings.firstDayOfYearFormat, this.formatInfo);else if (month != 1 && dayOfMonth == 1) title.innerHTML = day.toString(this.settings.firstDayOfMonthFormat, this.formatInfo);else title.innerHTML = day.toString(this.settings.generalFormat, this.formatInfo);

            return result;
        }
    }, {
        key: 'drawItemTable',
        value: function drawItemTable() {
            var result = null;

            var startDate = this._date;

            var t = document.createElement("table");
            t.className = "mfp-item-table";
            t.cellSpacing = 0;
            t.cellPadding = 0;
            result = t;

            var tb = document.createElement("tbody");
            t.appendChild(tb);

            var tr = document.createElement("tr");
            tb.appendChild(tr);

            for (var k = 0; k < this.settings.numberOfCells; k++) {
                var td = document.createElement("td");
                if (this.calendar.showTooltips) td.title = startDate.toString(this.formatInfo.dateFormats.longDate, this.formatInfo);

                tr.appendChild(td);
                var d = document.createElement("div");
                d.className = "mfp-cell-header";
                td.appendChild(d);

                startDate = this.addUnits(startDate, 1);
            }

            return result;
        }

        /*End Render*/

    }, {
        key: 'cells',
        get: function get$$1() {
            var result = new List();
            this._rows.forEach(function (t) {
                result.addRange(t.cells.items());
            }, this);

            result.sort(function (a, b) {
                return a.cellIndex - b.cellIndex;
            });
            return result;
        }
    }, {
        key: 'cssClass',
        get: function get$$1() {
            return "mfp-list-view";
        }
    }]);
    return HorizontalList;
}(Cell);

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* For internal use only.
* @private
*/

var VerticalList = function (_Cell) {
    inherits(VerticalList, _Cell);

    function VerticalList(calendar) {
        classCallCheck(this, VerticalList);

        var _this = possibleConstructorReturn(this, (VerticalList.__proto__ || Object.getPrototypeOf(VerticalList)).call(this, calendar));

        _this._settings = _this.calendar.listSettings;

        _this._rows = new List();

        _this.initVars();

        _this._dragging = false;
        _this._resizing = false;
        _this._selecting = false;
        _this._selectionPaused = false;

        _this.items = [];

        _this.Dom = {};
        return _this;
    }

    createClass(VerticalList, [{
        key: 'initVars',
        value: function initVars() {

            var d = this.calendar.date.clone();

            switch (this.settings.cellUnits) {
                case TimeUnit.Second:
                    {
                        this._date = new DateTime(Date.UTC(d.year, d.month, d.day, d.hour, d.minute, d.second));
                        break;
                    }
                case TimeUnit.Minute:
                    {
                        this._date = new DateTime(Date.UTC(d.year, d.month, d.day, d.hour, d.minute, 0));
                        break;
                    }
                case TimeUnit.Hour:
                    {
                        this._date = new DateTime(Date.UTC(d.year, d.month, d.day, d.hour, 0, 0));
                        break;
                    }
                case TimeUnit.Week:
                    {
                        var fd = this.calendar.getWeekFirstDate(d);
                        this._date = new DateTime(Date.UTC(fd.year, fd.month, fd.day, 0, 0, 0));
                        break;
                    }
                case TimeUnit.Month:
                    {
                        this._date = new DateTime(Date.UTC(d.year, d.month, 1, 0, 0, 0));
                        break;
                    }
                case TimeUnit.Year:
                    {
                        this._date = new DateTime(Date.UTC(d.year, 1, 1, 0, 0, 0));

                        break;
                    }
                default:
                    {
                        this._date = new DateTime(Date.UTC(d.year, d.month, d.day, 0, 0, 0));
                        break;
                    }
            }

            this.calendar._date = this._date;

            var firstVisibleDate = this._date;

            switch (this.settings.cellUnits) {
                case TimeUnit.Second:
                    this._lastDate = DateTime.addSeconds(firstVisibleDate, this.settings.numberOfCells);
                    break;
                case TimeUnit.Minute:
                    this._lastDate = DateTime.addMinutes(firstVisibleDate, this.settings.numberOfCells);
                    break;
                case TimeUnit.Hour:
                    this._lastDate = DateTime.addHours(firstVisibleDate, this.settings.numberOfCells);
                    break;
                case TimeUnit.Week:
                    this._lastDate = DateTime.addDays(firstVisibleDate, this.settings.numberOfCells * 7);
                    break;
                case TimeUnit.Month:
                    this._lastDate = DateTime.addMonths(firstVisibleDate, this.settings.numberOfCells);
                    break;
                case TimeUnit.Year:
                    this._lastDate = DateTime.addYears(firstVisibleDate, this.settings.numberOfCells);
                    break;
                default:
                    this._lastDate = DateTime.addDays(firstVisibleDate, this.settings.numberOfCells);
                    break;
            }

            this._groupColumns = 0;
            if (this.calendar.realGroupType != GroupType.None) this._groupColumns = this.calendar.groupResources.count();
            this._totalColumns = this._groupColumns == 0 ? 1 : this._groupColumns;

            this.createCells();
        }

        /* Dom */

    }, {
        key: 'getContent',
        value: function getContent() {
            if (!this.Dom.content) {
                this.Dom.content = this.calendar.getElement().querySelector("div.mfp-scroller");
            }
            return this.Dom.content;
        }
    }, {
        key: 'getGroupHeader',
        value: function getGroupHeader() {
            if (!this.Dom.groupHeader) {
                this.Dom.groupHeader = this.calendar.getElement().querySelector("div.mfp-header-group");
            }
            return this.Dom.groupHeader;
        }
    }, {
        key: 'getRows',
        value: function getRows() {
            if (!this.Dom.rows) {
                this.Dom.rows = this.calendar.getElement().querySelectorAll('div.mfp-item-row');
            }
            return this.Dom.rows;
        }
    }, {
        key: 'getBgCells',
        value: function getBgCells() {
            if (!this.Dom.bgCells) {
                this.Dom.bgCells = this.calendar.getElement().querySelectorAll('div.mfp-bg-cell');
            }
            return this.Dom.bgCells;
        }
    }, {
        key: 'createCells',
        value: function createCells() {

            this.startTime = this.itemsStartTime = this._date;
            this.endTime = this.itemsEndTime = this._lastDate;

            this._columns = new List();
            for (var i = 0; i < this._totalColumns; i++) {
                var col = new ViewColumn(i, this._date, this._date, this._lastDate);
                col.resource = this.resources[i];
                this._columns.add(col);
            }

            this.rowCellsCount = 1;

            var startDate = this._date;
            var endDate = this.addUnits(startDate, 1);
            var j = 0;
            for (var i = 0; i < this.settings.numberOfCells; i++) {
                var row = new ViewRow(startDate, endDate, startDate, endDate);
                row.index = i;

                for (var k = 0, m = this.rowCellsCount; k < m; k++) {
                    if (this.skipNext > 0 && k <= this.skipNext) {
                        var cst = this.addUnits(startDate, k);
                        var cet = this.addUnits(startDate, k + 1);
                    } else {
                        var cellStartTime = this.addUnits(startDate, k);
                        var cellEndTime = this.addUnits(startDate, k + 1);
                    }
                    var cell = new ViewCell();
                    cell.index = j;
                    cell.cellIndex = j;
                    cell.rowIndex = i;
                    cell.startTime = cellStartTime;
                    cell.endTime = cellEndTime;
                    cell.columnIndex = 0;

                    if (this.grouped) {
                        cell.resource = this.resources == null ? null : this.resources[0];
                    }
                    row.cells.add(cell);
                    j += 1;
                }

                startDate = this.addUnits(startDate, 1);
                endDate = this.addUnits(endDate, 1);
                this._rows.add(row);
            }

            this.groupCols = [];

            var col = new ViewColumn(0, this._date, this._date, this._date);
            col.resource = this.resources == null ? null : this.resources[0];

            this.groupCols.push(col);

            if (this._totalColumns > 1) {
                var rcells = this.cells.items().slice(0);

                for (var i = 1, l = this._totalColumns; i < l; i++) {
                    for (var k = 0, m = rcells.length; k < m; k++) {
                        var cell = new ViewCell();
                        cell.index = rcells[k].index;
                        cell.cellIndex = this.settings.numberOfCells * i + k;
                        cell.rowIndex = rcells[k].rowIndex;
                        cell.startTime = rcells[k].startTime;
                        cell.endTime = rcells[k].endTime;
                        cell.columnIndex = i;

                        if (this.grouped) {
                            cell.resource = this.resources == null ? null : this.resources[i];
                        }

                        this._rows.items()[cell.rowIndex].cells.add(cell);
                    }

                    var col = new ViewColumn(i, this._date, this._date, this._date);
                    col.resource = this.resources == null ? null : this.resources[i];
                    this.groupCols.push(col);
                }
            }
        }
    }, {
        key: 'detach',
        value: function detach() {
            if (this.getHeader()) {
                this.getHeader().removeEventListener("click", this.headerClickHandler);

                var buttons = this.getHeader().querySelectorAll("a.mfp-button");
                for (var i = 0; i < buttons.length; i++) {
                    buttons[i].removeEventListener('click', this.buttonClickHandler);
                }
            }

            if (this.getGroupHeader()) this.getGroupHeader().removeEventListener("click", this.headerClickHandler);
        }
    }, {
        key: 'attach',
        value: function attach() {

            if (this.settings.numberOfCells > this.settings.visibleCells) {
                var h = Unit.percentage(Math.round(100 / this.settings.visibleCells * this.settings.numberOfCells, 2)).toString();
                this.getContent().children[0].style.height = h;
            }

            var bgCells = this.getBgCells();
            var itemCells = this.getContent().querySelectorAll("div.mfp-item-cell");
            var cueCells = this.getContent().querySelectorAll(".mfp-item-table .mfp-cell-header");

            var j = 0;
            for (var i = 0; i < this._rows.count(); i++) {
                var row = this._rows.items()[i];
                // row.bgTable = bgTables[i];
                // row.itemTable = itemTables[i];

                for (var k = 0, m = row.cells.count(); k < m; k++) {
                    var cell = row.cells.items()[k];
                    cell.bgCell = bgCells[j];
                    cell.itemCell = itemCells[j];
                    cell.title = bgCells[j].childNodes[0];
                    cell.cueCell = cueCells[j];
                    j++;
                }
            }

            this.clear();
            this.init();

            if (this.getHeader()) {
                this.getHeader().addEventListener("click", this.headerClickHandler);
                var buttons = this.getHeader().querySelectorAll("a.mfp-button");
                for (var i = 0; i < buttons.length; i++) {
                    buttons[i].addEventListener('click', this.buttonClickHandler);
                }
            }

            if (this.getGroupHeader()) this.getGroupHeader().addEventListener("click", this.headerClickHandler);
        }
    }, {
        key: 'getCellAt',
        value: function getCellAt(x, y, resource) {
            var i = this.getCellIndexAt(x, y, resource);
            if (i >= this.cells.count()) {
                
            }
            return this.cells.items()[i];
        }
    }, {
        key: 'getCellIndexAt',
        value: function getCellIndexAt(x, y, resource) {
            if (!this.cellWidth) this.getDimensions();

            var cursor = DomUtils.getCursorPosition({ clientX: x - this.headerWidth, clientY: y }, this.getContent(), this.getScroller());
            var r = Math.floor(cursor.y / this.calculatedCellHeight);
            var c = Math.floor(cursor.x / this.cellWidth);

            if (r >= this.settings.numberOfCells || r < 0) {
                return null;
            }
            if (c >= this._totalColumns || c < 0) {
                return null;
            }

            var index = r + c * this._rows.count();

            if (resource && this.cells.items()[index].resource != resource) {
                var cell = this.getTimeCell(this.cells.items()[index].startTime, false, this.resources.indexOf(resource));
                index = this.cells.indexOfItem(cell);
            }

            return index;
        }
    }, {
        key: 'getItemCueCells',
        value: function getItemCueCells(item) {
            var result = [];
            for (var i = item.startCellIndex; i <= item.lastCellIndex; i++) {
                var c = this.getGroupCells(item.groupColumnIndex)[i];
                result.push(c.index * this._totalColumns + c.columnIndex);
            }
            return result;
        }
    }, {
        key: 'getEndCell',
        value: function getEndCell(endIndex, resource) {
            endIndex = Math.min(endIndex, this.cells.count() - 1);
            var cell = this.cells.items()[endIndex];
            if (cell.resource == resource || resource == null) return cell.cellIndex;
            var groupCol = this.groupCols[this.resources.indexOf(resource)];
            var cells = this.getGroupCells(groupCol.index);
            if (cells.length == 0) {
                
            }
            return cells[cells.length - 1].cellIndex;
        }

        /**
               * For internal use only.
               * @private
               * Increases the specified date by the specified number of units.
               */

    }, {
        key: 'addUnits',
        value: function addUnits(date, count) {
            var result;
            switch (this.settings.cellUnits) {
                case TimeUnit.Second:
                    {
                        var r = new DateTime(DateTime.addSeconds2(new Date(date._date.valueOf()), count));
                        result = DateTime.addSeconds(date, count);
                        if (result < r) {
                            return r;
                        }
                        if (result._date.getHours() - r._date.getHours() > 1) {
                            this.skipNext = 3600 + count;
                        } else {
                            if (this.skipNext > 0) {
                                this.skipped = true;
                            }
                            if (this.skipNext == 0 && this.skipped) {
                                result._date.setHours(result._date.getHours() - 1);
                            }
                            this.skipNext = 0;
                        }
                        break;
                    }
                case TimeUnit.Minute:
                    {
                        var r = new DateTime(DateTime.addMinutes2(new Date(date._date.valueOf()), count));
                        result = DateTime.addMinutes(date, count);
                        if (result < r) {
                            return r;
                        }
                        if (result._date.getHours() - r._date.getHours() > 1) {
                            this.skipNext = 60 + count;
                        } else {
                            if (this.skipNext > 0) {
                                this.skipped = true;
                            }
                            if (this.skipNext == 0 && this.skipped) {
                                result._date.setHours(result._date.getHours() - 1);
                            }
                            this.skipNext = 0;
                        }
                        break;
                    }
                case TimeUnit.Hour:
                    {
                        var r = new DateTime(DateTime.addHours2(new Date(date._date.valueOf()), count));
                        result = DateTime.addHours(date, count);
                        if (result < r) {
                            return r;
                        }
                        if (result._date.getHours() - r._date.getHours() > 1) {
                            this.skipNext = 1 + count;
                        } else {
                            if (this.skipNext > 0) {
                                this.skipped = true;
                            }
                            if (this.skipNext == 0 && this.skipped) {
                                result._date.setHours(result._date.getHours() - 1);
                            }
                            this.skipNext = 0;
                        }
                        break;
                    }
                case TimeUnit.Day:
                    {
                        result = new DateTime(DateTime.addDays2(new Date(date._date.valueOf()), count));
                        break;
                    }
                case TimeUnit.Week:
                    {
                        result = new DateTime(DateTime.addWeeks2(new Date(date._date.valueOf()), count));
                        break;
                    }
                case TimeUnit.Month:
                    {
                        result = new DateTime(DateTime.addMonths2(new Date(date._date.valueOf()), count));
                        break;
                    }
                case TimeUnit.Year:
                    {
                        result = new DateTime(DateTime.addYears2(new Date(date._date.valueOf()), count));
                        break;
                    }
            }
            return result;
        }

        /**
              * For internal use only.
              * @private
              */

    }, {
        key: 'setTimeOfUnit',
        value: function setTimeOfUnit(time, day) {
            var result = 0;
            switch (this.settings.cellUnits) {
                case TimeUnit.Second:
                    result = DateTime.setTimeOfSecond(time, day);
                    break;
                case TimeUnit.Minute:
                    result = DateTime.setTimeOfMinute(time, day);
                    break;
                case TimeUnit.Hour:
                    result = DateTime.setTimeOfHour(time, day);
                    break;
                case TimeUnit.Day:
                    result = DateTime.setTimeOfDay(time, day);
                    break;
                case TimeUnit.Week:
                    result = DateTime.setDayOfWeek(time, day);
                    break;
                case TimeUnit.Month:
                    result = DateTime.setDayOfMonth(time, day);
                    break;
                case TimeUnit.Year:
                    result = DateTime.setDayOfYear(time, day);
                    break;
            }
            return result;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'unitsBetween',
        value: function unitsBetween(date1, date2) {
            var result = 0;
            switch (this.settings.cellUnits) {
                case TimeUnit.Second:
                    result = DateTime.secondsBetween(date1, date2);
                    break;
                case TimeUnit.Minute:
                    result = DateTime.minutesBetween(date1, date2);
                    break;
                case TimeUnit.Hour:
                    result = DateTime.hoursBetween(date1, date2);
                    break;
                case TimeUnit.Day:
                    result = DateTime.daysBetween(date1, date2);
                    break;
                case TimeUnit.Week:
                    result = DateTime.weeksBetween(date1, date2);
                    break;
                case TimeUnit.Month:
                    result = DateTime.monthsBetween(date1, date2);
                    break;
                case TimeUnit.Year:
                    result = DateTime.yearsBetween(date1, date2);
                    break;
            }
            return result;
        }

        /* Interactions */

    }, {
        key: 'endSelection',
        value: function endSelection(e, start, end, resource) {
            var st = this.cells.items()[start].startTime;
            var et = this.cells.items()[end].endTime;

            var item = new DummyItem(st, et, '', this.settings.cellUnits > 2, this.calendar, resource);

            get(VerticalList.prototype.__proto__ || Object.getPrototypeOf(VerticalList.prototype), 'endSelection', this).call(this, item);
        }
    }, {
        key: 'endItemDrag',
        value: function endItemDrag(e, resource) {
            var cell = this.getCellAt(e.clientX, e.clientY, resource);
            var startCell = this.getGroupCells(this.itemData.appointment.groupColumnIndex)[this.itemData.startCellIndex];
            if (!cell) {
                cell = startCell;
            }

            var item = this.itemData.item;
            var app = this.itemData.appointment;
            app.row = cell;

            var startTime = this.setTimeOfUnit(item.startTime, cell.startTime);
            var endTime = app.getEndTime(startTime);
            var resource = cell.resource;

            get(VerticalList.prototype.__proto__ || Object.getPrototypeOf(VerticalList.prototype), 'endItemDrag', this).call(this, { startTime: startTime, endTime: endTime, resource: resource });
        }
    }, {
        key: 'endItemResize',
        value: function endItemResize(e) {
            var startCell = this.itemData.itemStartCell;
            var endCell = this.itemData.itemLastCell;

            var cell = this.getCellAt(e.clientX, e.clientY);
            if (!cell) {
                startCell = endCell = null;
            }

            var item = this.itemData.item;
            var app = this.itemData.appointment;

            var startTime;
            var resource;

            if (startCell != null) {
                startTime = DateTime.setTimeOfDay(item.startTime, startCell.startTime);
                resource = startCell.resource;
            } else {
                startTime = item.startTime;
                resource = this.getGroupCells(this.itemData.appointment.groupColumnIndex)[this.itemData.startCellIndex].resource;
            }
            var endTime = endCell != null ? endCell.endTime : item.endTime;

            get(VerticalList.prototype.__proto__ || Object.getPrototypeOf(VerticalList.prototype), 'endItemResize', this).call(this, { startTime: startTime, endTime: endTime, resource: resource });
        }
    }, {
        key: 'getDragOffset',
        value: function getDragOffset(cell, item) {
            var itemsInCell = this.getAllItemsInCell(cell);
            if (this.itemsContainItem(item, itemsInCell)) {
                itemsInCell.splice(itemsInCell.indexOf(item), 1);
            }
            if (itemsInCell.length == 0) {
                return 0;
            }
            var indexColl = [];
            for (var i = 0, l = itemsInCell.length; i < l; i++) {
                if (itemsInCell[i].pos != -1) {
                    indexColl.push(itemsInCell[i].pos);
                }
            }

            indexColl.sort(function (a, b) {
                return a - b;
            });

            var result = 0;
            for (var l = indexColl.length; result < l; result++) {
                if (indexColl[result] == result || indexColl.indexOf(result) > -1) {
                    continue;
                }
                return result;
            }
            return result;
        }

        /* Item placement */

    }, {
        key: 'getDimensions',
        value: function getDimensions() {
            var getBounds = DomUtils.getBounds;
            var row = this.getRows()[0];
            this.cellWidth = getBounds(this.getBgCells()[0]).width;

            this.dayHeaderHeight = getBounds(this.cells.items()[0].title).height;
            this.calculatedCellHeight = getBounds(row).height;
            this.rowHeight = getBounds(row).height - this.dayHeaderHeight;

            this.headerWidth = this.getHeader() ? getBounds(this.getHeader()).width : 0;

            this.dragWidth = this.calendar.itemSettings.size;
            this.dragHeight = this.rowHeight;

            this.itemsCount = Math.floor(this.cellWidth / (this.calendar.itemSettings.size + this.calendar.itemSettings.spacing));
            if (this.settings.maxItems) this.itemsCount = Math.min(this.settings.maxItems, this.itemsCount);
        }
        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'clear',
        value: function clear() {
            DomUtils.removeNodes(this.getContent().querySelectorAll('.mfp-item-wrap'));
        }
    }, {
        key: 'init',
        value: function init() {
            if (!this.cellWidth) this.getDimensions();

            this.getAllItems();

            for (var k = 0, m = this.groupCols.length; k < m; k++) {
                this.itemsToPut = this.getItemsToPut(k);
                for (var i = 0; i < this.itemsToPut.length; i++) {
                    this.itemsToPut[i].cell = null;
                    this.itemsToPut[i].row = -1;
                }
                for (var i = 0, l = this._rows.count(); i < l; i++) {
                    this.createItemsTable(this._rows.items()[i], k);
                }
                for (var i = 0; i < this.itemsToPut.length; i++) {
                    var item = this.items[this.items.indexOf(this.itemsToPut[i])];
                    item.cell = null;
                    item.row = -1;
                    item.hidden = true;
                }
            }

            this.placeItems();

            if (this.calendar.itemSettings.showItems) {
                this.getCues();
                this.createCues();
            }
        }
    }, {
        key: 'createItemsTable',
        value: function createItemsTable(row, groupCol) {
            var items = this.getItemsToPutInCol(row, groupCol);
            for (var i = 0, l = items.length; i < l; i++) {
                items[i].cell = null;
                if (this.getItemsCountInRow(row, groupCol) < this.itemsCount) {
                    items[i].cell = this.getItemRow(row, groupCol);
                    items[i].row = items[i].startCellIndex;
                    this.itemsToPut.splice(this.itemsToPut.indexOf(items[i]), 1);
                } else {
                    items[i].cell = this.getItemRow(row, groupCol);
                }
            }
        }
    }, {
        key: 'placeItems',
        value: function placeItems() {
            for (var i = 0; i < this.items.length; i++) {
                var item = this.items[i];

                if (item.cell) {
                    item.hidden = false;
                    item.element.parentNode.style.cssText = '';
                    item.element.parentNode.style.position = 'absolute';
                    item.element.parentNode.style.height = this.getItemHeight(item) + 'px';
                    item.cell.appendChild(item.element.parentNode);
                } else {
                    item.hidden = true;
                    item.row = -1;
                    item.pos = -1;
                }
            }

            this.arrangeItems();
        }
    }, {
        key: 'arrangeItems',
        value: function arrangeItems() {
            for (var i = 0, l = this._totalColumns; i < l; i++) {
                this.arrangeItemsInCol(i);
            }
        }
    }, {
        key: 'arrangeItemsInCol',
        value: function arrangeItemsInCol(col) {
            var items = this.getItemsInCol(col);
            var b = [];
            for (var i = 0; i < items.length; i++) {
                items[i].element.parentNode.style.height = this.getItemHeight(items[i]) + 'px';
                items[i].element.parentNode.style.left = '0px';
            }
            for (var i = 0; i < items.length; i++) {
                if (items[i].cell == null) {
                    continue;
                }
                var element = items[i].element.parentNode;
                var itemCell = this.getItemCell(items[i]).bgCell;
                var bounds = DomUtils.getRelativeBounds(element, itemCell);
                var cellBounds = DomUtils.getRelativeBounds(itemCell, this.getContent()); //.querySelector(".mfp-content"));
                var zeroLeft = cellBounds.x - this.headerWidth;

                var pos = 0;
                if (element && this.calendar.itemSettings.size > 0) {
                    var x = bounds.x || 0;
                    var y = (bounds.y || 0) + cellBounds.y;
                    var y2 = bounds.height + y;
                    while (!this.checkElementBounds(b, x, y, y2)) {
                        pos += 1;
                        x += this.calendar.itemSettings.size + this.calendar.itemSettings.spacing * 2;
                    }
                    b.push({ x: x, y: y, y2: y2 });
                    element.style.left = zeroLeft + this.calendar.itemSettings.size * pos + this.calendar.itemSettings.spacing * (pos + 1) + 'px';
                    if (this.calendar.itemSettings.size * pos + this.calendar.itemSettings.spacing * (pos + 1) + this.calendar.itemSettings.size + this.calendar.itemSettings.spacing > this.cellWidth) {
                        items[i].row = -1;
                        items[i].pos = -1;
                    } else {
                        items[i].pos = pos;
                    }
                }
            }
        }

        /* Cell.getCues override */

    }, {
        key: 'getCues',
        value: function getCues() {
            this.cues = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                var item = this.items[i];
                if (item.row == -1) {
                    var cells = this.getItemCueCells(item);
                    for (var k = 0; k < cells.length; k++) {
                        if (this.cues.indexOf(cells[k]) === -1) this.cues.push(cells[k]);
                    }
                    item.element.parentNode.style.visibility = 'hidden';
                    item.element.parentNode.style.display = 'none';
                } else {
                    item.element.parentNode.style.visibility = 'visible';
                }
            }
        }

        /**
              * For internal use only.
              * @private
              */

    }, {
        key: 'updateItem',
        value: function updateItem(appointment, addToItems) {
            var item = appointment.item;
            appointment.groupColumnIndex = this.getItemCols(item);

            //invisible items
            if (!item.visible) {
                return appointment;
            }
            var appointment = appointment;

            var parts = [];
            var removed = [];
            if (!this.hasVisibleParts(item)) {
                removed.push(appointment);
            } else if (this.isComposite(item)) {
                var st = DateTime.maxDate(item.startTime, this.itemsStartTime, false);
                var et = DateTime.minDate(item.endTime, this.itemsEndTime, true);

                var partIndex = 0;
                if (st.compareTo(item.startTime) == 1) // right arrow
                    partIndex = 1;
                if (et.compareTo(item.endTime) == -1) // left arrow
                    partIndex = -1;
                if (st.compareTo(item.startTime) == 1 && et.compareTo(item.endTime) == -1) // both arrows
                    partIndex = 0;

                if (appointment.groupColumnIndex.length == 1) {
                    var scell = this.getTimeCell(st, false, appointment.groupColumnIndex);
                    var lcell = this.getTimeCell(et, true, appointment.groupColumnIndex);
                    var partData = {
                        prototype: appointment,
                        type: 'part',
                        cellIndex: scell.index,
                        cellsLength: lcell.index - scell.index + 1,
                        colIndex: 0,
                        isPartial: true,
                        partIndex: partIndex,
                        lastCellIndex: lcell.index,
                        startCellIndex: scell.index,
                        groupColumnIndex: appointment.groupColumnIndex
                    };
                    var part = new Appointment(partData);
                    part.composite = true;
                    parts.push(part);
                    removed.push(appointment);
                } else if (appointment.groupColumnIndex.length > 1) {
                    for (var i = 0, l = appointment.groupColumnIndex.length; i < l; i++) {
                        var scell = this.getTimeCell(st, false, appointment.groupColumnIndex[i]);
                        var lcell = this.getTimeCell(et, true, appointment.groupColumnIndex[i]);
                        var partData = {
                            prototype: appointment,
                            type: 'part',
                            cellIndex: scell.index,
                            cellsLength: lcell.index - scell.index + 1,
                            colIndex: scell.rowIndex,
                            isPartial: true,
                            partIndex: partIndex,
                            lastCellIndex: lcell.index,
                            startCellIndex: scell.index,
                            groupColumnIndex: appointment.groupColumnIndex[i]
                        };
                        var part = new Appointment(partData);
                        part.composite = true;
                        parts.push(part);
                        removed.push(appointment);
                    }
                }
            } else if (appointment.groupColumnIndex.length == 1) {
                var cell = this.getTimeCell(item.startTime, false, appointment.groupColumnIndex);
                if (item.startTime._date.valueOf() == item.endTime._date.valueOf()) {
                    var lcell = cell;
                } else {
                    var lcell = this.getTimeCell(item.endTime, true, appointment.groupColumnIndex);
                }
                appointment.lastCellIndex = lcell.index;
                appointment.startCellIndex = cell.index;
                appointment.cellsLength = lcell.index - cell.index + 1;
                if (appointment.cellsLength < 1) {
                    appointment.cellsLength = 1;
                }
                appointment.cellIndex = cell.index;
                appointment.colIndex = cell.rowIndex;
                appointment.updateVisual();
            } else if (appointment.groupColumnIndex.length > 1) {
                for (var i = 0, l = appointment.groupColumnIndex.length; i < l; i++) {
                    var cell = this.getTimeCell(item.startTime, false, appointment.groupColumnIndex[i]);
                    if (item.startTime._date.valueOf() == item.endTime._date.valueOf()) {
                        var lcell = cell;
                    } else {
                        var lcell = this.getTimeCell(item.endTime, true, appointment.groupColumnIndex[i]);
                    }
                    var partData = {
                        prototype: appointment,
                        type: 'part',
                        cellIndex: cell.index,
                        cellsLength: lcell.index - cell.index + 1,
                        colIndex: appointment.groupColumnIndex[i],
                        isPartial: true,
                        partIndex: appointment.partIndex,
                        lastCellIndex: lcell.index,
                        startCellIndex: cell.index,
                        groupColumnIndex: appointment.groupColumnIndex[i]
                    };
                    var part = new Appointment(partData);
                    part.composite = true;
                    parts.push(part);
                    removed.push(appointment);
                }
            }

            for (var i = 0; i < removed.length; i++) {
                this.removeAppointment(removed[i]);
            }

            if (addToItems != false) this.items = this.items.concat(parts);

            for (var i = 0; i < parts.length; i++) {
                parts[i].updateVisual();
            }

            //return value is only used for recurrent composite items
            if (parts.length > 0) return parts;
            parts.push(appointment);
            return parts;
        }

        /**
               * Gets the cell that corresponds to the specified time.
               * @param {Object} [time] The time to search for.
               * @param {Boolean} [isEndTime] true if the index of the first interval is returned when the time is the boundary between two consecutive intervals;
               false if the index of the second interval is contained.
               * @returns {Object} The cell that holds the specified time.
               */

    }, {
        key: 'getTimeCell',
        value: function getTimeCell(time, isEndTime, col) {
            if (col.length != undefined) col = col[0];

            var cells = this.getGroupCells(col);

            if (time._date.valueOf() < this.startTime._date.valueOf()) return null;
            if (time._date.valueOf() > this.endTime._date.valueOf()) return null;

            var t = this.setTimeOfUnit(this.startTime, time);
            var i = this.unitsBetween(this.startTime, t);

            if (this.skipNext > 0 && i > cells.length) {
                return cells[cells.length - 1];
            }

            if (i > cells.length) return null;
            if (i == cells.length) {
                if (isEndTime && time.equals(cells[i - 1].endTime)) return cells[i - 1];else return null;
            }
            if (isEndTime && DateTime.isSameDate(time, cells[i].startTime) && i > 0) {
                i -= 1;
            }

            return cells[i];
        }
    }, {
        key: 'getTimeCells',
        value: function getTimeCells(startTime, endTime, isEndTime, col) {
            var startCell = null;
            var endCell = null;

            if (col.length != undefined) col = col[0];

            if (col < 0 || col > this.groupCols.length - 1) return null;
            var cells = this.getGroupCells(col);

            if (!cells) return [];

            if (startTime.valueOf() < this.startTime.valueOf()) {
                startCell = cells[0];
            } else if (startTime.valueOf() > this.endTime.valueOf()) {
                return [];
            } else {
                startCell = this.getTimeCell(startTime, false, col);
            }
            if (endTime !== null && typeof endTime !== "undefined" && typeof endTime._date !== "undefined") {
                if (endTime.valueOf() > this.endTime.valueOf()) {
                    endCell = cells[cells.length - 1];
                } else if (endTime.valueOf() < this.startTime.valueOf()) {
                    return [];
                } else {
                    endCell = this.getTimeCell(endTime, isEndTime, col);
                }
            } else {
                endCell = startCell;
            }

            if (startCell && endCell) {
                return cells.slice(startCell.index, endCell.index + 1);
            }
            return [];
        }

        /**
             * For internal use only.
             * @private
             */

    }, {
        key: 'isComposite',
        value: function isComposite(item) {
            if (item.startTime._date.valueOf() < this._rows.items()[0].itemsStartTime._date.valueOf()) return true;
            if (item.endTime._date.valueOf() > this._rows.items()[this._rows.count() - 1].itemsEndTime._date.valueOf()) return true;
            return false;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'hasVisibleParts',
        value: function hasVisibleParts(item) {
            if (this.grouped && this.getItemCols(item).length == 0) return false;
            if (item.startTime._date.valueOf() >= this._rows.items()[0].itemsStartTime._date.valueOf() && item.startTime._date.valueOf() < this._rows.items()[this._rows.count() - 1].itemsEndTime._date.valueOf()) return true;
            if (item.endTime._date.valueOf() > this._rows.items()[0].itemsStartTime._date.valueOf() && item.endTime._date.valueOf() < this._rows.items()[this._rows.count() - 1].itemsEndTime._date.valueOf()) return true;
            if (item.startTime._date.valueOf() <= this._rows.items()[0].itemsStartTime._date.valueOf() && item.endTime._date.valueOf() >= this._rows.items()[0].itemsEndTime._date.valueOf()) return true;
            return false;
        }
    }, {
        key: 'checkElementBounds',
        value: function checkElementBounds(bounds, x, y, y2) {
            for (var i = 0; i < bounds.length; i++) {
                if (x == bounds[i].x) {
                    if (y >= bounds[i].y && y < bounds[i].y2 || y2 >= bounds[i].y && y2 < bounds[i].y2) return false;
                }
            }
            return true;
        }
    }, {
        key: 'getItemsInCell',
        value: function getItemsInCell(cell, items) {
            var result = [];
            for (var i = 0, l = items.length; i < l; i++) {
                if (items[i].startCellIndex == cell.index) result.push(items[i]);
            }
            return result;
        }
    }, {
        key: 'getAllItemsInCell',
        value: function getAllItemsInCell(cell) {
            var result = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].groupColumnIndex == cell.columnIndex) {
                    if (this.items[i].startCellIndex <= cell.index && this.items[i].lastCellIndex >= cell.index) {
                        if (this.items[i].pos < this.itemsCount || this.items[i].pos == -1) {
                            result.push(this.items[i]);
                        }
                    }
                }
            }
            return result;
        }
    }, {
        key: 'getItemsInCol',
        value: function getItemsInCol(index) {
            var result = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].groupColumnIndex == index && this.items[i].item.visible == true) {
                    result.push(this.items[i]);
                }
            }
            return result;
        }
    }, {
        key: 'getItemCols',
        value: function getItemCols(item) {
            var result = [];
            if (this.resources == null || !this.grouped) {
                result.push(0);
                return result;
            }
            for (var i = 0, l = this.resources.length; i < l; i++) {
                if (item.hasResource(this.resources[i])) {
                    result.push(i);
                }
            }
            return result;
        }
    }, {
        key: 'getItemCell',
        value: function getItemCell(item) {
            return this.cells.items()[item.cellIndex + item.groupColumnIndex * this._rows.count()];
        }
    }, {
        key: 'getGroupCells',
        value: function getGroupCells(col) {
            if (col.length) col = col[0];

            var cells = [];
            this.cells.forEach(function (t) {
                if (t.columnIndex == col) cells.push(t);
            });
            return cells;
        }
    }, {
        key: 'getItemRow',
        value: function getItemRow(row, col) {
            return this.getGroupCells(col)[row.index].itemCell;
        }
    }, {
        key: 'getItemHeight',
        value: function getItemHeight(item) {
            return Math.floor(this.rowHeight * item.cellsLength + this.dayHeaderHeight * (item.cellsLength - 1));
        }
    }, {
        key: 'getItemsToPut',
        value: function getItemsToPut(groupCol) {
            var result = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].item.visible && this.items[i].groupColumnIndex == groupCol) {
                    result.push(this.items[i]);
                }
            }
            return result;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getItemsToPutInCol',
        value: function getItemsToPutInCol(row, groupCol) {
            var items = [];
            for (var i = 0, l = this.itemsToPut.length; i < l; i++) {
                if (this.itemsToPut[i].groupColumnIndex == groupCol && this.itemsToPut[i].startCellIndex == row.index) items.push(this.itemsToPut[i]);
            }
            return items;
        }
    }, {
        key: 'getItemsCountInRow',
        value: function getItemsCountInRow(row, groupCol) {
            var items = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].groupColumnIndex == groupCol && this.items[i].startCellIndex == row.index && this.items[i].cell != null && this.items[i].row != -1) items.push(this.items[i]);
                if (this.items[i].groupColumnIndex == groupCol && this.items[i].startCellIndex < row.index && this.items[i].lastCellIndex >= row.index && this.items[i].cell != null && this.items[i].row != -1) items.push(this.items[i]);
            }
            return items.length;
        }

        /*Rendering*/

    }, {
        key: 'draw',
        value: function draw() {
            this._element = document.createElement("div");

            if (this._groupColumns > 0) {
                var g = this.drawGroupHeader();
                this._element.appendChild(g);
            }

            var d1 = document.createElement("div");
            d1.className = "mfp-scroller";
            this._element.appendChild(d1);

            var d2 = document.createElement("div");
            d2.className = "mfp-wrapper";
            d1.appendChild(d2);

            if (this.settings.headerStyle != MainHeaderStyle.None) {
                var header = this.drawHeader();
                d2.appendChild(header);

                if ((this.settings.headerStyle & MainHeaderStyle.Buttons) == MainHeaderStyle.Buttons) {
                    var b = this.drawHeaderButtons();
                    header.appendChild(b);
                }
            }

            var content = this.drawContent();
            d2.appendChild(content);

            return this._element;
        }
    }, {
        key: 'drawGroupHeader',
        value: function drawGroupHeader() {
            var result = null;

            var groupName = "";

            var d = document.createElement("div");
            d.className = "mfp-header-group";
            result = d;

            var d1 = document.createElement("div");
            d.appendChild(d1);

            for (var k = 0; k < this._totalColumns; k++) {

                groupName = this.calendar.getResourceName(this.calendar.groupResources.items()[k]);
                var g = document.createElement("div");
                d.appendChild(g);
                g.innerHTML = groupName || "&nbsp;";
            }

            var d2 = document.createElement("div");
            d.appendChild(d2);

            return result;
        }
    }, {
        key: 'drawHeader',
        value: function drawHeader() {
            var result = null;

            var time = this._date.clone();

            var header = document.createElement("div");
            header.className = "mfp-header";
            result = header;

            if ((this.settings.headerStyle & MainHeaderStyle.Title) == MainHeaderStyle.Title) {
                for (var day = 0; day < this.settings.numberOfCells; day++) {
                    var d = document.createElement("div");
                    var a = document.createElement("a");
                    a.innerHTML = time.toString(this.settings.titleFormat, this.formatInfo);
                    d.appendChild(a);
                    header.appendChild(d);
                    time = this.addUnits(time, 1);
                }
            }

            return result;
        }
    }, {
        key: 'drawHeaderButtons',
        value: function drawHeaderButtons(parent) {
            var result = null;

            var d = document.createElement("div");
            d.className = "mfp-button-wrap";
            result = d;

            var b1 = document.createElement("a");
            DomUtils.addCssClass(b1, "mfp-button");
            DomUtils.addCssClass(b1, "mfp-button-prev");
            if (this.calendar.showTooltips) {
                b1.title = this.getHeaderButtonTooltip(-1);
            }
            var s = document.createElement("span");
            b1.appendChild(s);
            d.appendChild(b1);

            var b2 = document.createElement("a");
            DomUtils.addCssClass(b2, "mfp-button");
            DomUtils.addCssClass(b2, "mfp-button-next");
            if (this.calendar.showTooltips) {
                b2.title = this.getHeaderButtonTooltip(0);
            }
            s = document.createElement("span");
            b2.appendChild(s);
            d.appendChild(b2);

            return result;
        }
    }, {
        key: 'getHeaderButtonTooltip',
        value: function getHeaderButtonTooltip(step) {
            var time = step == -1 ? this._date : this._lastDate;

            var result = "";

            var d = this.formatInfo.dateFormats;

            switch (this.settings.cellUnits) {
                case TimeUnit.Second:
                    result = DateTime.addSeconds(time, step).toString(d.longTime, this.formatInfo);
                    break;
                case TimeUnit.Minute:
                    result = DateTime.addMinutes(time, step).toString(d.longTime, this.formatInfo);
                    break;
                case TimeUnit.Hour:
                    result = DateTime.addHours(time, step).toString(d.longTime, this.formatInfo);
                    break;
                case TimeUnit.Day:
                    result = DateTime.addDays(time, step).toString(d.longDate, this.formatInfo);
                    break;
                case TimeUnit.Week:
                    result = DateTime.addDays(time, step * 7).toString(d.longDate, this.formatInfo);
                    result += " - ";
                    result += time.toString(d.longDate, this.formatInfo);
                    break;
                case TimeUnit.Month:
                    result = DateTime.addMonths(time, step).toString(d.yearMonth, this.formatInfo);
                    break;
                case TimeUnit.Year:
                    result = DateTime.addYears(time, step).toString(d.yearMonth, this.formatInfo);
                    break;
            }

            return result;
        }
    }, {
        key: 'drawContent',
        value: function drawContent() {
            var result = null;

            var content = document.createElement("div");
            content.className = "mfp-content";
            result = content;

            var r = document.createElement("div");
            r.className = "mfp-wrap";
            content.appendChild(r);

            var t = this.drawBackgroundTable();
            r.appendChild(t);

            var t = this.drawItemTable();
            r.appendChild(t);

            return result;
        }
    }, {
        key: 'drawBackgroundTable',
        value: function drawBackgroundTable() {
            var result = null;

            var startDate = this._date;

            var c = document.createElement("div");
            c.className = "mfp-bg-table";
            result = c;

            for (var i = 0; i < this._rows.count(); i++) {
                var r = document.createElement("div");
                r.className = "mfp-bg-row";
                c.appendChild(r);

                for (var k = 0; k < this._totalColumns; k++) {
                    var d = this.drawDay(startDate);
                    r.appendChild(d);
                }
                startDate = this.addUnits(startDate, 1);
            }

            return result;
        }
    }, {
        key: 'drawBackgroundTable1',
        value: function drawBackgroundTable1() {
            var result = null;

            var startDate = this._date;

            var table = document.createElement("table");
            table.cellSpacing = 0;
            table.cellPadding = 0;
            table.className = "mfp-bg-table";
            result = table;

            for (var i = 0; i < this._rows.count(); i++) {
                var tr = document.createElement("tr");
                table.appendChild(tr);

                for (var k = 0; k < this._totalColumns; k++) {
                    var d = this.drawDay(startDate);
                    tr.appendChild(d);
                }
                startDate = this.addUnits(startDate, 1);
            }

            return result;
        }
    }, {
        key: 'drawDay',
        value: function drawDay(day) {
            var result = null;
            var output = this.calendar.renderer;

            var dayOfMonth = DateTime.getDayOfMonth(day);
            var month = DateTime.getMonth(day);

            var c = document.createElement("div");
            c.className = "mfp-bg-cell";

            var dayOfWeek = day.dayOfWeek;
            if (dayOfWeek === DayOfWeek.Saturday || dayOfWeek === DayOfWeek.Sunday) c.className += " mfp-weekend-cell";

            var d = document.createElement("div");
            d.className = "mfp-bg-cell-header";

            if (month == 1 && dayOfMonth == 1) d.innerHTML = day.toString(this.settings.firstDayOfYearFormat, this.formatInfo);else if (month != 1 && dayOfMonth == 1) d.innerHTML = day.toString(this.settings.firstDayOfMonthFormat, this.formatInfo);else d.innerHTML = day.toString(this.settings.generalFormat, this.formatInfo);

            c.appendChild(d);

            result = c;
            return result;
        }
    }, {
        key: 'drawItemTable',
        value: function drawItemTable() {
            var result = null;

            var startDate = this._date;

            var div = document.createElement("div");
            div.className = "mfp-item-table";
            result = div;

            for (var row = 0; row < this._rows.count(); row++) {

                var r = document.createElement("div");
                r.className = "mfp-item-row";
                div.appendChild(r);

                var w = document.createElement("div");
                w.className = "mfp-header-wrap";
                r.appendChild(w);

                for (var k = 0; k < this._totalColumns; k++) {
                    var c = document.createElement("div");
                    c.className = "mfp-cell-header";
                    if (this.calendar.showTooltips) c.title = startDate.toString(this.formatInfo.dateFormats.longDate, this.formatInfo);
                    w.appendChild(c);
                }

                startDate = this.addUnits(startDate, 1);

                w = document.createElement("div");
                w.className = "mfp-cell-wrap";
                r.appendChild(w);

                for (var k = 0; k < this._totalColumns; k++) {
                    c = document.createElement("div");
                    c.className = "mfp-item-cell";
                    w.appendChild(c);
                }
            }

            return result;
        }
        /*End Render*/

    }, {
        key: 'cells',
        get: function get$$1() {
            var result = new List();
            this._rows.forEach(function (t) {
                result.addRange(t.cells.items());
            }, this);

            result.sort(function (a, b) {
                return a.cellIndex - b.cellIndex;
            });
            return result;
        }
    }, {
        key: 'orientation',
        get: function get$$1() {
            return Orientation.Vertical;
        }
    }, {
        key: 'cssClass',
        get: function get$$1() {
            return "mfp-vertical-list-view";
        }
    }]);
    return VerticalList;
}(Cell);

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* For internal use only.
* @private
*/

var ResourceViewCell = function (_Cell) {
    inherits(ResourceViewCell, _Cell);

    function ResourceViewCell(calendar) {
        classCallCheck(this, ResourceViewCell);

        var _this = possibleConstructorReturn(this, (ResourceViewCell.__proto__ || Object.getPrototypeOf(ResourceViewCell)).call(this, calendar));

        _this._date = _this.calendar.date;

        _this._settings = _this.calendar.resourceViewSettings;
        _this._timelineSettings = _this.calendar.resourceViewSettings.bottomTimelineSettings;

        _this._rows = new List();

        _this.initVars();

        _this._dragging = false;
        _this._resizing = false;
        _this._selecting = false;
        _this._selectionPaused = false;

        _this.items = [];

        _this.Dom = {};
        return _this;
    }

    createClass(ResourceViewCell, [{
        key: 'initVars',
        value: function initVars() {

            this._date = DateTime.getFirstDateAfter(this._date, this._timelineSettings.unit, this._timelineSettings.unitCount, this.formatInfo);

            if (this._date.greaterThan(this.calendar.date)) this._date = DateTime.getPreviousDate(this._date, this._timelineSettings.unit, this._timelineSettings.unitCount);
            this.calendar._date = this._date;

            var endDate = this.calendar.endDate;
            var numberOfCells = this.getCellsCount(this._date, endDate, this._timelineSettings.unit, this._timelineSettings.unitCount);
            // this.calendar.endDate = endDate;
            this._lastDate = endDate;

            this._realCells = this.rowCellsCount = numberOfCells;
            if (numberOfCells > this._settings.visibleCells) this._contentWidth = Unit.percentage(Math.round(100 / this._settings.visibleCells * numberOfCells, 2)).toString();else this._contentWidth = Unit.percentage(100).toString();

            this._firstVisibleDate = this._date;

            this._groupColumns = this.calendar.groupResources.count();

            this.cellTicks = new List();
            for (var i = 0; i < this._settings.timelines; i++) {
                this.cellTicks.add(new List());
            }
            if (this._settings.timelines >= 1) {
                this._bottomTimelineCells = this.calculateCells(this._settings.bottomTimelineSettings, ResourceViewTimeline.Bottom);
            }
            if (this._settings.timelines >= 2) {
                this._middleTimelineCells = this.calculateCells(this._settings.middleTimelineSettings, ResourceViewTimeline.Middle);
            }
            if (this._settings.timelines >= 3) {
                this._topTimelineCells = this.calculateCells(this._settings.topTimelineSettings, ResourceViewTimeline.Top);
            }

            this.createCells();
        }

        /* Dom */

    }, {
        key: 'getTimelineHeader',
        value: function getTimelineHeader() {
            if (!this.Dom.timelineHeader) {
                this.Dom.timelineHeader = this.calendar.getElement().querySelector("div.mfp-header-timeline");
            }
            return this.Dom.timelineHeader;
        }
    }, {
        key: 'getGroupHeader',
        value: function getGroupHeader() {
            if (!this.Dom.groupHeader) {
                this.Dom.groupHeader = this.calendar.getElement().querySelector("div.mfp-header-group-wrap");
            }
            return this.Dom.groupHeader;
        }
    }, {
        key: 'getRows',
        value: function getRows() {
            if (!this.Dom.rows) {
                this.Dom.rows = this.calendar.getElement().querySelectorAll('div.mfp-wrap');
            }
            return this.Dom.rows;
        }
    }, {
        key: 'getBgCells',
        value: function getBgCells() {
            if (!this.Dom.bgCells) {
                this.Dom.bgCells = this.calendar.getElement().querySelectorAll('div.mfp-bg-cell');
            }
            return this.Dom.bgCells;
        }
    }, {
        key: 'getDayCells',
        value: function getDayCells() {
            return this.getBgCells();
        }
    }, {
        key: 'createCells',
        value: function createCells() {

            this.startTime = this.itemsStartTime = this._date;
            this.endTime = this.itemsEndTime = this._lastDate;

            var j = 0;
            this.groupCols = [];

            for (var i = 0; i < this._groupColumns; i++) {

                var col = new ViewColumn(i, this.startTime, this.startTime, this.endTime);
                col.resource = this.resources == null ? null : this.resources[i];
                this.groupCols.push(col);

                var row = new ViewRow(this.startTime, this.endTime, this.startTime, this.endTime);
                row.index = i;

                for (var k = 0, m = this._realCells; k < m; k++) {
                    if (this.skipNext > 0 && k <= this.skipNext) {
                        var cst = this.addUnits(this.startTime, k);
                        var cet = this.addUnits(this.startTime, k + 1);
                    } else {
                        var cellStartTime = this.addUnits(this.startTime, k);
                        var cellEndTime = this.addUnits(this.startTime, k + 1);
                    }
                    var cell = new ViewCell();
                    cell.index = k;
                    cell.cellIndex = j;
                    cell.rowIndex = i;
                    cell.startTime = cellStartTime;
                    cell.endTime = cellEndTime;
                    cell.columnIndex = i;

                    if (this.grouped) {
                        cell.resource = this.resources == null ? null : this.resources[i];
                    }
                    row.cells.add(cell);
                    j += 1;
                }
                this._rows.add(row);
            }
        }
    }, {
        key: 'detach',
        value: function detach() {
            var _this2 = this;

            this.getScroller().removeEventListener("scroll", function (e) {
                return _this2.onScroll(e);
            });

            this.getHeader().removeEventListener("click", this.headerClickHandler);
            if (this.getGroupHeader()) this.getGroupHeader().removeEventListener("click", this.headerClickHandler);
            if (this.getTimelineHeader()) this.getTimelineHeader().removeEventListener("click", this.headerClickHandler);
        }
    }, {
        key: 'attach',
        value: function attach() {
            var _this3 = this;

            // if (this._rows.count() === 0) return;

            var bgTables = this.getContent().querySelectorAll("div.mfp-bg-row");
            var bgCells = this.getContent().querySelectorAll("div.mfp-bg-cell");
            var itemCells = this.getContent().querySelectorAll("div.mfp-item-cell");

            var wrapper = this.getContent().querySelector("div.mfp-content-wrap");
            wrapper.style.width = this._contentWidth;
            var width = DomUtils.getBounds(wrapper).width;

            var j = 0;

            for (var i = 0; i < this._rows.count(); i++) {
                var row = this._rows.items()[i];
                row.bgTable = bgTables[i];

                for (var k = 0, m = row.cells.count(); k < m; k++) {
                    var cell = row.cells.items()[k];
                    cell.bgCell = bgCells[j];
                    cell.itemCell = itemCells[j];
                    cell.title = bgCells[j];
                    j++;
                }
            }

            var itemTables = this.getContent().querySelectorAll(".mfp-item-table");
            var laneTables = this.getContent().querySelectorAll(".mfp-lane-table");

            for (var i = 0; i < this.groupCols.length; i++) {
                this.groupCols[i].itemTable = itemTables[i];
                this.groupCols[i].laneTable = laneTables[i];
            }

            if (this.grouped) {
                var headerCells = this.getGroupHeader().childNodes;
                for (var i = 0; i < this.groupCols.length; i++) {
                    this.groupCols[i].header = headerCells[i];
                }
            }

            var timelines = this.getHeader().querySelectorAll(".mfp-timeline");
            for (var i = 0; i < timelines.length; i++) {
                timelines[i].style.width = width + "px";
            }

            this.updateTimelines();

            this.clear();
            this.init();

            this.getScroller().addEventListener("scroll", function (e) {
                return _this3.onScroll(e);
            });

            this.getHeader().addEventListener("click", this.headerClickHandler);
            if (this.getGroupHeader()) this.getGroupHeader().addEventListener("click", this.headerClickHandler);
            if (this.getTimelineHeader()) this.getTimelineHeader().addEventListener("click", this.headerClickHandler);
        }
    }, {
        key: 'updateTimelines',
        value: function updateTimelines() {
            if (!this.calculatedCellWidth) this.getDimensions();

            // timeline cells' widths.
            // cache the timelines' cells
            var timelinesDom = this.getHeader().querySelectorAll(".mfp-timeline");
            var timelines = [];
            for (var i = 0, l = timelinesDom.length; i < l; i++) {
                var timeline = [];

                var cells = timelinesDom[i].querySelectorAll('div');
                for (var j = 0, m = cells.length; j < m; j++) {
                    timeline.push(cells[j]);
                }
                timelines.push(timeline);
            }

            // get the border-width and padding from bottom timeline cells style.
            var td = timelines[timelines.length - 1][0];
            var bottomDiff = td.offsetWidth - td.clientWidth;
            var cw = Math.floor(this.calculatedCellWidth) - bottomDiff;

            var totalWidth = timelines[timelines.length - 1].length * (cw + bottomDiff);

            // create an object to cache cell widths to be used for "sticky left label" during scrolling.
            this.cellsWidthCache = [];

            for (var i = 0, l = this.cellTicks.count(); i < l; i++) {
                if (i < l - 1) {
                    this.cellsWidthCache.push([]);
                    // get the border-width and padding from this timeline cell style.
                    var thisDiff = timelines[i][0].offsetWidth - timelines[i][0].clientWidth;
                }
                for (var j = 0, m = this.cellTicks.items()[i].count(); j < m; j++) {
                    var w;
                    if (i < l - 1) {
                        // non-bottom timeline
                        // account for borders
                        w = this.cellTicks.items()[i].items()[j] * (cw + bottomDiff) - thisDiff;
                    } else {
                        w = cw;
                    } // bottom timeline cellTicks is always 1
                    timelines[i][j].style.width = w + "px";
                    if (i < l - 1) {
                        this.cellsWidthCache[i].push(w);
                    }
                }
            }

            // update header and content width-s after the above adjustments.
            for (var i = 0; i < timelinesDom.length; i++) {
                timelinesDom[i].style.width = totalWidth + "px";
            }

            this.getContent().querySelector("div.mfp-content-wrap").style.width = totalWidth + "px";

            this.updateLeftmost(this.getScroller().scrollLeft);

            if (this._rows.count() > 0) this.calculatedCellWidth = DomUtils.getBounds(this.getRows()[0]).width / this.rowCellsCount;
        }
    }, {
        key: 'onScroll',
        value: function onScroll(e) {
            var s = this.getScroller();
            this.getTimelineHeader().style.left = -s.scrollLeft + 'px';
            if (this.getGroupHeader()) this.getGroupHeader().style.top = -s.scrollTop + 'px';

            this.updateLeftmost(s.scrollLeft);
        }
    }, {
        key: 'updateLeftmost',
        value: function updateLeftmost(offset) {
            var timelines = this.getHeader().querySelectorAll(".mfp-timeline");
            var len = timelines.length;

            if (!this.cellsWidthCache) {
                return;
            }
            if (len <= 1) {
                return;
            }

            var leftAligned = [];
            for (var i = 0; i < len - 1; i++) {
                var leftAlign = timelines[i].querySelectorAll('div')[0].style.textAlign;
                leftAligned.push(leftAlign == 'left' || leftAlign == '');
            }

            var cells = [];
            var timelineCells = len == 2 ? [[]] : [[], []];
            for (var i = 0; i < len - 1; i++) {
                cells = timelines[i].querySelectorAll('span');
                timelineCells[i] = cells; //.slice(0);
            }

            var leftmost = this.getLeftmost(offset);

            if (!this.currentLeftmost || leftmost.length !== this.currentLeftmost.length) {
                this.currentLeftmost = [];
                for (var i = 0, l = leftmost.length; i < l; i++) {
                    this.currentLeftmost.push(leftmost[i]);
                }
            }

            for (var i = 0, l = timelineCells.length; i < l; i++) {
                if (leftAligned[i] === false) {
                    continue;
                }
                var current = leftmost[i];
                var prev = this.currentLeftmost[i];
                var currentCell = timelineCells[i][current];

                if (current !== prev) {
                    this.currentLeftmost[i] = leftmost[i];
                    var prevCell = timelineCells[i][prev];
                    prevCell.style.left = '0px';
                }
                if (currentCell) currentCell.style.left = this.calcLeftmostOffset(offset, currentCell.parentNode, i);
            }
        }
    }, {
        key: 'calcLeftmostOffset',
        value: function calcLeftmostOffset(offset, cell, timeline) {
            var timelines = this.getHeader().querySelectorAll(".mfp-timeline");

            var x = DomUtils.getRelativeBounds(cell, timelines[timeline]).x;
            var l = offset - x;
            return l + "px";
        }
    }, {
        key: 'getLeftmost',
        value: function getLeftmost(offset) {

            var result = [];
            var cells = this.cellsWidthCache;
            for (var i = 0, l = cells.length; i < l; i++) {
                var len = offset;

                if (cells[i].length == 1) {
                    result.push(0);continue;
                }
                for (var j = 0, m = cells[i].length; j < m; j++) {
                    len -= cells[i][j];

                    if (len < 0) {
                        result.push(j);
                        break;
                    }
                }
            }

            return result;
        }
    }, {
        key: 'getCellsCount',
        value: function getCellsCount(start, end, unit, unitCount) {
            var d = start.clone();
            var pdate = DateTime.getFirstDateAfter(d, unit, unitCount, this.formatInfo);
            if (pdate.equals(d)) pdate = DateTime.getNextDate(d, unit, unitCount);
            if (pdate.greaterThan(end)) end = pdate.clone();
            var count = 1;
            while (pdate.lessThan(end)) {
                d = pdate.clone();
                pdate = DateTime.getNextDate(pdate, unit, unitCount);
                if (pdate.greaterThan(end)) end = pdate;
                count++;
            }
            return count;
        }
    }, {
        key: 'getRelativeTicks',
        value: function getRelativeTicks(settings, start, end, bottomTicks) {
            var real = end - start;
            switch (settings.unit) {
                case TimeUnit.Second:
                case TimeUnit.Minute:
                case TimeUnit.Hour:
                case TimeUnit.Day:
                case TimeUnit.Week:
                default:
                    return real.ticks;
                case TimeUnit.Month:
                case TimeUnit.Year:
                    var bottom = this._settings.bottomTimelineSettings;
                    var value = start.clone();
                    var count = 0;
                    while (value < end) {
                        value = DateTime.getNextDate(value, bottom.Unit, 1);
                        count++;
                    }
                    return bottomTicks * count;
            }
        }
    }, {
        key: 'getBottomRelativeTicks',
        value: function getBottomRelativeTicks(settings) {
            switch (settings.unit) {
                case TimeUnit.Second:
                    return DateTime.MillisPerSecond;
                case TimeUnit.Minute:
                    return DateTime.MillisPerMinute;
                case TimeUnit.Hour:
                    return DateTime.MillisPerHour;

                case TimeUnit.Day:
                default:
                    return DateTime.MillisPerDay;
                case TimeUnit.Week:
                    return DateTime.MillisPerDay * 7;
                case TimeUnit.Month:
                    return DateTime.MillisPerDay * 30;
                case TimeUnit.Year:
                    return DateTime.MillisPerDay * 365;
            }
        }
    }, {
        key: 'calculateCells',
        value: function calculateCells(timeline, type) {
            var cells = new List();
            var index = type - (3 - this._settings.timelines);
            if (type === ResourceViewTimeline.Bottom) {
                for (var i = 0; i < this._realCells; i++) {
                    cells.add(1 / this._realCells);
                    this.cellTicks.items()[index].add(1);
                }
                return cells;
            }
            var adjust = this._settings.bottomTimelineSettings.unit >= TimeUnit.Month;
            var bottomUnitTicks = this.getBottomRelativeTicks(this._settings.bottomTimelineSettings);
            var bCount = this._settings.bottomTimelineSettings.unitCount;

            var date = this._date.date.clone();
            var endDate = this.calendar.endDate.clone();
            var totalTicks = DateTime.millisecondsBetween(endDate, date);
            var pdate = DateTime.getFirstDateAfter(date, timeline.unit, timeline.unitCount, this.formatInfo);
            if (pdate.equals(date)) pdate = DateTime.getNextDate(date, timeline.unit, timeline.unitCount);
            if (pdate.greaterThan(endDate)) pdate = endDate;
            var ticks = -1;
            if (adjust) ticks = this.getRelativeTicks(timeline, date, pdate, bottomUnitTicks);else ticks = Math.abs(pdate._ticks - date._ticks);
            var val = ticks / bottomUnitTicks / bCount;
            cells.add(ticks / totalTicks);

            this.cellTicks.items()[index].add(val);
            while (pdate.lessThan(endDate)) {
                date = pdate.clone();
                pdate = DateTime.getNextDate(pdate, timeline.unit, timeline.unitCount);
                if (pdate.greaterThan(endDate)) pdate = endDate.clone();
                if (adjust) ticks = this.getRelativeTicks(timeline, date, pdate, bottomUnitTicks);else ticks = Math.abs(pdate._ticks - date._ticks);
                val = ticks / bottomUnitTicks / bCount;
                cells.add(ticks / totalTicks);
                this.cellTicks.items()[index].add(val);
            }
            return cells;
        }
    }, {
        key: 'getEndCell',
        value: function getEndCell(endIndex, resource) {
            endIndex = Math.min(endIndex, this.cells.count() - 1);
            var cell = this.cells.items()[endIndex];
            if (cell.resource == resource || resource == null) return cell.cellIndex;
            var groupCol = this.groupCols[this.resources.indexOf(resource)];
            var cells = this.getGroupCells(groupCol.index);
            if (cells.length == 0) {
                
            }
            return cells[cells.length - 1].cellIndex;
        }

        /* Interactions */

    }, {
        key: 'endSelection',
        value: function endSelection(e, start, end, resource) {
            var st = this.cells.items()[start].startTime;
            var et = this.cells.items()[end].endTime;

            var item = new DummyItem(st, et, '', this._timelineSettings.unit > 2, this.calendar, resource);

            get(ResourceViewCell.prototype.__proto__ || Object.getPrototypeOf(ResourceViewCell.prototype), 'endSelection', this).call(this, item);
        }
    }, {
        key: 'endItemDrag',
        value: function endItemDrag(e, resource) {

            var cell = this.getCellAt(e.clientX, e.clientY, resource);
            var startCell = this.getGroupCells(this.itemData.appointment.groupColumnIndex)[this.itemData.startCellIndex];
            if (cell == null) cell = startCell;

            var item = this.itemData.item;
            var app = this.itemData.appointment;

            var startTime = this.setTimeOfUnit(item.startTime, cell.startTime);
            var endTime = app.getEndTime(startTime);
            var resource = cell.resource;

            get(ResourceViewCell.prototype.__proto__ || Object.getPrototypeOf(ResourceViewCell.prototype), 'endItemDrag', this).call(this, { startTime: startTime, endTime: endTime, resource: resource });
        }
    }, {
        key: 'endItemResize',
        value: function endItemResize(e) {

            var startCell = this.itemData.itemStartCell;
            var endCell = this.itemData.itemLastCell;

            var cell = this.getCellAt(e.clientX, e.clientY);
            if (!cell) {
                startCell = endCell = null;
            }

            var item = this.itemData.item;
            var app = this.itemData.appointment;

            var startTime;
            var resource;

            if (startCell != null) {
                startTime = DateTime.setTimeOfDay(item.startTime, startCell.startTime);
                resource = startCell.resource;
            } else {
                startTime = item.startTime;
                resource = this.getGroupCells(this.itemData.appointment.groupColumnIndex)[this.itemData.startCellIndex].resource;
            }
            var endTime = endCell != null ? endCell.endTime : item.endTime;

            get(ResourceViewCell.prototype.__proto__ || Object.getPrototypeOf(ResourceViewCell.prototype), 'endItemResize', this).call(this, { startTime: startTime, endTime: endTime, resource: resource });
        }
    }, {
        key: 'getDimensions',
        value: function getDimensions() {
            var getBounds = DomUtils.getBounds;

            if (this.getBgCells().length == 0) {
                var calWidth = getBounds(this.getContent()).width;
                this.cellWidth = calWidth / this._settings.visibleCells;
                this.calculatedCellWidth = Math.floor(this.cellWidth);

                this.getHeader().childNodes[0].style.display = "none";
                this.getContent().childNodes[0].style.height = "100%";
            } else {
                this.cellWidth = this.cells.items()[0].title.offsetWidth;
                this.calculatedCellWidth = getBounds(this.getRows()[0]).width / this.rowCellsCount;
                this.rowHeight = getBounds(this.getRows()[0]).height;
                this.groupHeaderWidth = getBounds(this.getGroupHeader()).width;
                this.dragOffsetLeft = getBounds(this.getElement()).x + this.groupHeaderWidth;
                this.dragWidth = this.cellWidth;
            }
        }
    }, {
        key: 'updateItem',
        value: function updateItem(appointment, addToItems) {
            var item = appointment.item;
            appointment.groupColumnIndex = this.getItemCols(item);

            //invisible items
            if (!item.visible) {
                return appointment;
            }
            var appointment = appointment;

            var parts = [];
            var removed = [];
            if (!this.hasVisibleParts(item)) {
                removed.push(appointment);
            } else if (this.isComposite(item)) {
                var st = DateTime.maxDate(item.startTime, this.itemsStartTime, false);
                var et = DateTime.minDate(item.endTime, this.itemsEndTime, true);

                var partIndex = 0;
                if (st.compareTo(item.startTime) == 1) // right arrow
                    partIndex = 1;
                if (et.compareTo(item.endTime) == -1) // left arrow
                    partIndex = -1;
                if (st.compareTo(item.startTime) == 1 && et.compareTo(item.endTime) == -1) // both arrows
                    partIndex = 0;

                if (appointment.groupColumnIndex.length == 1) {
                    var scell = this.getTimeCell(st, false, appointment.groupColumnIndex[0]);
                    var lcell = this.getTimeCell(et, true, appointment.groupColumnIndex[0]);
                    var partData = {
                        prototype: appointment,
                        type: 'part',
                        cellIndex: scell.index,
                        cellsLength: lcell.index - scell.index + 1,
                        colIndex: scell.rowIndex,
                        isPartial: true,
                        partIndex: partIndex,
                        lastCellIndex: lcell.index,
                        startCellIndex: scell.index,
                        groupColumnIndex: appointment.groupColumnIndex
                    };
                    var part = new Appointment(partData);
                    part.composite = true;
                    parts.push(part);
                    removed.push(appointment);
                } else if (appointment.groupColumnIndex.length > 1) {
                    for (var i = 0, l = appointment.groupColumnIndex.length; i < l; i++) {
                        var scell = this.getTimeCell(st, false, appointment.groupColumnIndex[i]);
                        var lcell = this.getTimeCell(et, true, appointment.groupColumnIndex[i]);
                        var partData = {
                            prototype: appointment,
                            type: 'part',
                            cellIndex: scell.index,
                            cellsLength: lcell.index - scell.index + 1,
                            colIndex: scell.rowIndex,
                            isPartial: true,
                            partIndex: partIndex,
                            lastCellIndex: lcell.index,
                            startCellIndex: scell.index,
                            groupColumnIndex: appointment.groupColumnIndex[i]
                        };
                        var part = new Appointment(partData);
                        part.composite = true;
                        parts.push(part);
                        removed.push(appointment);
                    }
                }
            } else if (appointment.groupColumnIndex.length == 1) {
                var cell = this.getTimeCell(item.startTime, false, appointment.groupColumnIndex[0]);
                if (item.startTime._date.valueOf() == item.endTime._date.valueOf()) {
                    var lcell = cell;
                } else {
                    var lcell = this.getTimeCell(item.endTime, true, appointment.groupColumnIndex[0]);
                }
                appointment.lastCellIndex = lcell.index;
                appointment.startCellIndex = cell.index;
                appointment.cellsLength = lcell.index - cell.index + 1;
                if (appointment.cellsLength < 1) {
                    appointment.cellsLength = 1;
                }
                appointment.cellIndex = cell.index;
                appointment.colIndex = cell.rowIndex;
                appointment.updateVisual();
            } else if (appointment.groupColumnIndex.length > 1) {
                for (var i = 0, l = appointment.groupColumnIndex.length; i < l; i++) {
                    var cell = this.getTimeCell(item.startTime, false, appointment.groupColumnIndex[i]);
                    if (item.startTime._date.valueOf() == item.endTime._date.valueOf()) {
                        var lcell = cell;
                    } else {
                        var lcell = this.getTimeCell(item.endTime, true, appointment.groupColumnIndex[i]);
                    }
                    var partData = {
                        prototype: appointment,
                        type: 'part',
                        cellIndex: cell.index,
                        cellsLength: lcell.index - cell.index + 1,
                        colIndex: appointment.groupColumnIndex[i],
                        isPartial: true,
                        partIndex: undefined,
                        lastCellIndex: lcell.index,
                        startCellIndex: cell.index,
                        groupColumnIndex: appointment.groupColumnIndex[i]
                    };
                    var part = new Appointment(partData);
                    part.composite = true;
                    parts.push(part);
                    removed.push(appointment);
                }
            }

            for (var i = 0; i < removed.length; i++) {
                this.removeAppointment(removed[i]);
            }

            if (addToItems != false) this.items = this.items.concat(parts);

            for (var i = 0; i < parts.length; i++) {
                parts[i].updateVisual();
            }

            //return value is only used for recurrent composite items
            if (parts.length > 0) return parts;
            parts.push(appointment);
            return parts;
        }
    }, {
        key: 'isComposite',
        value: function isComposite(item) {
            if (item.startTime.valueOf() == item.endTime.valueOf()) {
                return false;
            }
            if (item.startTime.valueOf() < this._rows.items()[0].itemsStartTime.valueOf()) return true;
            if (item.endTime.valueOf() > this._rows.items()[0].itemsEndTime.valueOf()) return true;

            return false;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'hasVisibleParts',
        value: function hasVisibleParts(item) {
            if (this.getItemCols(item).length == 0) return false;
            if (item.startTime.valueOf() >= this._rows.items()[0].itemsStartTime.valueOf() && item.startTime.valueOf() < this._rows.items()[this._rows.count() - 1].itemsEndTime.valueOf()) return true;
            if (item.endTime.valueOf() > this._rows.items()[0].itemsStartTime.valueOf() && item.endTime.valueOf() < this._rows.items()[this._rows.count() - 1].itemsEndTime.valueOf()) return true;
            if (item.startTime.valueOf() <= this._rows.items()[0].itemsStartTime.valueOf() && item.endTime.valueOf() >= this._rows.items()[0].itemsEndTime.valueOf()) return true;
            return false;
        }
    }, {
        key: 'clear',
        value: function clear() {
            DomUtils.removeNodes(this.getContent().querySelectorAll('.mfp-item-wrap'));
            DomUtils.removeNodes(this.getContent().querySelectorAll('.mfp-item-row'));
            DomUtils.removeNodes(this.getContent().querySelectorAll('.mfp-lane-row'));
        }
    }, {
        key: 'init',
        value: function init() {
            if (!this.grouped) return;

            if (!this.cellWidth) this.getDimensions();

            this.getAllItems();

            for (var k = 0, m = this.groupCols.length; k < m; k++) {
                this.itemsToPut = this.getItemsToPut(k);

                for (var i = 0, l = this._rows.count(); i < l; i++) {
                    this.createItemsTable(this._rows.items()[i], k);
                }

                for (var i = 0; i < this.itemsToPut.length; i++) {
                    var item = this.items[this.items.indexOf(this.itemsToPut[i])];
                    item.cell = null;
                    item.row = -1;
                    item.hidden = true;
                }
            }

            this.createLanes();
            this.placeItems();
        }
    }, {
        key: 'createItemsTable',
        value: function createItemsTable(row, groupCol) {
            var used = false;
            var items = this.getItemsToPutInCol(groupCol);

            for (var i = 0, l = items.length; i < l; i++) {
                used = false;
                var trow = document.createElement('tr');
                trow.className = 'mfp-item-row';
                trow.style.height = this.calendar.itemSettings.size + this.calendar.itemSettings.spacing + 'px';
                var day = 0;

                while (day < this.rowCellsCount) {

                    var items = this.getItemsInCell(row.cells.items()[day], this.itemsToPut);
                    var item = null;
                    if (items.length > 0) item = items[0];
                    if (item != null) {
                        var tcell = document.createElement('td');
                        tcell.className = 'mfp-item-cell';
                        tcell.style.paddingLeft = this.gridBorderLeft + 'px';
                        tcell.style.paddingRight = this.gridBorderRight + 'px';
                        tcell.colSpan = item.cellsLength;
                        day += item.cellsLength - 1;
                        item.cell = tcell;
                        item.row = i;
                        used = true;
                        this.itemsToPut.splice(this.itemsToPut.indexOf(item), 1);
                    } else {
                        var tcell = document.createElement('td');
                        tcell.className = 'mfp-item-cell';
                    }
                    trow.appendChild(tcell);
                    day += 1;
                }

                if (used) {
                    this.groupCols[groupCol].itemTable.appendChild(trow);
                }
            }
        }
    }, {
        key: 'createLanes',
        value: function createLanes() {
            for (var i = 0, l = this._rows.count(); i < l; i++) {
                while (this.groupCols[i].laneTable.rows.length < this.groupCols[i].itemTable.rows.length + 1) {
                    this.addLaneRow(i);
                }
            }

            for (var i = 0, l = this.groupCols.length; i < l; i++) {
                var rowHeight = DomUtils.getBounds(this.getRows()[i]).height;
                this.groupCols[i].header.style.height = rowHeight + "px";
            }
        }
        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'addLaneRow',
        value: function addLaneRow(groupCol) {
            var trow = document.createElement('tr');
            trow.className = 'mfp-lane-row';
            trow.style.height = this.calendar.itemSettings.size + this.calendar.itemSettings.spacing + 'px';

            for (var i = 0, l = this.rowCellsCount; i < l; i++) {
                var tcell = document.createElement('td');
                tcell.className = 'mfp-lane-cell';
                trow.appendChild(tcell);
            }
            this.groupCols[groupCol].laneTable.tBodies[0].appendChild(trow);
        }
    }, {
        key: 'getItemCols',
        value: function getItemCols(item) {
            var result = [];
            if (this.resources == null || !this.grouped) {
                result.push(0);
                return result;
            }
            for (var i = 0, l = this.resources.length; i < l; i++) {
                if (item.hasResource(this.resources[i])) {
                    result.push(i);
                }
            }
            return result;
        }
    }, {
        key: 'getItemsToPutInCol',
        value: function getItemsToPutInCol(groupCol) {
            var items = [];
            for (var i = 0, l = this.itemsToPut.length; i < l; i++) {
                if (this.itemsToPut[i].groupColumnIndex == groupCol) items.push(this.itemsToPut[i]);
            }
            return items;
        }
    }, {
        key: 'getItemsInCell',
        value: function getItemsInCell(cell, items) {
            var result = [];
            for (var i = 0, l = items.length; i < l; i++) {
                if (items[i].startCellIndex == cell.index) result.push(items[i]);
            }
            return result;
        }
    }, {
        key: 'getAllItemsInCell',
        value: function getAllItemsInCell(cell) {
            var result = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].groupColumnIndex == cell.columnIndex) {
                    if (this.items[i].startCellIndex <= cell.index && this.items[i].lastCellIndex >= cell.index) {
                        result.push(this.items[i]);
                    }
                }
            }
            return result;
        }
    }, {
        key: 'getGroupCells',
        value: function getGroupCells(col) {
            var cells = [];
            this.cells.forEach(function (t) {
                if (t.columnIndex == col) cells.push(t);
            });
            return cells;
        }
    }, {
        key: 'getTimeCell',
        value: function getTimeCell(time, isEndTime, col) {
            if (col.length != undefined) col = col[0];

            if (col < 0 || col > this.groupCols.length - 1) return null;

            var cells = this.getGroupCells(col);

            if (!cells || cells.length == 0) return null;
            if (time.valueOf() < this.startTime.valueOf()) return null;
            if (time.valueOf() > this.endTime.valueOf()) return null;

            var t = this.setTimeOfUnit(this.startTime, time);
            var i = this.unitsBetween(this.startTime, t);

            i = Math.floor(i);

            if (this.skipNext > 0 && i > cells.length) {
                return cells[cells.length - 1];
            }

            if (i > cells.length) return null;
            if (i == cells.length) {
                if (isEndTime && time.equals(cells[i - 1].endTime)) return cells[i - 1];else return null;
            }
            if (isEndTime && DateTime.isSameDate(time, cells[i].startTime) && i > 0) {
                i -= 1;
            }

            return cells[i];
        }
    }, {
        key: 'getTimeCells',
        value: function getTimeCells(startTime, endTime, isEndTime, col) {
            var startCell = null;
            var endCell = null;

            if (col.length != undefined) col = col[0];

            if (col < 0 || col > this.groupCols.length - 1) return null;

            var cells = this.getGroupCells(col);

            if (!cells) return [];

            if (startTime.valueOf() < this.startTime.valueOf()) {
                startCell = cells[0];
            } else if (startTime.valueOf() > this.endTime.valueOf()) {
                return [];
            } else {
                startCell = this.getTimeCell(startTime, false, col);
            }
            if (endTime !== null && typeof endTime !== "undefined" && typeof endTime._date !== "undefined") {
                if (endTime.valueOf() > this.endTime.valueOf()) {
                    endCell = cells[cells.length - 1];
                } else if (endTime.valueOf() < this.startTime.valueOf()) {
                    return [];
                } else {
                    endCell = this.getTimeCell(endTime, isEndTime, col);
                }
            } else {
                endCell = startCell;
            }

            if (startCell && endCell) {
                return cells.slice(startCell.index, endCell.index + 1);
            }
            return [];
        }
    }, {
        key: 'setTimeOfUnit',
        value: function setTimeOfUnit(time, day) {
            var result = 0;
            switch (this._timelineSettings.unit) {
                case TimeUnit.Second:
                    result = DateTime.setTimeOfSecond(time, day);
                    break;
                case TimeUnit.Minute:
                    result = DateTime.setTimeOfMinute(time, day);
                    break;
                case TimeUnit.Hour:
                    result = DateTime.setTimeOfHour(time, day);
                    break;
                case TimeUnit.Day:
                    result = DateTime.setTimeOfDay(time, day);
                    break;
                case TimeUnit.Week:
                    result = DateTime.setDayOfWeek(time, day);
                    break;
                case TimeUnit.Month:
                    result = DateTime.setDayOfMonth(time, day);
                    break;
                case TimeUnit.Year:
                    result = DateTime.setDayOfYear(time, day);
                    break;
            }
            return result;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'unitsBetween',
        value: function unitsBetween(date1, date2) {
            var result = 0;
            switch (this._timelineSettings.unit) {
                case TimeUnit.Second:
                    result = DateTime.secondsBetween(date1, date2);
                    break;
                case TimeUnit.Minute:
                    result = DateTime.minutesBetween(date1, date2);
                    break;
                case TimeUnit.Hour:
                    result = DateTime.hoursBetween(date1, date2);
                    break;
                case TimeUnit.Day:
                    result = DateTime.daysBetween(date1, date2);
                    break;
                case TimeUnit.Week:
                    result = DateTime.weeksBetween(date1, date2);
                    break;
                case TimeUnit.Month:
                    result = DateTime.monthsBetween(date1, date2);
                    break;
                case TimeUnit.Year:
                    result = DateTime.yearsBetween(date1, date2);
                    break;
            }
            return result / this._timelineSettings.unitCount;
        }
    }, {
        key: 'getItemsToPut',
        value: function getItemsToPut(groupCol) {
            var result = [];
            for (var i = 0, l = this.items.length; i < l; i++) {
                if (this.items[i].item.visible && this.items[i].groupColumnIndex == groupCol) {
                    result.push(this.items[i]);
                }
            }
            return result;
        }
    }, {
        key: 'getRowAt',
        value: function getRowAt(y) {
            for (var i = 0, l = this._rows.count(); i < l; i++) {
                var b = DomUtils.getRelativeBounds(this._rows.items()[i].bgTable, this.getContent());
                if (y >= b.y && y <= b.y + b.height) {
                    return i;
                }
            }
            return -1;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getCellAt',
        value: function getCellAt(x, y, resource) {
            var i = this.getCellIndexAt(x, y, resource);
            if (i >= this.cells.count()) {
                
            }
            return this.cells.items()[i];
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getCellIndexAt',
        value: function getCellIndexAt(x, y, resource) {
            if (!this.cellWidth) this.getDimensions();

            var cursor = DomUtils.getCursorPosition({ clientX: x, clientY: y }, this.getContent(), this.getScroller());

            var r = this.getRowAt(cursor.y + this.getScroller().scrollTop);
            var c = Math.floor(cursor.x / this.calculatedCellWidth);
            if (r >= this._rows.count() || r < 0) {
                return null;
            }
            if (c >= this.rowCellsCount || c < 0) {
                return null;
            }
            var index = c + r * this.rowCellsCount;
            if (resource && this.cells.items()[index].resource != resource) {
                var cell = this.getTimeCell(this.cells.items()[index].startTime, false, this.resources.indexOf(resource));
                index = this.cells.indexOfItem(cell);
            }

            return index;
        }
    }, {
        key: 'getItemsCount',
        value: function getItemsCount(cell) {
            return this.groupCols[cell.columnIndex].itemTable.rows.length || 1;
        }

        /* Render */

    }, {
        key: 'draw',
        value: function draw() {
            this._element = document.createElement("div");

            var h = this.drawHeader();
            this._element.appendChild(h);

            var w = document.createElement("div");
            w.className = "mfp-wrapper";
            this._element.appendChild(w);

            if (this._groupColumns > 0) {
                var g = this.drawGroupHeader();
                w.appendChild(g);
            }

            var c = this.drawContent();
            w.appendChild(c);

            return this._element;
        }
    }, {
        key: 'drawHeader',
        value: function drawHeader() {
            var result = null;

            var d = document.createElement("div");
            d.className = "mfp-header";
            result = d;

            var c = document.createElement("div");
            c.innerHTML = "&nbsp;";
            d.appendChild(c);

            var h = document.createElement("div");
            h.className = "mfp-header-timeline";
            d.appendChild(h);

            if (this._settings.timelines >= 3) {
                var t1 = this.drawTimeline(ResourceViewTimeline.Top);
                h.appendChild(t1);
            }
            if (this._settings.timelines >= 2) {
                var t2 = this.drawTimeline(ResourceViewTimeline.Middle);
                h.appendChild(t2);
            }
            if (this._settings.timelines >= 1) {
                var t3 = this.drawTimeline(ResourceViewTimeline.Bottom);
                h.appendChild(t3);
            }

            return result;
        }
    }, {
        key: 'drawContent',
        value: function drawContent() {
            var result = null;

            var w = document.createElement("div");
            w.className = "mfp-content";
            result = w;

            var content = document.createElement("div");
            content.className = "mfp-content-wrap";
            w.appendChild(content);

            for (var k = 0; k < this._rows.count(); k++) {
                var r = document.createElement("div");
                r.className = "mfp-wrap";
                r.style.height = "auto";
                r.style.minHeight = this.calendar.itemSettings.size + this.calendar.itemSettings.spacing + "px";
                content.appendChild(r);

                var t = this.drawBackgroundTable();
                r.appendChild(t);

                var t = this.drawItemTable();
                r.appendChild(t);

                var t = this.drawLaneTable();
                r.appendChild(t);
            }

            return result;
        }
    }, {
        key: 'drawItemTable',
        value: function drawItemTable() {
            var result = null;
            var table = document.createElement("table");
            table.className = "mfp-item-table";
            result = table;
            return result;
        }
    }, {
        key: 'drawBackgroundTable',
        value: function drawBackgroundTable() {
            var result = null;

            var dayClass = "mfp-bg-cell";

            var r = document.createElement("div");
            r.className = "mfp-bg-row";
            result = r;

            for (var k = 0; k < this._realCells; k++) {
                var d = document.createElement("div");
                d.className = dayClass;
                r.appendChild(d);
            }

            return result;
        }
    }, {
        key: 'drawLaneTable',
        value: function drawLaneTable() {
            var result = null;

            var t = document.createElement("table");
            t.className = "mfp-lane-table";
            t.cellPadding = "0";
            t.cellSpacing = "0";
            result = t;

            var tb = document.createElement("tbody");
            t.appendChild(tb);

            return result;
        }
    }, {
        key: 'drawGroupHeader',
        value: function drawGroupHeader() {
            var result = null;
            var groupName;

            var w = document.createElement("div");
            w.className = "mfp-header-group";
            result = w;

            var d = document.createElement("div");
            d.className = "mfp-header-group-wrap";
            w.appendChild(d);

            for (var k = 0; k < this._rows.count(); k++) {
                groupName = this.calendar.getResourceName(this.calendar.groupResources.items()[k]);

                var g = document.createElement("div");
                d.appendChild(g);
                g.innerHTML = groupName || "&nbsp;";
            }

            return result;
        }
    }, {
        key: 'drawTimeline',
        value: function drawTimeline(type) {
            var result = null;

            var settings = this._timelineSettings;
            var cells = this._bottomTimelineCells;
            switch (type) {
                case ResourceViewTimeline.Top:
                    settings = this._settings.topTimelineSettings;
                    cells = this._topTimelineCells;
                    break;
                case ResourceViewTimeline.Middle:
                    settings = this._settings.middleTimelineSettings;
                    cells = this._middleTimelineCells;
                    break;
            }

            var time = this._date;
            var t = document.createElement("div");
            t.className = "mfp-timeline";
            result = t;

            for (var day = 0; day < cells.count(); day++) {
                var td = document.createElement("div");

                t.appendChild(td);

                var span = document.createElement("span");

                td.appendChild(span);
                span.innerHTML = time.toString(settings.format, this.formatInfo);

                if (DateTime.isTimeSpanShorter(time, settings.unit, settings.unitCount, this.formatInfo)) {
                    var check = time.clone();

                    time = DateTime.getFirstDateAfter(time, settings.unit, settings.unitCount, this.formatInfo);

                    if (check.equals(time)) time = DateTime.getNextDate(time, settings.unit, settings.unitCount);
                } else time = DateTime.getNextDate(time, settings.unit, settings.unitCount);
            }

            return result;
        }

        /* End Render */

        /**
            * For internal use only.
            * @private
            */

    }, {
        key: 'addUnits',
        value: function addUnits(date, count) {
            count *= this._timelineSettings.unitCount;
            var result;
            switch (this._timelineSettings.unit) {
                case TimeUnit.Second:
                    {
                        var r = new DateTime(DateTime.addSeconds2(new Date(date._date.valueOf()), count));
                        result = DateTime.addSeconds(date, count);
                        if (result < r) {
                            return r;
                        }
                        if (result._date.getHours() - r._date.getHours() > 1) {
                            this.skipNext = 3600 + count;
                        } else {
                            if (this.skipNext > 0) {
                                this.skipped = true;
                            }
                            if (this.skipNext == 0 && this.skipped) {
                                result._date.setHours(result._date.getHours() - 1);
                            }
                            this.skipNext = 0;
                        }
                        break;
                    }
                case TimeUnit.Minute:
                    {
                        var r = new DateTime(DateTime.addMinutes2(new Date(date._date.valueOf()), count));
                        result = DateTime.addMinutes(date, count);
                        if (result < r) {
                            return r;
                        }
                        if (result._date.getHours() - r._date.getHours() > 1) {
                            this.skipNext = 60 + count;
                        } else {
                            if (this.skipNext > 0) {
                                this.skipped = true;
                            }
                            if (this.skipNext == 0 && this.skipped) {
                                result._date.setHours(result._date.getHours() - 1);
                            }
                            this.skipNext = 0;
                        }
                        break;
                    }
                case TimeUnit.Hour:
                    {
                        var r = new DateTime(DateTime.addHours2(new Date(date._date.valueOf()), count));
                        result = DateTime.addHours(date, count);
                        if (result < r) {
                            return r;
                        }
                        if (result._date.getHours() - r._date.getHours() > 1) {
                            this.skipNext = 1 + count;
                        } else {
                            if (this.skipNext > 0) {
                                this.skipped = true;
                            }
                            if (this.skipNext == 0 && this.skipped) {
                                result._date.setHours(result._date.getHours() - 1);
                            }
                            this.skipNext = 0;
                        }
                        break;
                    }
                case TimeUnit.Day:
                    {
                        result = new DateTime(DateTime.addDays2(new Date(date._date.valueOf()), count));
                        break;
                    }
                case TimeUnit.Week:
                    {
                        result = new DateTime(DateTime.addWeeks2(new Date(date._date.valueOf()), count));
                        break;
                    }
                case TimeUnit.Month:
                    {
                        result = new DateTime(DateTime.addMonths2(new Date(date._date.valueOf()), count));
                        break;
                    }
                case TimeUnit.Year:
                    {
                        result = new DateTime(DateTime.addYears2(new Date(date._date.valueOf()), count));
                        break;
                    }
            }
            return result;
        }
    }, {
        key: 'cells',
        get: function get$$1() {
            var result = new List();
            this._rows.forEach(function (t) {
                result.addRange(t.cells.items());
            }, this);

            result.sort(function (a, b) {
                return a.cellIndex - b.cellIndex;
            });
            return result;
        }
    }, {
        key: 'cssClass',
        get: function get$$1() {
            return "mfp-resource-view";
        }
    }]);
    return ResourceViewCell;
}(Cell);

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* Defines properties that allow customization of the appearance of a Month view.
* @property {MainHeaderStyle} headerStyle Gets or sets the style of the view header.
* @property {VerticalHeaderStyle} weekHeaderStyle Gets or sets the style of the view week numbers header.
* @property {HorizontalHeaderStyle} dayNamesHeaderStyle Gets or sets the style of the view day names header.
* @property {DayOfWeekFormat} dayOfWeekFormat Gets or sets the format of the day names displayed in the day names header.
* @property {String} titleFormat Gets or sets the string used to format the header title.
* @property {Boolean} hideTrailingWeeks Gets or sets a value indicating whether to hide trailing weeks, which do not contain days from the current month.
* @property {Number} trailingWeekCount Gets or sets the number of full weeks to display from the next month.
* @property {Number} leadingWeekCount Gets or sets the number of full weeks to display from the previous month.
* @property {Boolean} showPaddingDays Gets or sets a value indicating whether to display days from the
* previous and next months at the beginning and the end of the current one, in order to fill the whole grid of day cells.
* @property {Boolean} showPaddingItems Gets or sets a value indicating whether items are shown in padding days.
* @property {String} generalFormat Gets or sets the string used to format cells' headers.
* @property {String} firstDayOfMonthFormat Gets or sets the string used to format the cell header of the first day of each month.
* @property {String} firstDayOfYearFormat Gets or sets the string used to format the cell header of the first day of each year.
* @property {Number} maxItems Gets or sets the maximum number of items to display in a cell.
*/
var MonthSettings = function () {
  function MonthSettings(calendar) {
    classCallCheck(this, MonthSettings);


    this.calendar = calendar;

    this._headerStyle = MainHeaderStyle.Title | MainHeaderStyle.Buttons;
    this._weekHeaderStyle = VerticalHeaderStyle.Left;
    this._dayNamesHeaderStyle = HorizontalHeaderStyle.Top;
    this._dayOfWeekFormat = DayOfWeekFormat.Abbreviated;
    this._titleFormat = "mmmm, yyyy";

    this._hideTrailingWeeks = true;
    this._trailingWeekCount = 0;
    this._leadingWeekCount = 0;

    this._showPaddingDays = true;
    this._showPaddingItems = true;

    this._generalFormat = "d ";
    this._firstDayOfMonthFormat = "d MMM";
    this._firstDayOfYearFormat = "d ";

    this._propertyChanged = new EventDispatcher();
  }

  /**
  * Copies property values from another object.
  * @param {Object} settings An object containing property values.
  */


  createClass(MonthSettings, [{
    key: 'copyFrom',
    value: function copyFrom(settings) {
      if (!settings) return;

      if (settings.headerStyle !== undefined) this.headerStyle = settings.headerStyle;
      if (settings.weekHeaderStyle !== undefined) this.weekHeaderStyle = settings.weekHeaderStyle;
      if (settings.dayNamesHeaderStyle !== undefined) this.dayNamesHeaderStyle = settings.dayNamesHeaderStyle;
      if (settings.dayOfWeekFormat !== undefined) this.dayOfWeekFormat = settings.dayOfWeekFormat;
      if (settings.titleFormat !== undefined) this.titleFormat = settings.titleFormat;

      if (settings.hideTrailingWeeks !== undefined) this.hideTrailingWeeks = settings.hideTrailingWeeks;
      if (settings.trailingWeekCount !== undefined) this.trailingWeekCount = settings.trailingWeekCount;
      if (settings.leadingWeekCount !== undefined) this.leadingWeekCount = settings.leadingWeekCount;

      if (settings.showPaddingDays !== undefined) this.showPaddingDays = settings.showPaddingDays;
      if (settings.showPaddingItems !== undefined) this.showPaddingItems = settings.showPaddingItems;

      if (settings.generalFormat !== undefined) this.generalFormat = settings.generalFormat;
      if (settings.firstDayOfMonthFormat !== undefined) this.firstDayOfMonthFormat = settings.firstDayOfMonthFormat;
      if (settings.firstDayOfYearFormat !== undefined) this.firstDayOfYearFormat = settings.firstDayOfYearFormat;

      if (settings.maxItems !== undefined) this.maxItems = settings.maxItems;
    }

    /**
     * Raises the propertyChanged event.
     * @package
     */

  }, {
    key: 'onPropertyChanged',
    value: function onPropertyChanged(name, oldValue, newValue) {
      this._propertyChanged.raiseEvent(this, new PropertyEventArgs(name, oldValue, newValue));
    }

    /**
    * For internal use only.
    * @private
    */

  }, {
    key: 'showHeader',
    get: function get$$1() {
      return this.headerStyle !== MainHeaderStyle.None;
    }
    /**
    * For internal use only.
    * @private
    */

  }, {
    key: 'showDayNamesHeader',
    get: function get$$1() {
      return this.dayNamesHeaderStyle !== HorizontalHeaderStyle.None;
    }
    /**
    * For internal use only.
    * @private
    */

  }, {
    key: 'showWeekHeader',
    get: function get$$1() {
      return this._weekHeaderStyle !== VerticalHeaderStyle.None;
    }

    /**
    * Gets the style of the view header.
    * @returns {MainHeaderStyle} One of the MainHeaderStyle enumeration values.
    */

  }, {
    key: 'headerStyle',
    get: function get$$1() {
      return this._headerStyle;
    }

    /**
    * Sets the style of the view header.
    * @param {MainHeaderStyle} value One of the MainHeaderStyle enumeration values.
    */
    ,
    set: function set$$1(value) {
      var oldValue = this._headerStyle;
      this._headerStyle = value;
      this.onPropertyChanged('headerStyle', oldValue, value);
    }

    /**
    * Gets the style of the view week numbers header.
    * @returns {VerticalHeaderStyle} One of the VerticalHeaderStyle enumeration values.
    */

  }, {
    key: 'weekHeaderStyle',
    get: function get$$1() {
      return this._weekHeaderStyle;
    }

    /**
    * Sets the style of the view week numbers header.
    * @param {VerticalHeaderStyle} value One of the VerticalHeaderStyle enumeration values.
    */
    ,
    set: function set$$1(value) {
      var oldValue = this._weekHeaderStyle;
      this._weekHeaderStyle = value;
      this.onPropertyChanged('weekHeaderStyle', oldValue, value);
    }

    /**
    * Gets the style of the view day names header.
    * @returns {HorizontalHeaderStyle} One of the HorizontalHeaderStyle enumeration values.
    */

  }, {
    key: 'dayNamesHeaderStyle',
    get: function get$$1() {
      return this._dayNamesHeaderStyle;
    }

    /**
    * Sets the style of the view day names header.
    * @param {HorizontalHeaderStyle} value One of the HorizontalHeaderStyle enumeration values.
    */
    ,
    set: function set$$1(value) {
      var oldValue = this._dayNamesHeaderStyle;
      this._dayNamesHeaderStyle = value;
      this.onPropertyChanged('dayNamesHeaderStyle', oldValue, value);
    }

    /**
    * Gets the format of the day names displayed in the day names header.
    * @returns {DayOfWeekFormat} One of the DayOfWeekFormat enumeration values.
    */

  }, {
    key: 'dayOfWeekFormat',
    get: function get$$1() {
      return this._dayOfWeekFormat;
    }

    /**
    * Sets the format of the day names displayed in the day names header.
    * @param {DayOfWeekFormat} value One of the DayOfWeekFormat enumeration values.
    */
    ,
    set: function set$$1(value) {
      var oldValue = this._dayOfWeekFormat;
      this._dayOfWeekFormat = value;
      this.onPropertyChanged('dayOfWeekFormat', oldValue, value);
    }

    /**
    * Gets the string used to format the header title.
    * @returns {String} The format string.
    */

  }, {
    key: 'titleFormat',
    get: function get$$1() {
      return this._titleFormat;
    }

    /**
    * Sets the string used to format the header title.
    * @param {String} value The format string.
    */
    ,
    set: function set$$1(value) {
      var oldValue = this._titleFormat;
      this._titleFormat = value;
      this.onPropertyChanged('titleFormat', oldValue, value);
    }

    /**
    * Gets a value indicating whether items are shown in padding days.
    * @returns {Boolean} True if items are shown in padding days, otherwise false.
    */

  }, {
    key: 'showPaddingItems',
    get: function get$$1() {
      return this._showPaddingItems;
    }

    /**
    * Sets a value indicating whether items are shown in padding days.
    * @param {Boolean} value True if items are shown in padding days, otherwise false.
    */
    ,
    set: function set$$1(value) {
      var oldValue = this._showPaddingItems;
      this._showPaddingItems = value;
      this.onPropertyChanged('showPaddingItems', oldValue, value);
    }

    /**
    * Gets a value indicating whether to display days from the
    * previous and next months at the beginning and the end of the current
    * one, in order to fill the whole grid of day cells.
    * @returns {Boolean} True if padding days are displayed, otherwise false.
    */

  }, {
    key: 'showPaddingDays',
    get: function get$$1() {
      return this._showPaddingDays;
    }

    /**
    * Sets a value indicating whether to display days from the
    * previous and next months at the beginning and the end of the current
    * one, in order to fill the whole grid of day cells.
    * @param {Boolean} value True if padding days are displayed, otherwise false.
    */
    ,
    set: function set$$1(value) {
      var oldValue = this._showPaddingDays;
      this._showPaddingDays = value;
      this.onPropertyChanged('showPaddingDays', oldValue, value);
    }

    /**
    * Gets a value indicating whether to hide trailing weeks,
    * which do not contain days from the current month.
    * @returns {Boolean} True to hide trailing weeks, otherwise false.
    */

  }, {
    key: 'hideTrailingWeeks',
    get: function get$$1() {
      return this._hideTrailingWeeks;
    }

    /**
    * Sets a value indicating whether to hide trailing weeks,
    * which do not contain days from the current month.
    * @param {Boolean} value True to hide trailing weeks, otherwise false.
    */
    ,
    set: function set$$1(value) {
      var oldValue = this._hideTrailingWeeks;
      this._hideTrailingWeeks = value;
      this.onPropertyChanged('hideTrailingWeeks', oldValue, value);
    }

    /**
    * Gets the number of full weeks to display from the previous month.
    * @returns {Number} The number of full weeks to display from the previous month.
    */

  }, {
    key: 'leadingWeekCount',
    get: function get$$1() {
      return this._leadingWeekCount;
    }

    /**
    * Sets the number of full weeks to display from the previous month.
    * @param {Number} value The number of full weeks to display from the previous month.
    */
    ,
    set: function set$$1(value) {
      var oldValue = this._leadingWeekCount;
      this._leadingWeekCount = value;
      this.onPropertyChanged('leadingWeekCount', oldValue, value);
    }

    /**
    * Gets the number of full weeks to display from the next month.
    * @returns {Number} The number of full weeks to display from the next month.
    */

  }, {
    key: 'trailingWeekCount',
    get: function get$$1() {
      return this._trailingWeekCount;
    }

    /**
    * Sets the number of full weeks to display from the next month.
    * @param {Number} value The number of full weeks to display from the next month.
    */
    ,
    set: function set$$1(value) {
      var oldValue = this._trailingWeekCount;
      this._trailingWeekCount = value;
      this.onPropertyChanged('trailingWeekCount', oldValue, value);
    }

    /**
    * Gets the maximum number of calendar items to display in a view cell.
    * @returns {Number} The maximum number of calendar items to display in a view cell.
    */

  }, {
    key: 'maxItems',
    get: function get$$1() {
      return this._maxItems;
    }

    /**
    * Sets the maximum number of calendar items to display in a view cell.
    * @param {Number} value The maximum number of calendar items to display in a view cell.
    */
    ,
    set: function set$$1(value) {
      var oldValue = this._maxItems;
      this._maxItems = value;
      this.onPropertyChanged('maxItems', oldValue, value);
    }

    /**
     * Gets the string used to format cells' headers.
     * @returns {String} The format string.
     */

  }, {
    key: 'generalFormat',
    get: function get$$1() {
      return this._generalFormat;
    }

    /**
    * Sets the string used to format cells' headers.
    * @param {String} value The format string.
    */
    ,
    set: function set$$1(value) {
      var oldValue = this._generalFormat;
      this._generalFormat = value;
      this.onPropertyChanged('generalFormat', oldValue, value);
    }

    /**
    * Gets the string used to format the cell header of the first day of each month.
    * @returns {String} The format string.
    */

  }, {
    key: 'firstDayOfMonthFormat',
    get: function get$$1() {
      return this._firstDayOfMonthFormat;
    }

    /**
    * Sets the string used to format the cell eader of the first day of each month.
    * @param {String} value The format string.
    */
    ,
    set: function set$$1(value) {
      var oldValue = this._firstDayOfMonthFormat;
      this._firstDayOfMonthFormat = value;
      this.onPropertyChanged('firstDayOfMonthFormat', oldValue, value);
    }

    /**
    * Gets the string used to format the cell header of the first day of each year.
    * @returns {String} The format string.
    */

  }, {
    key: 'firstDayOfYearFormat',
    get: function get$$1() {
      return this._firstDayOfYearFormat;
    }
    /**
    * Sets the string used to format the cell header of the first day of each year.
    * @param {String} value The format string.
    */
    ,
    set: function set$$1(value) {
      var oldValue = this._firstDayOfYearFormat;
      this._firstDayOfYearFormat = value;
      this.onPropertyChanged('firstDayOfYearFormat', oldValue, value);
    }
  }]);
  return MonthSettings;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* Defines properties that allow customization of the appearance of a MonthRange view.
* @property {Number} numberOfMonths Gets or sets the total number of months to be displayed in the view.
* @property {Number} monthsPerRow Gets or sets the number of months to be displayed in a row.
* @property {Number} visibleRows Gets or sets the number of rows visible at the same time.
* @property {MainHeaderStyle} headerStyle Gets or sets the style of the view header.
* @property {String} titleFormat Gets or sets the string used to format the header title.
* @property {String} titleSeparator Gets or sets the string used as a title separator.
*/
var MonthRangeSettings = function () {
    function MonthRangeSettings(calendar) {
        classCallCheck(this, MonthRangeSettings);

        this.calendar = calendar;

        this._numberOfMonths = 4;
        this._monthsPerRow = 2;
        this._visibleRows = 2;

        this._headerStyle = MainHeaderStyle.Title | MainHeaderStyle.Buttons;

        this._titleFormat = "MMMM, yyyy";
        this._titleSeparator = " - ";

        this._propertyChanged = new EventDispatcher();
    }

    /**
    * Copies property values from another object.
    * @param {Object} settings An object containing property values.
    */


    createClass(MonthRangeSettings, [{
        key: 'copyFrom',
        value: function copyFrom(settings) {
            if (!settings) return;

            if (settings.numberOfMonths !== undefined) this.numberOfMonths = settings.numberOfMonths;
            if (settings.monthsPerRow !== undefined) this.monthsPerRow = settings.monthsPerRow;
            if (settings.visibleRows !== undefined) this.visibleRows = settings.visibleRows;

            if (settings.headerStyle !== undefined) this.headerStyle = settings.headerStyle;

            if (settings.titleFormat !== undefined) this.titleFormat = settings.titleFormat;
            if (settings.titleSeparator !== undefined) this.titleSeparator = settings.titleSeparator;
        }

        /**
        * Raises the propertyChanged event.
        * @package
        */

    }, {
        key: 'onPropertyChanged',
        value: function onPropertyChanged(name, oldValue, newValue) {
            this._propertyChanged.raiseEvent(this, new PropertyEventArgs(name, oldValue, newValue));
        }

        /**
        * Gets the style of the view header.
        * @returns {MainHeaderStyle} One of the MainHeaderStyle enumeration values.
        */

    }, {
        key: 'headerStyle',
        get: function get$$1() {
            return this._headerStyle;
        }

        /**
        * Sets the style of the view header.
        * @param {MainHeaderStyle} value One of the MainHeaderStyle enumeration values.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._headerStyle;
            this._headerStyle = value;
            this.onPropertyChanged('headerStyle', oldValue, value);
        }

        /**
        * Gets the string used to format the header title.
        * @returns {String} The format string.
        */

    }, {
        key: 'titleFormat',
        get: function get$$1() {
            return this._titleFormat;
        }

        /**
        * Sets the string used to format the header title.
        * @param {String} value The format string.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._titleFormat;
            this._titleFormat = value;
            this.onPropertyChanged('titleFormat', oldValue, value);
        }
        /**
        * Gets the string used as a title separator.
        * @returns {String} The separator string.
        */

    }, {
        key: 'titleSeparator',
        get: function get$$1() {
            return this._titleSeparator;
        }
        /**
        * Sets the string used as a title separator.
        * @param {String} value The separator string.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._titleSeparator;
            this._titleSeparator = value;
            this.onPropertyChanged('titleSeparator', oldValue, value);
        }

        /**
        * Gets the number of rows visible at the same time.
        * @returns {Number} The number of rows visible at the same time.
        */

    }, {
        key: 'visibleRows',
        get: function get$$1() {
            return this._visibleRows;
        }

        /**
        * Sets the number of rows visible at the same time.
        * @param {Number} value The number of rows visible at the same time.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._visibleRows;
            this._visibleRows = value;
            this.onPropertyChanged('visibleRows', oldValue, value);
        }

        /**
        * Gets the number of months to be displayed in a row.
        * @returns {Number} The number of months to be displayed in a row.
        */

    }, {
        key: 'monthsPerRow',
        get: function get$$1() {
            return this._monthsPerRow;
        }

        /**
        * Sets the number of months to be displayed in a row.
        * @param {Number} value The number of months to be displayed in a row.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._monthsPerRow;
            this._monthsPerRow = value;
            this.onPropertyChanged('monthsPerRow', oldValue, value);
        }

        /**
        * Gets the total number of months to display in the view.
        * @returns {Number} The number of months to be displayed in the view.
        */

    }, {
        key: 'numberOfMonths',
        get: function get$$1() {
            return this._numberOfMonths;
        }

        /**
        * Sets the total number of months to be displayed in the view.
        * @param {Number} value The number of months to be displayed in the view.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._numberOfMonths;
            this._numberOfMonths = value;
            this.onPropertyChanged('numberOfMonths', oldValue, value);
        }
    }]);
    return MonthRangeSettings;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* Defines properties that allow customization of the appearance of a WeekRange view.
* @property {WeekRangeViewStyle} viewStyle Gets or sets the style of the view.
* @property {Number} visibleRows Gets or sets the number of rows visible at the same time.
* @property {MainHeaderStyle} headerStyle Gets or sets the style of the view header.
* @property {String} titleFormat Gets or sets the string used to format the header title.
* @property {String} titleSeparator Gets or sets the string used as a title separator.
* @property {HorizontalHeaderStyle} dayNamesHeaderStyle Gets or sets the style of the view day names header.
* @property {DayOfWeekFormat} dayOfWeekFormat Gets or sets the format of the day names displayed in the day names header.
* @property {String} generalFormat Gets or sets the string used to format cells' headers.
* @property {String} firstDayOfMonthFormat Gets or sets the string used to format the cell header of the first day of each month.
* @property {String} firstDayOfYearFormat Gets or sets the string used to format the cell header of the first day of each year.
* @property {Number} maxItems Gets or sets the maximum number of items to display in a cell.
*/
var WeekRangeSettings = function () {
	function WeekRangeSettings(calendar) {
		classCallCheck(this, WeekRangeSettings);

		this.calendar = calendar;

		this._viewStyle = WeekRangeViewStyle.WeekPerRow;

		this._visibleRows = 4;

		this._headerStyle = MainHeaderStyle.Title;
		this._titleFormat = "dd MMMM";
		this._titleSeparator = " - ";

		this._dayNamesHeaderStyle = HorizontalHeaderStyle.Top;
		this._dayOfWeekFormat = DayOfWeekFormat.Abbreviated;

		this._generalFormat = "d ";
		this._firstDayOfMonthFormat = "d MMM";
		this._firstDayOfYearFormat = "d ";

		this._propertyChanged = new EventDispatcher();
	}

	/**
 * Copies property values from another object.
 * @param {Object} settings An object containing property values.
 */


	createClass(WeekRangeSettings, [{
		key: 'copyFrom',
		value: function copyFrom(settings) {
			if (!settings) return;

			if (settings.viewStyle !== undefined) this.viewStyle = settings.viewStyle;

			if (settings.visibleRows !== undefined) this.visibleRows = settings.visibleRows;

			if (settings.headerStyle !== undefined) this.headerStyle = settings.headerStyle;
			if (settings.titleFormat !== undefined) this.titleFormat = settings.titleFormat;
			if (settings.titleSeparator !== undefined) this.titleSeparator = settings.titleSeparator;

			if (settings.dayNamesHeaderStyle !== undefined) this.dayNamesHeaderStyle = settings.dayNamesHeaderStyle;
			if (settings.dayOfWeekFormat !== undefined) this.dayOfWeekFormat = settings.dayOfWeekFormat;

			if (settings.generalFormat !== undefined) this.generalFormat = settings.generalFormat;
			if (settings.firstDayOfMonthFormat !== undefined) this.firstDayOfMonthFormat = settings.firstDayOfMonthFormat;
			if (settings.firstDayOfYearFormat !== undefined) this.firstDayOfYearFormat = settings.firstDayOfYearFormat;

			if (settings.maxItems !== undefined) this.maxItems = settings.maxItems;
		}

		/**
  	* Raises the propertyChanged event.
  	* @package
  	*/

	}, {
		key: 'onPropertyChanged',
		value: function onPropertyChanged(name, oldValue, newValue) {
			this._propertyChanged.raiseEvent(this, new PropertyEventArgs(name, oldValue, newValue));
		}

		/**
  * Gets the number of rows visible at the same time.
  * @returns {Number} The number of rows visible at the same time.
  */

	}, {
		key: 'visibleRows',
		get: function get$$1() {
			return this._visibleRows;
		}
		/**
     * Sets the number of rows visible at the same time.
     * @param {Number} value The number of rows visible at the same time.
     */
		,
		set: function set$$1(value) {
			var oldValue = this._visibleRows;
			this._visibleRows = value;
			this.onPropertyChanged('visibleRows', oldValue, value);
		}
		/**
  * Gets the style of the view.
  * @returns {WeekRangeViewStyle} One of the WeekRangeViewStyle enumeration values.
  */

	}, {
		key: 'viewStyle',
		get: function get$$1() {
			return this._viewStyle;
		}
		/**
  * Sets the style of the view.
  * @param {WeekRangeViewStyle} value One of the WeekRangeViewStyle enumeration values.
  */
		,
		set: function set$$1(value) {
			var oldValue = this._viewStyle;
			this._viewStyle = value;
			this.onPropertyChanged('viewStyle', oldValue, value);
		}
		/**
  * Gets the style of the view header.
  * @returns {MainHeaderStyle} One of the MainHeaderStyle enumeration values.
  */

	}, {
		key: 'headerStyle',
		get: function get$$1() {
			return this._headerStyle;
		}
		/**
  * Sets the style of the view header.
  * @param {MainHeaderStyle} value One of the MainHeaderStyle enumeration values.
  */
		,
		set: function set$$1(value) {
			var oldValue = this._headerStyle;
			this._headerStyle = value;
			this.onPropertyChanged('headerStyle', oldValue, value);
		}
		/**
  * Gets the style of the day names header.
  * @returns {HorizontalHeaderStyle} One of the HorizontalHeaderStyle enumeration values.
  */

	}, {
		key: 'dayNamesHeaderStyle',
		get: function get$$1() {
			return this._dayNamesHeaderStyle;
		}
		/**
     * Sets the style of the day names header.
     * @param {HorizontalHeaderStyle} value One of the HorizontalHeaderStyle enumeration values.
     */
		,
		set: function set$$1(value) {
			var oldValue = this._dayNamesHeaderStyle;
			this._dayNamesHeaderStyle = value;
			this.onPropertyChanged('dayNamesHeaderStyle', oldValue, value);
		}
		/**
  * Gets the format of the day names displayed in the day names header.
  * @returns {DayOfWeekFormat} One of the DayOfWeekFormat enumeration values.
  */

	}, {
		key: 'dayOfWeekFormat',
		get: function get$$1() {
			return this._dayOfWeekFormat;
		}
		/**
  * Sets the format of the day names displayed in the day names header.
  * @param {DayOfWeekFormat} value One of the DayOfWeekFormat enumeration values.
  */
		,
		set: function set$$1(value) {
			var oldValue = this._dayOfWeekFormat;
			this._dayOfWeekFormat = value;
			this.onPropertyChanged('dayOfWeekFormat', oldValue, value);
		}
		/**
  * Gets the string used to format the header title.
  * @returns {String} The format string.
  */

	}, {
		key: 'titleFormat',
		get: function get$$1() {
			return this._titleFormat;
		}
		/**
     * Sets the string used to format the header title.
     * @param {String} value The format string.
     */
		,
		set: function set$$1(value) {
			var oldValue = this._titleFormat;
			this._titleFormat = value;
			this.onPropertyChanged('titleFormat', oldValue, value);
		}
		/**
  * Gets the string used as a title separator.
  * @returns {String} The separator string.
  */

	}, {
		key: 'titleSeparator',
		get: function get$$1() {
			return this._titleSeparator;
		}
		/**
     * Sets the string used as a title separator.
     * @param {String} value The separator string.
     */
		,
		set: function set$$1(value) {
			var oldValue = this._titleSeparator;
			this._titleSeparator = value;
			this.onPropertyChanged('titleSeparator', oldValue, value);
		}
		/**
  * Gets the string used to format cells' headers.
  * @returns {String} The format string.
  */

	}, {
		key: 'generalFormat',
		get: function get$$1() {
			return this._generalFormat;
		}
		/**
  * Sets the string used to format cells' headers.
  * @param {String} value The format string.
  */
		,
		set: function set$$1(value) {
			var oldValue = this._generalFormat;
			this._generalFormat = value;
			this.onPropertyChanged('generalFormat', oldValue, value);
		}
		/**
  * Gets the string used to format the cell header of the first day of each month.
  * @returns {String} The format string.
  */

	}, {
		key: 'firstDayOfMonthFormat',
		get: function get$$1() {
			return this._firstDayOfMonthFormat;
		}
		/**
  * Sets the string used to format the cell eader of the first day of each month.
  * @param {String} value The format string.
  */
		,
		set: function set$$1(value) {
			var oldValue = this._firstDayOfMonthFormat;
			this._firstDayOfMonthFormat = value;
			this.onPropertyChanged('firstDayOfMonthFormat', oldValue, value);
		}
		/**
  * Gets the string used to format the cell header of the first day of each year.
  * @returns {String} The format string.
  */

	}, {
		key: 'firstDayOfYearFormat',
		get: function get$$1() {
			return this._firstDayOfYearFormat;
		}
		/**
  * Sets the string used to format the cell header of the first day of each year.
  * @param {String} value The format string.
  */
		,
		set: function set$$1(value) {
			var oldValue = this._firstDayOfYearFormat;
			this._firstDayOfYearFormat = value;
			this.onPropertyChanged('firstDayOfYearFormat', oldValue, value);
		}

		/**
  * Gets the maximum number of calendar items to display in a view cell.
  * @returns {Number} The maximum number of calendar items to display in a view cell.
  */

	}, {
		key: 'maxItems',
		get: function get$$1() {
			return this._maxItems;
		}
		/**
   	* Sets the maximum number of calendar items to display in a view cell.
   	* @param {Number} value The maximum number of calendar items to display in a view cell.
   	*/
		,
		set: function set$$1(value) {
			var oldValue = this._maxItems;
			this._maxItems = value;
			this.onPropertyChanged('maxItems', oldValue, value);
		}
	}]);
	return WeekRangeSettings;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* Defines properties that allow customization of the appearance of a Timetable view.
* @property {ObservableCollection} dates Gets or sets the collection of dates to display in the view.
* @property {Orientation} orientation Gets or sets the orientation of the view.
* @property {Number} startTime Gets or sets the start time of the timetable, expressed in minutes since the beginning of the day.
* @property {Number} endTime Gets or sets the end time of the timetable, expressed in minutes since the beginning of the day.
* @property {Number} cellSize Gets or sets the size of time cells.
* @property {TimeSpan} cellTime Gets or sets the time length of a single cell in a timetable view, accurate to the nearest second.
* @property {Boolean} reverseGrouping Gets or sets a value indicating whether grouping (if enabled) will be performed first by the resource, and then by the date.
* @property {MainHeaderStyle} headerStyle Gets or sets the style of the view header.
* @property {String} titleFormat Gets or sets the string used to format the header title.
* @property {Boolean} showDayHeader Gets or sets a value indicating whether to show the header displaying all-day items.
* @property {Boolean} groupHours Gets or sets a value indicating whether hours displayed in the timeline are grouped.
* @property {Boolean} twelveHourFormat Gets or sets value indicating whether to use a 12-hour format.
* @property {Boolean} showMinutes Gets or sets a value indicating whether to display the minutes of each hour in the timeline header when it displays whole hour cells.
* @property {Boolean} showAM Gets or sets a value indicating whether the AM and PM suffixes are displayed.
* @property {Number} scrollStep Gets or sets the number of days to scroll when the user clicks the navigation buttons.
* @property {Number} maxItems Gets or sets the maximum number of items to display in a cell.
*/
var TimetableSettings = function () {
    function TimetableSettings(calendar) {
        var _this = this;

        classCallCheck(this, TimetableSettings);

        this.calendar = calendar;

        this._dates = new ObservableCollection();
        this._dates.collectionChanged.addEventListener(function (s, a) {
            _this.onDatesChanged(s, a);
        });

        this._orientation = Orientation.Vertical;
        this._startTime = 0;
        this._endTime = 1440;

        this._cellSize = 25;
        this._cellTime = new TimeSpan(DateTime.TicksPerHour / 2);
        this._reverseGrouping = false;

        this._headerStyle = MainHeaderStyle.Title | MainHeaderStyle.Buttons;
        this._titleFormat = calendar.formatInfo.dateFormats.shortDate;

        this._showDayHeader = true;

        this._generalFormat = "HH:mm tt";

        this._groupHours = true;
        this._twelveHourFormat = false;
        this._showMinutes = true;
        this._showAM = true;

        this._scrollStep = 1;
        this._maxItems = 3;

        this._propertyChanged = new EventDispatcher();
    }

    /**
    * Copies property values from another object.
    * @param {Object} settings An object containing property values.
    */


    createClass(TimetableSettings, [{
        key: 'copyFrom',
        value: function copyFrom(settings) {
            if (!settings) return;

            this._dates.clear();
            if (settings.dates !== undefined) {
                for (var i = 0; i < settings.dates.count(); i++) {
                    this._dates.add(settings.dates.items()[i]);
                }
            }

            if (settings.orientation !== undefined) this._orientation = settings.orientation;

            if (settings.startTime !== undefined) this.startTime = settings.startTime;
            if (settings.endTime !== undefined) this.endTime = settings.endTime;

            if (settings.cellSize !== undefined) this.cellSize = settings.cellSize;
            if (settings.cellTime !== undefined) this.cellTime = settings.cellTime;
            if (settings.reverseGrouping !== undefined) this.reverseGrouping = settings.reverseGrouping;

            if (settings.headerStyle !== undefined) this.headerStyle = settings.headerStyle;
            if (settings.titleFormat !== undefined) this.titleFormat = settings.titleFormat;

            if (settings.showDayHeader !== undefined) this.showDayHeader = settings.showDayHeader;

            if (settings.groupHours !== undefined) this.groupHours = settings.groupHours;
            if (settings.twelveHourFormat !== undefined) this.twelveHourFormat = settings.twelveHourFormat;
            if (settings.showMinutes !== undefined) this.showMinutes = settings.showMinutes;
            if (settings.showAM !== undefined) this.showAM = settings.showAM;

            if (settings.scrollStep !== undefined) this.scrollStep = settings.scrollStep;
            if (settings.maxItems !== undefined) this.maxItems = settings.maxItems;
        }

        /**
         * Raises the propertyChanged event.
         * @package
         */

    }, {
        key: 'onPropertyChanged',
        value: function onPropertyChanged(name, oldValue, newValue) {
            this._propertyChanged.raiseEvent(this, new PropertyEventArgs(name, oldValue, newValue));
        }

        /**
        * Gets the collection of all dates visible in the timetable.
        * @returns {ObservableCollection} A collection of DateTime objects.
        */

    }, {
        key: 'onDatesChanged',
        value: function onDatesChanged(sender, args) {
            if (args.action === NotifyCollectionChangedAction.Add) {
                this.dates.items()[this.dates.count() - 1] = this.dates.items()[this.dates.count() - 1].date;
            }
            this.onPropertyChanged('dates', null, this.dates);
        }

        /**
        * Gets a value indicating whether view cells are displayed horizontally or vertically.
        * @returns {Orientation} One of the Orientation enumeration values.
        */

    }, {
        key: 'dates',
        get: function get$$1() {
            return this._dates;
        }
    }, {
        key: 'orientation',
        get: function get$$1() {
            return this._orientation;
        }

        /**
        * Gets a value indicating whether view cells are displayed horizontally or vertically.
        * @param {Orientation} value One of the Orientation enumeration values.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._orientation;
            this._orientation = value;
            this.onPropertyChanged('orientation', oldValue, value);
        }

        /**
        * Gets a value indicating whether the header displaying all-day items is visible.
        * @returns {Boolean} True if day header is visible, otherwise false.
        */

    }, {
        key: 'showDayHeader',
        get: function get$$1() {
            return this._showDayHeader;
        }
        /**
        * Sets a value indicating whether the header displaying all-day items is visible.
        * @param {Boolean} value True if day header is visible, otherwise false.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._showDayHeader;
            this._showDayHeader = value;
            this.onPropertyChanged('showDayHeader', oldValue, value);
        }

        /**
        * Gets a value indicating whether whether grouping (if enabled)  will be performed first by the resource, and then by the date.
        * @returns {Boolean} True if grouping is reversed, otherwise false.
        * @remarks 	By default grouping is done first by available dates, then by
        * the resources specified in the current grouping type. Setting
        * this property to true reverses this behavior.
        */

    }, {
        key: 'reverseGrouping',
        get: function get$$1() {
            return this._reverseGrouping;
        }

        /**
        * Sets a value indicating whether whether grouping (if enabled)  will be performed first by the resource, and then by the date.
        * @param {Boolean} value True if grouping is reversed, otherwise false.
        * @remarks 	By default grouping is done first by available dates, then by
        * the resources specified in the current grouping type. Setting
        * this property to true reverses this behavior.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._reverseGrouping;
            this._reverseGrouping = value;
            this.onPropertyChanged('reverseGrouping', oldValue, value);
        }

        /**
        * Gets the size of time cells.
        * @returns {Number} The size of time cells in pixels.
        */

    }, {
        key: 'cellSize',
        get: function get$$1() {
            return this._cellSize;
        }
        /**
        * Sets the size of time cells.
        * @param {Number} value The size of time cells in pixels.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._cellSize;
            this._cellSize = value;
            this.onPropertyChanged('cellSize', oldValue, value);
        }

        /**
        * Gets the time length of a single cell in a timetable view, accurate to the nearest second.
        * @returns {TimeSpan} A TimeSpan object representing the time length of the cell.
        * @remarks Valid values for this property range from 1 second to 1 day.
        */

    }, {
        key: 'cellTime',
        get: function get$$1() {
            return this._cellTime;
        }
        /**
        * Sets the time length of a single cell in a timetable view, accurate to the nearest second.
        * @param {TimeSpan} value A TimeSpan object representing the time length of the cell.
        * @remarks Valid values for this property range from 1 second to 1 day.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._cellTime;
            this._cellTime = value;
            this.onPropertyChanged('cellTime', oldValue, value);
        }

        /**
        * Gets the start time of the timetable, expressed in minutes since the beginning of the day.
        * @returns {Number} The start time of the timetable in minutes.
        */

    }, {
        key: 'startTime',
        get: function get$$1() {
            return this._startTime;
        }
        /**
        * Sets the start time of the timetable, expressed in minutes since the beginning of the day.
        * @param {Number} value The start time of the timetable in minutes.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._startTime;
            this._startTime = value;
            this.onPropertyChanged('startTime', oldValue, value);
        }
        /**
        * Gets the end time of the timetable, expressed in minutes since the beginning of the day.
        * @returns {Number} The end time of the timetable in minutes.
        */

    }, {
        key: 'endTime',
        get: function get$$1() {
            return this._endTime;
        }
        /**
        * Sets the end time of the timetable, expressed in minutes since the beginning of the day.
        * @param {Number} value The end time of the timetable in minutes.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._endTime;
            this._endTime = value;
            this.onPropertyChanged('endTime', oldValue, value);
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'realEndTime',
        get: function get$$1() {

            var startTime = this.startTime;
            var endTime = this.endTime;

            if (endTime > startTime) return endTime;

            return endTime + 24 * 60;
        }

        /**
        * Gets the string used to format ungrouped time cells in the timeline header.
        * @returns {String} The format string.
        */

    }, {
        key: 'generalFormat',
        get: function get$$1() {
            return this._generalFormat;
        }

        /**
        * Sets the string used to format ungrouped time cells in the timeline header.
        * @param {String} value The format string.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._generalFormat;
            this._generalFormat = value;
            this.onPropertyChanged('generalFormat', oldValue, value);
        }

        /**
        * Gets a value indicating whether hours displayed in the timeline are grouped.
        * @returns {Boolean} True if hours are grouped, otherwise false.
        * @remarks Certain conditions prevent hours from grouping, such as when the hours are not divisible by the specified CellTime.
        */

    }, {
        key: 'groupHours',
        get: function get$$1() {
            return this._groupHours;
        }
        /**
        * Sets a value indicating whether hours displayed in the timeline are grouped.
        * @param {Boolean} value True if hours are grouped, otherwise false.
        * @remarks Certain conditions prevent hours from grouping, such as when the hours are not divisible by the specified CellTime.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._groupHours;
            this._groupHours = value;
            this.onPropertyChanged('groupHours', oldValue, value);
        }
        /**
        * Gets a value indicating whether to use a 12-hour format.
        * @returns {Boolean} True to use a 12-hour format, otherwise false.
        */

    }, {
        key: 'twelveHourFormat',
        get: function get$$1() {
            return this._twelveHourFormat;
        }
        /**
        * Sets a value indicating whether to use a 12-hour format.
        * @param {Boolean} value True to use a 12-hour format, otherwise false.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._twelveHourFormat;
            this._twelveHourFormat = value;
            this.onPropertyChanged('twelveHourFormat', oldValue, value);
        }
        /**
        * Gets a value indicating whether to display the minutes of each hour in the timeline header when it displays whole hour cells.
        * @returns {Boolean} True to display minutes, otherwise false.
        * @remarks Whole hour cells are displayed when the hours are divisible by the specified CellTime.
        */

    }, {
        key: 'showMinutes',
        get: function get$$1() {
            return this._showMinutes;
        }
        /**
        * Sets a value indicating whether to display the minutes of each hour in the timeline header when it displays whole hour cells.
        * @param {Boolean} value True to display minutes, otherwise false.
        * @remarks Whole hour cells are displayed when the hours are divisible by the specified CellTime.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._showMinutes;
            this._showMinutes = value;
            this.onPropertyChanged('showMinutes', oldValue, value);
        }
        /**
        * Gets a value indicating whether the AM and PM suffixes are displayed.
        * @returns {Boolean} True to display AM and PM, otherwise false.
        */

    }, {
        key: 'showAM',
        get: function get$$1() {
            return this._showAM;
        }
        /**
        * Sets a value indicating whether the AM and PM suffixes are displayed.
        * @param {Boolean} value True to display AM and PM, otherwise false.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._showAM;
            this._showAM = value;
            this.onPropertyChanged('showAM', oldValue, value);
        }

        /**
        * Gets the style of the view header.
        * @returns {MainHeaderStyle} One of the MainHeaderStyle enumeration values.
        */

    }, {
        key: 'headerStyle',
        get: function get$$1() {
            return this._headerStyle;
        }

        /**
        * Sets the style of the view header.
        * @param {MainHeaderStyle} value One of the MainHeaderStyle enumeration values.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._headerStyle;
            this._headerStyle = value;
            this.onPropertyChanged('headerStyle', oldValue, value);
        }

        /**
        * Gets the string used to format header titles.
        * @returns {String} The format string.
        */

    }, {
        key: 'titleFormat',
        get: function get$$1() {
            return this._titleFormat;
        }
        /**
        * Sets the string used to format header titles.
        * @param {String} value The format string.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._titleFormat;
            this._titleFormat = value;
            this.onPropertyChanged('titleFormat', oldValue, value);
        }
        /**
        * Gets the number of days to scroll when a navigation button is clicked.
        * @returns {Number} The number of days to scroll.
        */

    }, {
        key: 'scrollStep',
        get: function get$$1() {
            return this._scrollStep;
        }
        /**
        * Sets the number of days to scroll when a navigation button is clicked.
        * @param {Number} value The number of days to scroll.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._scrollStep;
            this._scrollStep = value;
            this.onPropertyChanged('scrollStep', oldValue, value);
        }

        /**
        * Gets the maximum number of calendar items to display in a view cell.
        * @returns {Number} The maximum number of calendar items to display in a view cell.
        * @remarks Applies only to all day (header) items.
        */

    }, {
        key: 'maxItems',
        get: function get$$1() {
            return this._maxItems;
        }

        /**
        * Sets the maximum number of calendar items to display in a view cell.
        * @param {Number} value The maximum number of calendar items to display in a view cell.
        * @remarks Applies only to all day (header) items.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._maxItems;
            this._maxItems = value;
            this.onPropertyChanged('maxItems', oldValue, value);
        }
    }]);
    return TimetableSettings;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* Defines properties that allow customization of the appearance of a List view.
* @property {Orientation} orientation Gets or sets the orientation of the view.
* @property {TimeUnit} cellUnits Gets or sets the resolution of the list view.
* @property {Number} numberOfCells Gets or sets the total number of cells to be displayed in the view.
* @property {Number} visibleCells Gets or sets the number of cells visible at the same time.
* @property {MainHeaderStyle} headerStyle Gets or sets the style of the view header.
* @property {String} titleFormat Gets or sets the string used to format the header title.
* @property {String} generalFormat Gets or sets the string used to format cells' headers.
* @property {String} firstDayOfMonthFormat Gets or sets the string used to format the cell header of the first day of each month.
* @property {String} firstDayOfYearFormat Gets or sets the string used to format the cell header of the first day of each year.
* @property {Number} maxItems Gets or sets the maximum number of items to display in a cell.
*/
var ListSettings = function () {
    function ListSettings(calendar) {
        classCallCheck(this, ListSettings);

        this.calendar = calendar;

        this._orientation = Orientation.Horizontal;

        this._cellUnits = TimeUnit.Day;
        this._numberOfCells = 14;
        this._visibleCells = 7;

        this._headerStyle = MainHeaderStyle.Title | MainHeaderStyle.Buttons;
        this._titleFormat = calendar.formatInfo.dateFormats.dayMonth;

        this._generalFormat = "d ";
        this._firstDayOfMonthFormat = "d MMM";
        this._firstDayOfYearFormat = "d ";

        this._propertyChanged = new EventDispatcher();
    }

    /**
    * Copies property values from another object.
    * @param {Object} settings An object containing property values.
    */


    createClass(ListSettings, [{
        key: 'copyFrom',
        value: function copyFrom(settings) {
            if (!settings) return;

            if (settings.orientation !== undefined) this.orientation = settings.orientation;

            if (settings.cellUnits !== undefined) this.cellUnits = settings.cellUnits;
            if (settings.numberOfCells !== undefined) this.numberOfCells = settings.numberOfCells;
            if (settings.visibleCells !== undefined) this.visibleCells = settings.visibleCells;

            if (settings.headerStyle !== undefined) this.headerStyle = settings.headerStyle;
            if (settings.titleFormat !== undefined) this.titleFormat = settings.titleFormat;

            if (settings.generalFormat !== undefined) this.generalFormat = settings.generalFormat;
            if (settings.firstDayOfMonthFormat !== undefined) this.firstDayOfMonthFormat = settings.firstDayOfMonthFormat;
            if (settings.firstDayOfYearFormat !== undefined) this.firstDayOfYearFormat = settings.firstDayOfYearFormat;
        }

        /**
        * Raises the propertyChanged event.
        * @package
        */

    }, {
        key: 'onPropertyChanged',
        value: function onPropertyChanged(name, oldValue, newValue) {
            this._propertyChanged.raiseEvent(this, new PropertyEventArgs(name, oldValue, newValue));
        }

        /**
        * Gets a value indicating whether view cells are displayed horizontally or vertically.
        * @returns {Orientation} One of the Orientation enumeration values.
        */

    }, {
        key: 'orientation',
        get: function get$$1() {
            return this._orientation;
        }

        /**
        * Gets a value indicating whether view cells are displayed horizontally or vertically.
        * @param {Orientation} value One of the Orientation enumeration values.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._orientation;
            this._orientation = value;
            this.onPropertyChanged('orientation', oldValue, value);
        }

        /**
        * Gets the resolution of the view.
        * @returns {TimeUnit} One of the TimeUnit enumeration values.
        */

    }, {
        key: 'cellUnits',
        get: function get$$1() {
            return this._cellUnits;
        }

        /**
        * Sets the resolution of the view.
        * @param {TimeUnit} value One of the TimeUnit enumeration values.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._cellUnits;
            this._cellUnits = value;
            this.onPropertyChanged('cellUnits', oldValue, value);
        }

        /**
        * Gets the total number of cells to be displayed in the view.
        * @returns {Number} The total number of cells to be displayed in the view.
        */

    }, {
        key: 'numberOfCells',
        get: function get$$1() {
            return this._numberOfCells;
        }

        /**
        * Sets the total number of cells to be displayed in the view.
        * @param {Number} value The total number of cells to be displayed in the view.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._numberOfCells;
            this._numberOfCells = value;
            this.onPropertyChanged('numberOfCells', oldValue, value);
        }

        /**
        * Gets the number of cells visible at the same time.
        * @returns {Number} The number of cells visible at the same time.
        */

    }, {
        key: 'visibleCells',
        get: function get$$1() {
            return this._visibleCells;
        }

        /**
        * Sets the number of cells visible at the same time.
        * @param {Number} value The number of cells visible at the same time.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._visibleCells;
            this._visibleCells = value;
            this.onPropertyChanged('visibleCells', oldValue, value);
        }

        /**
        * Gets the style of the view header.
        * @returns {MainHeaderStyle} One of the MainHeaderStyle enumeration values.
        */

    }, {
        key: 'headerStyle',
        get: function get$$1() {
            return this._headerStyle;
        }

        /**
        * Sets the style of the view header.
        * @param {MainHeaderStyle} value One of the MainHeaderStyle enumeration values.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._headerStyle;
            this._headerStyle = value;
            this.onPropertyChanged('headerStyle', oldValue, value);
        }

        /**
        * Gets the string used to format the header title.
        * @returns {String} The format string.
        */

    }, {
        key: 'titleFormat',
        get: function get$$1() {
            return this._titleFormat;
        }

        /**
        * Sets the string used to format the header title.
        * @param {String} value The format string.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._titleFormat;
            this._titleFormat = value;
            this.onPropertyChanged('titleFormat', oldValue, value);
        }

        /**
        * Gets the string used to format cells' headers.
        * @returns {String} The format string.
        */

    }, {
        key: 'generalFormat',
        get: function get$$1() {
            return this._generalFormat;
        }

        /**
        * Sets the string used to format cells' headers.
        * @param {String} value The format string.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._generalFormat;
            this._generalFormat = value;
            this.onPropertyChanged('generalFormat', oldValue, value);
        }

        /**
        * Gets the string used to format the cell header of the first day of each month.
        * @returns {String} The format string.
        */

    }, {
        key: 'firstDayOfMonthFormat',
        get: function get$$1() {
            return this._firstDayOfMonthFormat;
        }

        /**
        * Sets the string used to format the cell eader of the first day of each month.
        * @param {String} value The format string.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._firstDayOfMonthFormat;
            this._firstDayOfMonthFormat = value;
            this.onPropertyChanged('firstDayOfMonthFormat', oldValue, value);
        }

        /**
        * Gets the string used to format the cell header of the first day of each year.
        * @returns {String} The format string.
        */

    }, {
        key: 'firstDayOfYearFormat',
        get: function get$$1() {
            return this._firstDayOfYearFormat;
        }
        /**
        * Sets the string used to format the cell header of the first day of each year.
        * @param {String} value The format string.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._firstDayOfYearFormat;
            this._firstDayOfYearFormat = value;
            this.onPropertyChanged('firstDayOfYearFormat', oldValue, value);
        }

        /**
        * Gets the maximum number of calendar items to display in a view cell.
        * @returns {Number} The maximum number of calendar items to display in a view cell.
        */

    }, {
        key: 'maxItems',
        get: function get$$1() {
            return this._maxItems;
        }

        /**
        * Sets the maximum number of calendar items to display in a view cell.
        * @param {Number} value The maximum number of calendar items to display in a view cell.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._maxItems;
            this._maxItems = value;
            this.onPropertyChanged('maxItems', oldValue, value);
        }
    }]);
    return ListSettings;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* Defines properties that allow customization of the appearance of timelines in a Resource view.
* @property {TimeUnit} unit Gets the resolution of the timeline.
* @property {Number} unitCount Gets or sets the number of units between adjacent ticks in the timeline.
* @property {String} format Gets or sets the string used to format timeline headers.
*/
var TimelineSettings = function () {
    function TimelineSettings(calendar, timeline) {
        classCallCheck(this, TimelineSettings);

        this.calendar = calendar;
        this._timeline = timeline;

        this._unit = TimeUnit.Day;
        this._unitCount = 1;
        this._format = "d ";

        this._propertyChanged = new EventDispatcher();
    }

    /**
    * Copies property values from another object.
    * @param {Object} settings An object containing property values.
    */


    createClass(TimelineSettings, [{
        key: 'copyFrom',
        value: function copyFrom(settings) {
            if (!settings) return;

            if (settings.unit !== undefined) this.unit = settings.unit;
            if (settings.unitCount !== undefined) this.unitCount = settings.unitCount;
            if (settings.format !== undefined) this.format = settings.format;
        }

        /**
        * Raises the propertyChanged event.
        * @package
        */

    }, {
        key: 'onPropertyChanged',
        value: function onPropertyChanged(name, oldValue, newValue) {
            this._propertyChanged.raiseEvent(this, new PropertyEventArgs(name, oldValue, newValue));
        }

        /**
        * Gets the resolution of the timeline.
        * @returns {TimeUnit} One of the TimeUnit enumeration values.
        */

    }, {
        key: 'unit',
        get: function get$$1() {
            return this._unit;
        }
        /**
        * Sets the resolution of the timeline.
        * @param {TimeUnit} value One of the TimeUnit enumeration values.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._unit;
            this._unit = value;
            this.onPropertyChanged('unit', oldValue, value);
        }
        /**
        * Gets the number of units between adjacent ticks in the timeline.
        * @returns {Number} The number of units between adjacent ticks in the timeline.
        */

    }, {
        key: 'unitCount',
        get: function get$$1() {
            return this._unitCount;
        }
        /**
        * Sets the number of units between adjacent ticks in the timeline.
        * @param {Number} value The number of units between adjacent ticks in the timeline.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._unitCount;
            this._unitCount = value;
            this.onPropertyChanged('unitCount', oldValue, value);
        }
        /**
        * Gets the string used to format timeline headers.
        * @returns {String} The format string.
        */

    }, {
        key: 'format',
        get: function get$$1() {
            return this._format;
        }
        /**
        * Sets the string used to format timeline headers.
        * @param {String} value The format string.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._format;
            this._format = value;
            this.onPropertyChanged('format', oldValue, value);
        }
    }]);
    return TimelineSettings;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* Defines properties that allow customization of the appearance of a Resource view.
* @property {Number} timelines Gets or sets the number of timelines displayed in the view.
* @property {TimelineSettings} topTimelineSettings Gets the settings for the top timeline.
* @property {TimelineSettings} middleTimelineSettings Gets the settings for the middle timeline.
* @property {TimelineSettings} bottomTimelineSettings Gets the settings for the bottom timeline.
* @property {Number} visibleCells Gets or sets the number of cells visible at the same time.
*/
var ResourceViewSettings = function () {
	function ResourceViewSettings(calendar) {
		classCallCheck(this, ResourceViewSettings);

		this.calendar = calendar;

		this._timelines = 3;
		this.topTimelineSettings._unit = TimeUnit.Year;
		this.topTimelineSettings._format = "yyyy";
		this.middleTimelineSettings._unit = TimeUnit.Month;
		this.middleTimelineSettings._format = "MMMM";
		this.bottomTimelineSettings._unit = TimeUnit.Day;

		this._visibleCells = 14;

		this._propertyChanged = new EventDispatcher();
	}

	/**
 * Copies property values from another object.
 * @param {Object} settings An object containing property values.
 */


	createClass(ResourceViewSettings, [{
		key: 'copyFrom',
		value: function copyFrom(settings) {
			if (!settings) return;

			if (settings.timelines != undefined) this.timelines = settings.timelines;

			if (settings.topTimelineSettings !== undefined) this.topTimelineSettings.copyFrom(settings.topTimelineSettings);
			if (settings.middleTimelineSettings !== undefined) this.middleTimelineSettings.copyFrom(settings.middleTimelineSettings);
			if (settings.bottomTimelineSettings !== undefined) this.bottomTimelineSettings.copyFrom(settings.bottomTimelineSettings);

			if (settings.visibleCells !== undefined) this.visibleCells = settings.visibleCells;
		}

		/**
  * Raises the propertyChanged event.
  * @package
  */

	}, {
		key: 'onPropertyChanged',
		value: function onPropertyChanged(name, oldValue, newValue) {
			this._propertyChanged.raiseEvent(new PropertyEventArgs(name, oldValue, newValue));
		}

		/**
  * Gets the number of cells visible at the same time.
  * @returns {Number} The number of cells visible at the same time.
  */

	}, {
		key: 'visibleCells',
		get: function get$$1() {
			return this._visibleCells;
		}

		/**
     * Sets the number of cells visible at the same time.
     * @param {Number} value The number of cells visible at the same time.
     */
		,
		set: function set$$1(value) {
			var oldValue = this._visibleCells;
			this._visibleCells = value;
			this.onPropertyChanged('visibleCells', oldValue, value);
		}

		/**
  * Gets the number of timelines displayed in the view.
  * @returns {Number} The number of timelines displayed in the view.
  */

	}, {
		key: 'timelines',
		get: function get$$1() {
			return this._timelines;
		}
		/**
     * Sets the number of timelines displayed in the view.
     * @param {Number} value The number of timelines displayed in the view.
  * @remarks The number of timelines can be between 0 and 3.
     */
		,
		set: function set$$1(value) {
			var oldValue = this._timelines;
			this._timelines = value;
			this.onPropertyChanged('timelines', oldValue, value);
		}

		/**
  * Gets the settings for the top timeline.
  * @returns {TimelineSettings} The settings for the top timeline.
  */

	}, {
		key: 'topTimelineSettings',
		get: function get$$1() {
			var _this = this;

			if (!this._topTimelineSettings) {
				this._topTimelineSettings = new TimelineSettings(this);
				this._topTimelineSettings._propertyChanged.addEventListener(function (sender, args) {
					_this.calendar.onViewSettingsChanged(sender, args);
				});
			}
			return this._topTimelineSettings;
		}

		/**
  * Gets the settings for the middle timeline.
  * @returns {TimelineSettings} The settings for the middle timeline.
  */

	}, {
		key: 'middleTimelineSettings',
		get: function get$$1() {
			var _this2 = this;

			if (!this._middleTimelineSettings) {
				this._middleTimelineSettings = new TimelineSettings(this);
				this._middleTimelineSettings._propertyChanged.addEventListener(function (sender, args) {
					_this2.calendar.onViewSettingsChanged(sender, args);
				});
			}
			return this._middleTimelineSettings;
		}

		/**
  * Gets the settings for the bottom timeline.
  * @returns {TimelineSettings} The settings for the bottom timeline.
  */

	}, {
		key: 'bottomTimelineSettings',
		get: function get$$1() {
			var _this3 = this;

			if (!this._bottomTimelineSettings) {
				this._bottomTimelineSettings = new TimelineSettings(this);
				this._bottomTimelineSettings._propertyChanged.addEventListener(function (sender, args) {
					_this3.calendar.onViewSettingsChanged(sender, args);
				});
			}
			return this._bottomTimelineSettings;
		}
	}]);
	return ResourceViewSettings;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/** 
* @class Defines properties that enable appearance customization of schedule items in the calendar views.
* @property {String} cssClass Gets or sets the default CSS class for all appointments whose CSS is not explicitly specified.
* @property {Number} size Gets or sets the size of schedule items drawn in the calendar.
* @property {Number} spacing Gets or sets the amount of space between adjacent items.
* @property {Boolean} showItems Gets or sets a value indicating whether to display schedule items.
* @property {Boolean} showContinuationArrows Gets or sets a value indicating whether to display small arrows at the beginning or at the end of each incomplete segment to
* indicate that the schedule item continues in an adjacent calendar cell.
* @property {Boolean} showCues Gets or sets a value indicating whether to display a 'more items' link in a calendar cell which isn't big enough to contain all of its items.
* @property {String} tooltipFormat Gets or sets a value indicating how to format and display item tooltips.
* @property {String} titleFormat Gets or sets a value indicating how to format and display item titles.
*/
var ItemSettings = function () {
    function ItemSettings(calendar) {
        classCallCheck(this, ItemSettings);

        this.calendar = calendar;

        this._cssClass = "";
        this._size = 17;
        this._spacing = 2;
        this._showItems = true;
        this._showContinuationArrows = true;
        this._showCues = true;

        this._titleFormat = "%h";
        this._tooltipFormat = "%s[d MMM] %s[hh:mm] - %e[d MMM] %e[hh:mm] %h %d";

        this._propertyChanged = new EventDispatcher();
    }

    /**
    * Copies property values from another object.
    * @param {Object} settings An object containing property values.
    */


    createClass(ItemSettings, [{
        key: 'copyFrom',
        value: function copyFrom(settings) {
            if (!settings) return;

            if (settings.cssClass !== undefined) this.cssClass = settings.cssClass;

            if (settings.size !== undefined) this.size = settings.size;
            if (settings.spacing !== undefined) this.spacing = settings.spacing;

            if (settings.showItems !== undefined) this.showItems = settings.showItems;
            if (settings.showContinuationArrows !== undefined) this.showContinuationArrows = settings.showContinuationArrows;
            if (settings.showCues !== undefined) this.showCues = settings.showCues;

            if (settings.tooltipFormat !== undefined) this.tooltipFormat = settings.tooltipFormat;
            if (settings.titleFormat !== undefined) this.titleFormat = settings.titleFormat;
        }

        /**
         * Raises the propertyChanged event.
         * @package
         */

    }, {
        key: 'onPropertyChanged',
        value: function onPropertyChanged(name, oldValue, newValue) {
            this._propertyChanged.raiseEvent(new PropertyEventArgs(name, oldValue, newValue));
        }

        /**
         * Gets the default CSS class for all appointments whose CSS is not explicitly specified.
         * @returns {String} The CSS class.
        */

    }, {
        key: 'cssClass',
        get: function get$$1() {
            return this._cssClass;
        }
        /**
            * Sets the default CSS class for all appointments whose CSS is not explicitly specified.
         * @param {String} value The CSS class.
         */
        ,
        set: function set$$1(value) {
            var oldValue = this._cssClass;
            this._cssClass = value;
            this.onPropertyChanged('cssClass', oldValue, value);
        }

        /**
         * Gets the size of schedule items drawn in the calendar.
         * @returns {Number} The size in pixels.
         * @remarks The size of an item is its height when the items are positioned horizontally or its width when positioned vertically.
        */

    }, {
        key: 'size',
        get: function get$$1() {
            return this._size;
        }
        /**
         * Sets the size of schedule items drawn in the calendar.
         * @param {Number} value The size in pixels.
         * @remarks The size of an item is its height when the items are positioned horizontally or its width when positioned vertically.
        */
        ,
        set: function set$$1(value) {
            var oldValue = this._size;
            this._size = value;
            this.onPropertyChanged('size', oldValue, value);
        }

        /**
         * Gets the amount of space between adjacent items.
         * @returns {Number} The amount of space between adjacent items in pixels.
        */

    }, {
        key: 'spacing',
        get: function get$$1() {
            return this._spacing;
        }
        /**
            * Sets the amount of space between adjacent items.
         * @param {Number} value The amount of space between adjacent items in pixels.
         */
        ,
        set: function set$$1(value) {
            var oldValue = this._spacing;
            this._spacing = value;
            this.onPropertyChanged('spacing', oldValue, value);
        }

        /**
         *Gets a value indicating whether to display schedule items in the calendar.
         * @returns {Boolean} True if items should be displayed, otherwise false.
        */

    }, {
        key: 'showItems',
        get: function get$$1() {
            return this._showItems;
        }
        /**
            * Sets a value indicating whether to display schedule items in the calendar.
         * @param {Boolean} value True if items should be displayed, otherwise false.
         */
        ,
        set: function set$$1(value) {
            var oldValue = this._showItems;
            this._showItems = value;
            this.onPropertyChanged('showItems', oldValue, value);
        }

        /**
        * Gets a value indicating whether to display small arrows 
        	* at the beginning or at the end of each incomplete segment to 
        	* indicate that the schedule item continues in an adjacent calendar 
        	* cell.
        * @returns {Boolean} True if arrows should be displayed, otherwise false.
        */

    }, {
        key: 'showContinuationArrows',
        get: function get$$1() {
            return this._showContinuationArrows;
        }
        /**
           * Sets a value indicating whether to display small arrows 
           	* at the beginning or at the end of each incomplete segment to 
           	* indicate that the schedule item continues in an adjacent calendar 
           	* cell.
         * @param {Boolean} value True if arrows should be displayed, otherwise false.
         */
        ,
        set: function set$$1(value) {
            var oldValue = this._showContinuationArrows;
            this._showContinuationArrows = value;
            this.onPropertyChanged('showContinuationArrows', oldValue, value);
        }

        /**
        * Gets a value indicating whether to display a 'more items' 
        * link in a calendar cell which isn't big enough to contain all of 
        * its items.
        * @returns {Boolean} True if cues should be displayed, otherwise false.
        */

    }, {
        key: 'showCues',
        get: function get$$1() {
            return this._showCues;
        }
        /**
           * Sets a value indicating whether to display a 'more items' 
           * link in a calendar cell which isn't big enough to contain all of 
           * its items.
         * @param {Boolean} value True if cues should be displayed, otherwise false.
         */
        ,
        set: function set$$1(value) {
            var oldValue = this._showCues;
            this._showCues = value;
            this.onPropertyChanged('showCues', oldValue, value);
        }

        /**
        * Gets a value indicating how to format and display item tooltips.
        * @returns {String} The format string.
        */

    }, {
        key: 'tooltipFormat',
        get: function get$$1() {
            return this._tooltipFormat;
        }

        /**
        * Sets a value indicating how to format and display item tooltips.
        * @param {String} value The format string.
        */
        ,
        set: function set$$1(value) {
            this._tooltipFormat = value;
        }

        /**
        * Gets a value indicating how to format and display item titles.
        * @returns {String} The format string.
        */

    }, {
        key: 'titleFormat',
        get: function get$$1() {
            return this._titleFormat;
        }

        /**
        * Sets a value indicating how to format and display item titles.
        * @param {String} value The format string.
        */
        ,
        set: function set$$1(value) {
            this._titleFormat = value;
        }
    }]);
    return ItemSettings;
}();

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
 * Provides methods that read/write primitive data types from/into an XML document.
 */

var XmlPersistContext = function () {
  function XmlPersistContext(schedule, document) {
    classCallCheck(this, XmlPersistContext);

    this._schedule = schedule;
    this._document = document;
  }

  createClass(XmlPersistContext, [{
    key: 'saveResource',
    value: function saveResource(resource, collectionElement, elementName) {
      var element = this.document.createElement(elementName);
      collectionElement.appendChild(element);

      var classDesc = resource.constructor.xmlInfo;
      if (classDesc != null) {
        element.setAttribute("class", classDesc.classId);
        element.setAttribute("version", classDesc.classVersion.toString());
        resource.saveToXml(element, this);
      } else {
        throw new Error("Resource cannot be serialized because it does not implement getXmlInfo().");
      }
    }
  }, {
    key: 'loadResource',
    value: function loadResource(element) {
      var classId = element.getAttribute("class");

      // Instantiate the resource
      var resource = this.instantiateResource(classId);

      // Load the resource
      resource.loadFromXml(element, this);

      return resource;
    }
  }, {
    key: 'instantiateResource',
    value: function instantiateResource(classId) {
      var type = Schedule.xmlClassMap[classId];
      if (!type) throw new Error("Resource classId [" + classId + "] is not registered.");

      var resource = new type();
      return resource;
    }
  }, {
    key: 'saveItem',
    value: function saveItem(item, collectionElement, elementName) {
      var newElement = false;
      var element;

      if (elementName) {
        newElement = true;
        element = this.document.createElement(elementName);
        collectionElement.appendChild(element);
      } else {
        element = collectionElement;
      }

      var classDesc = item.constructor.xmlInfo;
      if (classDesc != null) {
        if (newElement) {
          element.setAttribute("class", classDesc.classId);
          element.setAttribute("version", classDesc.classVersion);
        } else {
          this.writeString(classDesc.classId, "class", element);
          this.writeInt(classDesc.classVersion, "version", element);
        }

        item.saveToXml(element, this);
      } else {
        throw new Error("Item cannot be serialized because it does not implement getXmlInfo().");
      }
    }
  }, {
    key: 'loadItem',
    value: function loadItem(element) {
      var classId = "";
      if (element.hasAttribute("class")) classId = element.getAttribute("class");else if (element.hasAttribute("classId")) classId = element.getAttribute("classId");

      if (classId === "") classId = this.readString("class", element);
      if (classId === "") classId = this.readString("classId", element);

      // Instantiate the item
      var item = this.instantiateResource(classId);

      // Load the resource
      item.loadFromXml(element, this);

      return item;
    }
  }, {
    key: 'instantiateItem',
    value: function instantiateItem(classId) {
      var type = Schedule.xmlClassMap[classId];
      if (!type) throw new Error("Item classId [" + classId + "] is not registered.");

      var item = new type();
      return item;
    }
  }, {
    key: 'selectSingleNode',
    value: function selectSingleNode(name, parentElement) {
      var children = parentElement.getElementsByTagName(name);
      if (children.length < 1) return null;
      if (children[0].parentNode != parentElement) return null;
      return children[0];
    }
  }, {
    key: 'innerText',
    value: function innerText(element) {
      if (element.childNodes.length == 0) return "";
      return element.childNodes[0].nodeValue;
    }
  }, {
    key: 'isEmpty',
    value: function isEmpty(element) {
      return element.childNodes.length == 0;
    }
  }, {
    key: 'hasValue',
    value: function hasValue(value) {
      return typeof value != "undefined" && value !== null;
    }
  }, {
    key: 'isFloat',
    value: function isFloat(number) {
      return !/^-?\d+$/.test(String(number));
    }

    /**
    * Adds a new child node with the specified name and value to the specified parent node.
    * @param {String} elementName A string containing the name of new child element.
    * @param {Element} parentElement The parent DOM Element object.
    * @param {String} [innerText] Optional value to be added as child text node of the new element.
    * @returns {Element} The newly created DOM Element object.
    */

  }, {
    key: 'addChildElement',
    value: function addChildElement(elementName, parentElement, innerText) {
      var element = this.document.createElement(elementName);
      parentElement.appendChild(element);
      if (this.hasValue(innerText)) {
        element.appendChild(this.document.createTextNode(innerText));
      }
      return element;
    }

    /**
    * Writes a string value with the specified name.
    * @param {String} stringValue The string that should be saved in current XML document.
    * @param {String} elementName A string specifying the name of the new element.
    * @param {Element} parentElement The parent DOM Element object.
    * @returns {Element} The newly created DOM Element object.
    */

  }, {
    key: 'writeString',
    value: function writeString(stringValue, elementName, parentElement) {
      return this.addChildElement(elementName, parentElement, stringValue);
    }

    /**
        * Reads a string value with the specified name.
        * @param {String} elementName The name of the string's XML element.
        * @param {Element} parentElement The parent DOM Element object.
        * @param {Object} [defaultValue] The default string to return if specified child XML element does not exist.
        * @returns {String} The string loaded from XML.
        */

  }, {
    key: 'readString',
    value: function readString(elementName, parentElement, defaultValue) {
      if (defaultValue === undefined) defaultValue = "";

      var element = this.selectSingleNode(elementName, parentElement);
      if (!element) return defaultValue;

      return this.innerText(element);
    }

    /**
    * Writes a floating-point number with the specified name.
    * @param {Number} floatValue The number that should be saved in current XML document.
    * @param {String} elementName A string specifying the name of the new element.
    * @param {Element} parentElement The parent DOM Element object.
    * @returns {Element} The newly created DOM Element object.
    */

  }, {
    key: 'writeFloat',
    value: function writeFloat(floatValue, elementName, parentElement) {
      return this.addChildElement(elementName, parentElement, floatValue.toString());
    }

    /**
    * Reads a floating-point number with the specified name.
    * @param {String} elementName A string specifying the name of the number XML element.
    * @param {Element} parentElement The parent DOM Element object.
    * @param {Number} [defaultValue] The default number to return if specified child XML element does not exist.
    * @returns {Number} The number loaded from XML.
    */

  }, {
    key: 'readFloat',
    value: function readFloat(elementName, parentElement, defaultValue) {
      if (defaultValue === undefined) defaultValue = 0;

      var element = this.selectSingleNode(elementName, parentElement);
      if (!element) return defaultValue;

      return parseFloat(this.innerText(element));
    }

    /**
    * Writes a Boolean value with the specified name.
    * @param {Boolean} boolValue The Boolean value that should be saved in current XML document.
    * @param {String} elementName A string specifying the name of the new element.
    * @param {Element} parentElement The parent DOM Element object.
    * @returns {Element} The newly created DOM Element object.
    */

  }, {
    key: 'writeBool',
    value: function writeBool(boolValue, elementName, parentElement) {
      if (typeof boolValue === "undefined" || boolValue === null) boolValue = false;

      return this.addChildElement(elementName, parentElement, boolValue.toString());
    }

    /**
    * Reads a Boolean value with the specified name.
    * @param {String} elementName A string specifying the name of the Boolean XML element.
    * @param {Element} parentElement The parent DOM Element object.
    * @param {Boolean} [defaultValue] The default value to return if specified child XML element does not exist.
    * @returns {Boolean} The value loaded from XML.
    */

  }, {
    key: 'readBool',
    value: function readBool(elementName, parentElement, defaultValue) {
      if (defaultValue === undefined) defaultValue = false;

      var element = this.selectSingleNode(elementName, parentElement);
      if (!element) return defaultValue;

      return this.innerText(element).toLowerCase() == "true";
    }

    /**
    * Writes an integer number with the specified name.
    * @param {Number} intValue The number that should be saved in current XML document.
    * @param {String} elementName A string specifying the name of the new element.
    * @param {Element} parentElement The parent DOM Element object.
    * @returns {Element} The newly created DOM Element object.
    */

  }, {
    key: 'writeInt',
    value: function writeInt(intValue, elementName, parentElement) {
      var innerText = intValue.toString();
      if (innerText.indexOf('.') != -1) innerText = Math.round(intValue).toString();

      return this.addChildElement(elementName, parentElement, innerText);
    }

    /**
    * Reads an integer number with the specified name.
    * @param {String} elementName A string specifying the name of the number XML element.
    * @param {Element} parentElement The parent DOM Element object.
    * @param {Number} [defaultValue] The default number to return if specified child XML element does not exist.
    * @returns {Number} The number loaded from XML.
    */

  }, {
    key: 'readInt',
    value: function readInt(elementName, parentElement, defaultValue) {
      if (defaultValue === undefined) defaultValue = 0;

      var element = this.selectSingleNode(elementName, parentElement);
      if (!element) return defaultValue;

      return parseInt(this.innerText(element));
    }

    /**
    * Writes a DateTime value with the specified name.
    * @param {DateTime} dateTimeValue The DateTime value that should be saved in current XML document.
    * @param {String} elementName A string specifying the name of the new element.
    * @param {Element} parentElement The parent DOM Element object.
    * @returns {Element} The newly created DOM Element object.
    */

  }, {
    key: 'writeDateTime',
    value: function writeDateTime(dateTimeValue, elementName, parentElement) {
      var element = this.addChildElement(elementName, parentElement);

      this.writeInt(dateTimeValue.year, "year", element);
      this.writeInt(dateTimeValue.month + 1, "month", element);
      this.writeInt(dateTimeValue.day, "day", element);
      this.writeInt(dateTimeValue.hour, "hour", element);
      this.writeInt(dateTimeValue.minute, "minute", element);
      this.writeInt(dateTimeValue.second, "second", element);
      this.writeInt(dateTimeValue.millisecond, "millisecond", element);

      return element;
    }

    /**
    * Reads a DateTime value with the specified name.
    * @param {String} elementName A string specifying the name of the DateTime XML element.
    * @param {Element} parentElement The parent DOM Element object.
    * @param {Boolean} [defaultValue] The default value to return if specified child XML element does not exist.
    * @returns {Boolean} The value loaded from XML.
    */

  }, {
    key: 'readDateTime',
    value: function readDateTime(elementName, parentElement, defaultValue) {
      if (defaultValue === undefined) defaultValue = DateTime.minValue();

      var element = this.selectSingleNode(elementName, parentElement);
      if (!element) return defaultValue;

      return DateTime.fromDateParts(this.readInt("year", element), this.readInt("month", element) - 1, this.readInt("day", element), this.readInt("hour", element), this.readInt("minute", element), this.readInt("second", element), this.readInt("millisecond", element));
    }
  }, {
    key: 'writeTag',
    value: function writeTag(item, tagValue, elementName, parentElement) {
      if (tagValue == null) return null;

      var element = this.addChildElement(elementName, parentElement);

      // // If the tag is not custom-serialized or the undelying
      // // diagram is null, save it as an arbitrary object
      // var serialized = false;
      // if (this.diagram)
      //   serialized = this.diagram.raiseSerializeTag(
      //     {
      //       item: item,
      //       tag: tagValue,
      //       propertyName: elementName,
      //       element: element,
      //       context: this
      //     });

      // if (!serialized) {
      //   parentElement.removeChild(element);
      this.writeObject(tagValue, elementName, parentElement, false);
      // }

      return element;
    }
  }, {
    key: 'readTag',
    value: function readTag(item, elementName, parentElement) {
      var element = this.selectSingleNode(elementName, parentElement);
      if (!element) return null;
      if (this.isEmpty(element)) return null;
      // var params = {
      //   item: item,
      //   tag: null,
      //   propertyName: elementName,
      //   element: element,
      //   context: this
      // };
      // var serialized = this.diagram.raiseDeserializeTag(params);

      // if (!serialized)
      return this.readObject(elementName, parentElement);

      // return params.tag;
    }
  }, {
    key: 'writeObject',
    value: function writeObject(object, elementName, parentElement, raiseIfNotSerializable) {
      if (object == null) return null;

      var typeId = 0,
          element = null;

      if (typeof object === "string") {
        if (object.length === 1) typeId = 4; // char
        else typeId = 1; // string

        this.writeString(object, elementName, parentElement);
      } else if (typeof object === "boolean") {
        typeId = 2; // bool
        this.writeBool(object, elementName, parentElement);
      } else if (typeof object === "number") {
        if (this.isFloat(object)) {
          typeId = 6; // double
          this.writeFloat(object, elementName, parentElement);
        } else {
          typeId = 9; // int64
          this.writeInt(object, elementName, parentElement);
        }
      }

      if (element != null) element.setAttribute("type", typeId);

      return element;
    }
  }, {
    key: 'readObject',
    value: function readObject(elementName, parentElement) {
      var element = this.selectSingleNode(elementName, parentElement);
      if (!element) return null;

      var typeId = parseInt(element.getAttribute("Type"));

      if (typeId == 1) return this.readString(elementName, parentElement);

      if (typeId == 2) return this.readBool(elementName, parentElement);

      if (typeId == 3) return this.readInt(elementName, parentElement); // byte

      if (typeId == 4) return this.readString(elementName, parentElement); // char

      if (typeId == 5) return this.readInt(elementName, parentElement); // decimal

      if (typeId == 6) return this.readFloat(elementName, parentElement); // double

      if (typeId == 7) return this.readInt(elementName, parentElement); // short

      if (typeId == 8) return this.readInt(elementName, parentElement);

      if (typeId == 9) return this.readInt(elementName, parentElement);

      if (typeId == 10) return this.readInt(elementName, parentElement);

      if (typeId == 11) return this.readFloat(elementName, parentElement);

      if (typeId == 12) return this.readInt(elementName, parentElement);

      if (typeId == 13) return this.readInt(elementName, parentElement);

      if (typeId == 14) return this.readInt(elementName, parentElement);

      return null;
    }

    /**
    * Writes the specified Reminder object as an XML element with the specified name and the specified parent.
    * @param {Reminder} The Reminder object to write.
    * @param {String} elementName A string specifying the name of the Reminder XML element.
    * @param {Element} parentElement The parent DOM Element object.
    */

  }, {
    key: 'writeReminder',
    value: function writeReminder(reminder, elementName, parentElement) {
      if (!reminder) return null;

      var element = this.addChildElement(elementName, parentElement);
      reminder.saveToXml(element, this);
    }

    /**
    * Reads a Reminder object with the specified name.
    * @param {String} elementName A string specifying the name of the Reminder XML element.
    * @param {Element} parentElement The parent DOM Element object.
    * @returns {Reminder} The Reminder object read; null if reading has failed.
    */

  }, {
    key: 'readReminder',
    value: function readReminder(elementName, parentElement) {

      var element = this.selectSingleNode(elementName, parentElement);
      if (!element) return null;
      if (this.isEmpty(element)) return null;

      var reminder = new Reminder();
      reminder.loadFromXml(element, this);

      return reminder;
    }

    /**
    * Writes the specified Recurrence object as an XML element with the specified name and the specified parent.
    * @param {Recurrence} The Recurrence object to write.
    * @param {String} elementName A string specifying the name of the Recurrence XML element.
    * @param {Element} parentElement The parent DOM Element object.
    */

  }, {
    key: 'writeRecurrence',
    value: function writeRecurrence(recurrence, elementName, parentElement) {
      if (!recurrence) return null;

      var element = this.addChildElement(elementName, parentElement);
      recurrence.saveToXml(element, this);
    }

    /**
    * Reads a Recurrence object with the specified name.
    * @param {String} elementName A string specifying the name of the Recurrence XML element.
    * @param {Element} parentElement The parent DOM Element object.
    * @returns {Recurrence} The Recurrence object read; null if reading has failed.
    */

  }, {
    key: 'readRecurrence',
    value: function readRecurrence(elementName, parentElement) {
      var element = this.selectSingleNode(elementName, parentElement);
      if (!element) return null;
      if (this.isEmpty(element)) return null;

      var recurrence = new Recurrence();
      recurrence.loadFromXml(element, this);

      return recurrence;
    }
  }, {
    key: 'schedule',
    get: function get$$1() {
      return this._schedule;
    }
  }, {
    key: 'document',
    get: function get$$1() {
      return this._document;
    }
  }]);
  return XmlPersistContext;
}();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* @class Represents a timetable of scheduled events. In the model-view architecture,
* Schedule instances are the documents whose data is displayed by Calendar
* instances, which are the views.
* @property {ObservableCollection} items Gets the collection of items in this schedule.
* @property {ObservableCollection} tasks Gets the collection of tasks in this schedule.
* @property {ObservableCollection} contacts Gets the collection of contacts in this schedule.
* @property {ObservableCollection} locations Gets the collection of locations in this schedule.
* @property {ObservableCollection} resources Gets the collection of resources in this schedule.
*/
var Schedule = function () {

    /**
       * Initializes a new instance of the Schedule class.
       * @constructor
    */
    function Schedule() {
        var _this = this;

        classCallCheck(this, Schedule);


        this.registerXmlTypes();

        this._items = new ObservableCollection();
        this._items.collectionChanged.addEventListener(function () {
            _this.onItemsChanged();
        });

        this._tasks = new ObservableCollection();
        this._tasks.collectionChanged.addEventListener(function () {
            _this.onTasksChanged();
        });

        this._contacts = new ObservableCollection();
        this._contacts.collectionChanged.addEventListener(function () {
            _this.onContactsChanged();
        });

        this._resources = new ObservableCollection();
        this._resources.collectionChanged.addEventListener(function () {
            _this.onResourcesChanged();
        });

        this._locations = new ObservableCollection();
        this._locations.collectionChanged.addEventListener(function () {
            _this.onLocationsChanged();
        });

        this._changed = new EventDispatcher();
        this._itemChanged = new EventDispatcher();

        this.itemChangedHandler = function (item, args) {
            _this.onItemChanged(item, args);
        };
    }

    /**
    * Copies property values from another object.
    * @param {Object} settings An object containing property values.
    */


    createClass(Schedule, [{
        key: 'copyFrom',
        value: function copyFrom(settings) {
            if (!settings) return;

            this._contacts.clear();
            if (settings.contacts !== undefined) settings.contacts.copyTo(this._contacts);
            this._locations.clear();
            if (settings.locations !== undefined) settings.locations.copyTo(this._locations);
            this._tasks.clear();
            if (settings.tasks !== undefined) settings.tasks.copyTo(this._tasks);
            this._resources.clear();
            if (settings.resources !== undefined) settings.resources.copyTo(this._resources);
            this._items.clear();
            if (settings.items !== undefined) settings.items.copyTo(this._items);
        }

        /**
        * Retrieves all events, including recurrent item instances, scheduled to occur in the specified time interval.
           * @param {DateTime} startTime Time interval start.
           * @param {DateTime} [endTime] Time interval end.
           * @param {Resource} [resource] A resource that must be related to the event.
        * @returns {List} The list of events scheduled to occur in the specified period.
        */

    }, {
        key: 'getAllItems',
        value: function getAllItems(startTime, endTime, resource) {

            var timeRange = new TimeRange(startTime, endTime || startTime);

            var items = [];

            var source = this.items.items();

            for (var i = 0, l = source.length; i < l; i++) {
                var item = source[i];

                // recurrence items
                if (item.recurrenceState === RecurrenceState.Master) {

                    var startTimeTicks = startTime.valueOf() - (item.endTime.valueOf() - item.startTime.valueOf());
                    if (startTimeTicks < 0) startTimeTicks = 0;

                    var occurrences = item.recurrence.generateItems(new DateTime(new Date(startTimeTicks)), endTime);

                    for (var j = 0, m = occurrences.length; j < m; j++) {
                        if (this.itemInTimeRange(occurrences[j], timeRange)) items.push(occurrences[j]);
                    }
                } else {
                    // regular items
                    if (item.recurrenceState === RecurrenceState.None) {

                        if (this.itemInTimeRange(item, timeRange)) items.push(item);
                    }
                }
            }

            if (resource) items = items.filter(function (item) {
                return item.hasResource(resource);
            });

            return new List(items);
        }
    }, {
        key: 'itemInTimeRange',
        value: function itemInTimeRange(item, range) {

            var itemRange = new TimeRange(item.startTime, item.endTime);

            if (range.contains(itemRange) || range.intersects(itemRange) || range.sameStart(itemRange)) return true;

            return false;
        }

        /**
        * Gets the item with the specified id.
           * @param {String} id The id of the  item.
           * @param {Number} [occurrenceIndex] The occurrence index of the item.
        * @returns {Item} The item; null if no item with the specified id has been found.
        */

    }, {
        key: 'getItemById',
        value: function getItemById(id, occurrenceIndex) {
            if (occurrenceIndex === undefined) occurrenceIndex = -1;

            for (var i = 0, l = this.items.count(); i < l; i++) {
                if (this.items.items()[i].id === id && this.items.items()[i].occurrenceIndex === occurrenceIndex) return this.items.items()[i];
            }
            return null;
        }

        /**
        * In a recurrence, gets the recurrence master item with the specified id.
        * @param {String} id The id of the master item.
        * @returns {Item} The item; null if no master item with the specified id has been found.
        */

    }, {
        key: 'getMasterById',
        value: function getMasterById(id) {
            for (var i = 0, l = this.items.count(); i < l; i++) {
                if (this.items.items()[i].id === id && this.items.items()[i].recurrenceState === RecurrenceState.Master) {
                    return this.items.items()[i];
                }
            }
            return null;
        }

        /**
        * Returns a resource from a schedule resource collection by a specified id.
        * @param {String} id The id of the resource.
        * @returns {Resource} The resource object if found, null otherwise.
        * @remarks The schedule resource collection (contacts, locations, tasks, resources) is determined automatically by the resource's id.
        */

    }, {
        key: 'getResourceById',
        value: function getResourceById(id) {

            var getResource = function getResource(collection, id) {
                for (var i = 0, l = collection.count(); i < l; i++) {
                    if (collection.items()[i].id === id) {
                        return collection.items()[i];
                    }
                }
                return null;
            };

            var resource = null;
            if (typeof id === "undefined" || id === null) {
                return resource;
            }

            // resource is a contact
            if (id.substr(0, 3) === 'CNT') {
                return getResource(this.contacts, id);
            }
            // resource is a location
            if (id.substr(0, 3) === 'LOC') {
                return getResource(this.locations, id);
            }
            // resource is a task
            if (id.substr(0, 3) === 'TSK') {
                return getResource(this.tasks, id);
            }
            // resource is a resource
            if (id.substr(0, 3) === 'RSC') {
                return getResource(this.resources, id);
            }
            return resource;
        }

        /**
        * Gets the items in the specified time interval.
           * @param {DateTime} startTime Time interval start.
           * @param {DateTime} [endTime] Time interval end.
        * @returns {List} The list of items in the specified time interval.
        */

    }, {
        key: 'getItemsByTime',
        value: function getItemsByTime(startTime, endTime) {
            var _this2 = this;

            var timeRange = new TimeRange(startTime, endTime || startTime);

            var items = this.items.items();

            items = items.filter(function (item) {
                return _this2.itemInTimeRange(item, timeRange);
            });

            return new List(items);
        }

        /**
        * Gets the items, related to the specified resource.
           * @param {Resource} resource The resource.
        * @returns {List} The list of items, related to the specified resource.
        */

    }, {
        key: 'getItemsByResource',
        value: function getItemsByResource(resource) {

            var items = this.items.items();

            if (resource) items = items.filter(function (item) {
                return item.hasResource(resource);
            });

            return new List(items);
        }

        /*
        * Gets the collection of items in this schedule.
        */

    }, {
        key: 'onItemsChanged',
        value: function onItemsChanged() {
            for (var i = 0, l = this._items.count(); i < l; i++) {
                this._items.items()[i].propertyChanged.removeEventListener(this.itemChangedHandler);
                this._items.items()[i].propertyChanged.addEventListener(this.itemChangedHandler);
            }
            this.onChanged();
        }
    }, {
        key: 'onItemChanged',
        value: function onItemChanged(sender, args) {
            this._itemChanged.raiseEvent(sender, args);
        }

        /**
         * Raised when an item is changed.
         */

    }, {
        key: 'onTasksChanged',
        value: function onTasksChanged(args) {
            this.onChanged();
        }
        /*
        * Gets the collection of contacts in this schedule.
        */

    }, {
        key: 'onContactsChanged',
        value: function onContactsChanged(args) {
            this.onChanged();
        }
        /*
        * Gets the collection of resources in this schedule.
        */

    }, {
        key: 'onResourcesChanged',
        value: function onResourcesChanged(args) {
            this.onChanged();
        }
        /*
        * Gets the collection of locations in this schedule.
        */

    }, {
        key: 'onLocationsChanged',
        value: function onLocationsChanged(args) {
            this.onChanged();
        }
    }, {
        key: 'onChanged',
        value: function onChanged() {
            this._changed.raiseEvent(this, EventArgs.Empty);
        }
    }, {
        key: 'registerXmlTypes',


        /* Serialization */
        value: function registerXmlTypes() {
            Schedule.registerItemClass(Item, "std:appointment", 1);
            Schedule.registerItemClass(Resource, "std:resource", 1);
            Schedule.registerItemClass(Contact, "std:contact", 1);
            Schedule.registerItemClass(Location, "std:location", 1);
            Schedule.registerItemClass(Task, "std:task", 1);
        }

        /**
        * Saves the schedule to an XML file.
        * @param {String} url A URL specifying where the schedule's XML should be posted to.
        */

    }, {
        key: 'saveToXml',
        value: function saveToXml(url) {
            var xhr = new XMLHttpRequest();
            xhr.open("POST", url, true);
            xhr.setRequestHeader('Content-Type', 'text/xml');

            var serializer = new XMLSerializer();
            xhr.send(serializer.serializeToString(this.toXmlDocument()));
        }

        /**
        * Saves the schedule into an XML Document.
        * @returns {Document} A DOM Document object containing XML-serialized schedule contents.
        */

    }, {
        key: 'toXmlDocument',
        value: function toXmlDocument() {
            var xmldoc = document.implementation.createDocument("", "", null);
            var scheduleElement = xmldoc.createElement("schedule");
            scheduleElement.setAttribute("version", "6");
            xmldoc.appendChild(scheduleElement);

            var context = new XmlPersistContext(this, xmldoc);

            // write contacts
            var contactsElement = context.addChildElement("contacts", scheduleElement);
            for (var i = 0; i < this.contacts.count(); i++) {
                context.saveResource(this.contacts.items()[i], contactsElement, "contact");
            } // write resources
            var resourcesElement = context.addChildElement("resources", scheduleElement);
            for (var i = 0; i < this.resources.count(); i++) {
                context.saveResource(this.resources.items()[i], resourcesElement, "resource");
            } // write locations
            var locationsElement = context.addChildElement("locations", scheduleElement);
            for (var i = 0; i < this.locations.count(); i++) {
                context.saveResource(this.locations.items()[i], locationsElement, "location");
            } // write tasks
            var tasksElement = context.addChildElement("tasks", scheduleElement);
            for (var i = 0; i < this.tasks.count(); i++) {
                context.saveResource(this.tasks.items()[i], tasksElement, "task");
            } // write items
            var itemsElement = context.addChildElement("items", scheduleElement);
            for (var i = 0; i < this.items.count(); i++) {
                context.saveItem(this.items.items()[i], itemsElement, "item");
            }return xmldoc;
        }

        /**
        * Loads the schedule from an XML file.
        * @param {String} fileUrl The URL of an XML file where the data should be read from.
        * @param {Function} [onLoad] A callback that should be invoked if the file is loaded successfully.
        * @param {Function} [onError] A callback that should be invoked if the file could not be downloaded.
        */

    }, {
        key: 'loadFromXml',
        value: function loadFromXml(fileUrl, onLoad, onError) {
            var schedule = this;
            var xhr = new XMLHttpRequest();
            xhr.onload = function () {
                schedule.fromXmlDocument(xhr.responseXML);
                if (onLoad) onLoad(schedule);
            };
            xhr.onerror = function () {
                console.log("Error while getting XML.");
                if (onError) onError(schedule);
            };
            xhr.open("GET", fileUrl);
            xhr.responseType = "document";
            xhr.send();
        }

        /**
        * Loads schedule data from specified XML Document.
        * @param {Document} document A DOM Document object containing XML-serialized schedule data.
        */

    }, {
        key: 'fromXmlDocument',
        value: function fromXmlDocument(document) {

            var doc = document.documentElement;

            var context = new XmlPersistContext(this, document);

            // load contacts
            this.contacts.clear();
            var nodes = doc.getElementsByTagName("contacts")[0];
            var element = nodes.firstElementChild;
            while (element != null) {
                var contact = context.loadResource(element);
                this.contacts.add(contact);
                element = element.nextElementSibling;
            }

            // load locations
            this.locations.clear();
            nodes = doc.getElementsByTagName("locations")[0];
            element = nodes.firstElementChild;
            while (element != null) {
                var location = context.loadResource(element);
                this.locations.add(location);
                element = element.nextElementSibling;
            }

            // load resources
            this.resources.clear();
            nodes = doc.getElementsByTagName("resources")[0];
            element = nodes.firstElementChild;
            while (element != null) {
                var resource = context.loadResource(element);
                this.resources.add(resource);
                element = element.nextElementSibling;
            }

            // load tasks
            this.tasks.clear();
            nodes = doc.getElementsByTagName("tasks")[0];
            element = nodes.firstElementChild;
            while (element != null) {
                var task = context.loadResource(element);
                this.tasks.add(task);
                element = element.nextElementSibling;
            }

            // load items
            this.items.clear();
            nodes = doc.getElementsByTagName("items")[0];
            element = nodes.firstElementChild;
            while (element != null) {
                var item = context.loadItem(element);
                this.items.add(item);
                element = element.nextElementSibling;
            }

            this.onChanged();
        }

        /**
        * Serializes the schedule into a JSON string.
        * @returns {String} A string containing the schedule's JSON representation.
        */

    }, {
        key: 'toJson',
        value: function toJson() {
            var contacts = [];
            for (var i = 0, l = this.contacts.count(); i < l; i++) {
                contacts.push(this.contacts.items()[i].toJson());
            }

            var resources = [];
            for (var i = 0, l = this.resources.count(); i < l; i++) {
                resources.push(this.resources.items()[i].toJson());
            }

            var locations = [];
            for (var i = 0, l = this.locations.count(); i < l; i++) {
                locations.push(this.locations.items()[i].toJson());
            }

            var tasks = [];
            for (var i = 0, l = this.tasks.count(); i < l; i++) {
                tasks.push(this.tasks.items()[i].toJson());
            }

            var items = [];
            for (var i = 0, l = this.items.count(); i < l; i++) {
                items.push(this.items.items()[i].toJson());
            }

            var json = {
                contacts: contacts,
                resources: resources,
                locations: locations,
                tasks: tasks,
                items: items
            };

            return JSON.stringify(json);
        }

        /**
        * Deserializes the diagram from a JSON string.
        * @param {String} json A string created by the toJson method.
        */

    }, {
        key: 'fromJson',
        value: function fromJson(json) {

            if (json > '') {
                var obj = JSON.parse(json);

                this._contacts.clear();
                if (obj.contacts) {
                    for (var i = 0, l = obj.contacts.length; i < l; i++) {
                        var contact = new Contact();
                        contact.fromJson(obj.contacts[i]);
                        this.contacts.add(contact);
                    }
                }

                this._resources.clear();
                if (obj.resources) {
                    for (var i = 0, l = obj.resources.length; i < l; i++) {
                        var resource = new Resource();
                        resource.fromJson(obj.resources[i]);
                        this.resources.add(resource);
                    }
                }

                this._locations.clear();
                if (obj.locations) {
                    for (var i = 0, l = obj.locations.length; i < l; i++) {
                        var location = new Location();
                        location.fromJson(obj.locations[i]);
                        this.locations.add(location);
                    }
                }

                this._tasks.clear();
                if (obj.tasks) {
                    for (var i = 0, l = obj.tasks.length; i < l; i++) {
                        var task = new Task();
                        task.fromJson(obj.tasks[i]);
                        this.tasks.add(task);
                    }
                }

                this._items.clear();
                if (obj.items) {
                    for (var i = 0, l = obj.items.length; i < l; i++) {
                        var item = new Item();
                        item.fromJson(obj.items[i], this);
                        this.items.add(item);
                    }
                }

                this.onChanged();
            }
        }
    }, {
        key: 'items',
        get: function get$$1() {
            return this._items;
        }
    }, {
        key: 'itemChanged',
        get: function get$$1() {
            return this._itemChanged;
        }

        /*
        * Gets the collection of tasks in this schedule.
        */

    }, {
        key: 'tasks',
        get: function get$$1() {
            return this._tasks;
        }
    }, {
        key: 'contacts',
        get: function get$$1() {
            return this._contacts;
        }
    }, {
        key: 'resources',
        get: function get$$1() {
            return this._resources;
        }
    }, {
        key: 'locations',
        get: function get$$1() {
            return this._locations;
        }
    }, {
        key: 'changed',
        get: function get$$1() {
            return this._changed;
        }
    }]);
    return Schedule;
}();

/**
* Registers a schedule item class for serialization support.
* @param {Object} itemClass An object identifying the item class.
* @param {String} classId A class identifier to use when saving and loading items of the specified type.
* @param {Number} classVersion A revision number of the item's class serialization format.
* @private 
*/
Schedule.registerItemClass = function (itemClass, classId, classVersion) {
    Schedule.xmlClassMap[classId] = itemClass;
    itemClass.xmlInfo = { classId: classId, classVersion: classVersion };
};

/**
* Maps class identifiers to their class descriptors.
* @private 
*/
Schedule.xmlClassMap = new Dictionary();

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* @class Represents a selected date-time range.
* @property {Boolean} enabled Gets or sets a value indicating whether users are allowed to select date cells.
* @property {Boolean} allowMultiple Gets or sets a value indicating whether users are allowed to select more than one date cell at a time.
*/
var Selection = function () {
    function Selection(calendar) {
        classCallCheck(this, Selection);

        this.calendar = calendar;
        this.enabled = true;
        this.allowMultiple = true;

        this.ranges = [];

        this._cells = [];
        this._cache = [];
    }

    /**
    * Gets the selection range.
    * @returns {TimeRange} The selected time range.
    */


    createClass(Selection, [{
        key: 'getRange',
        value: function getRange() {
            if (this.ranges.length > 0) {
                return this.ranges[0];
            }
            return null;
        }

        /**
        * Sets the selection range.
        * @param {DateTime} start The start time of the selection.
        * @param {DateTime} [end] The end time of the selection.
        * @param {Resource} [resource] The associated resource.
        */

    }, {
        key: 'setRange',
        value: function setRange(start, end, resource) {
            if (this.calendar._loaded) {

                if (start.valueOf() > this.calendar.view.endTime.valueOf()) return;
                if (end && end.valueOf() < this.calendar.view.startTime.valueOf()) return;
                if (resource == null && this.calendar.view.grouped) {
                    return null;
                }

                var startIndex = 0;
                var endIndex = 0;
                var startCell = this.calendar.getTimeCell(start, false, resource);
                if (startCell) {
                    startIndex = startCell.globalIndex || startCell.index;
                } else {
                    startCell = this.calendar.getTimeCell(this.calendar.view.startTime, false, resource);
                    if (startCell != null) {
                        startIndex = startCell.globalIndex || startCell.index;
                    }
                }

                if (end) {
                    var endCell = this.calendar.getTimeCell(end, true, resource);
                    if (endCell != null) {
                        endIndex = endCell.globalIndex || endCell.index;
                    } else {
                        endCell = this.calendar.getTimeCell(this.calendar.view.endTime, true, resource);
                        if (endCell != null) {
                            endIndex = endCell.globalIndex || endCell.index;
                        }
                    }
                } else {
                    endIndex = startIndex;
                }

                if (this.calendar.view.grouped && this.calendar.currentView != CalendarView.Timetable) {
                    if (startCell) startIndex = startCell.cellIndex;
                    if (endCell) endIndex = endCell.cellIndex;
                }

                var m = this.calendar.selectManager;

                if (resource) {
                    var r = m.resource;
                    m.resource = resource;
                    m.doSelect(startIndex, endIndex);
                    m.resource = r;
                } else {
                    m.doSelect(startIndex, endIndex);
                }
            }
        }

        /**
        * Clears the selection.
        */

    }, {
        key: 'clear',
        value: function clear(raiseChanged) {
            for (var i = 0, l = this._cells.length; i < l; i++) {
                DomUtils.removeCssClass(this._cells[i].bgCell, "mfp-selection");
            }
            this._cells = [];
            this.updateRanges(raiseChanged);
        }

        /**
        * Checks if the selection is empty.
        * @returns {Boolean} true if the selection is empty; otherwise false.
        */

    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            return this._cells.length === 0;
        }

        // Private methods
        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'addItems',
        value: function addItems(items) {
            for (var i = 0, l = items.length; i < l; i++) {

                if (this._cells.indexOf(items[i]) > -1) {
                    continue;
                }

                if (!this.allowMultiple) {
                    if (i < l - 1) {
                        continue;
                    }
                }
                this._cells.push(items[i]);
                DomUtils.addCssClass(items[i].bgCell, "mfp-selection");
            }
            this.updateRanges(true);
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'updateRanges',
        value: function updateRanges(raiseChanged) {
            this.ranges = [];

            if (this._cells.length > 0) {
                if (this._cells.length === 1) {
                    this.ranges.push(new TimeRange(this._cells[0].startTime, this._cells[0].endTime));
                } else {
                    this._cells.sort(this.sortItems);
                    this.ranges.push(new TimeRange(this._cells[0].startTime, this._cells[this._cells.length - 1].endTime));
                }
                this.resource = this._cells[0].resource;
            }

            if (raiseChanged !== false) {

                var trueChange = false;

                if (this._cache.length !== this.ranges.length) {
                    trueChange = true;
                } else {
                    for (var i = 0, l = this.ranges.length; i < l; i++) {
                        if (!this._cache[i].equals(this.ranges[i])) {
                            trueChange = true;
                        }
                    }
                }

                if (trueChange) {
                    if (this.ranges.length > 0) this.calendar.onSelectionChanged(new SelectionEventArgs(this.ranges[0].start, this.ranges[0].end, this.resource));

                    this._cache = [];
                    for (var i = 0, l = this.ranges.length; i < l; i++) {
                        this._cache.push(this.ranges[i]);
                    }
                }
            }
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'sortItems',
        value: function sortItems(a, b) {
            if (a.globalIndex !== undefined && b.globalIndex !== undefined) return a.globalIndex - b.globalIndex;
            return a.startTime._date.valueOf() - b.startTime._date.valueOf();
        }

        // Properties
        /**
        * Gets a value indicating whether users are allowed to select date cells.
         * @returns {Boolean} true if selection is enabled, otherwise false.
        */

    }, {
        key: 'enabled',
        get: function get$$1() {
            return this._enabled;
        }
        /**
        * Sets a value indicating whether users are allowed to select date cells.
        * @param {Boolean} value true to enable selection, otherwise false.
        */
        ,
        set: function set$$1(value) {
            if (this._enabled === value) return;

            this._enabled = value;
        }

        /**
        * Gets a value indicating whether users are allowed to select more than one date cell at a time.
         * @returns {Boolean} true if multiple selection is enabled, otherwise false.
        */

    }, {
        key: 'allowMultiple',
        get: function get$$1() {
            return this._allowMultiple;
        }
        /**
        * Sets a value indicating whether users are allowed to select more than one date cell at a time.
        * @param {Boolean} value true to enable multiple selection, otherwise false.
        */
        ,
        set: function set$$1(value) {
            if (this._allowMultiple === value) return;

            this._allowMultiple = value;
        }
    }]);
    return Selection;
}();

/**
* For internal use only.
* @private
*/

var SelectManager = function () {
    function SelectManager(calendar, args) {
        var _this = this;

        classCallCheck(this, SelectManager);


        this.calendar = calendar;
        this.view = calendar.view;
        this.element = this.view.getContainer();

        this.cells = this.view.cells;

        this.mouseUpHandler = function (e) {
            return _this.onMouseUp(e);
        };

        this.mouseDownHandler = function (e) {
            return _this.onMouseDown(e);
        };
        this.element.addEventListener('mousedown', this.mouseDownHandler);

        this.mouseMoveHandler = function (e) {
            return _this.onMouseMove(e);
        };
        this.element.addEventListener('mousemove', this.mouseMoveHandler);

        this.clickHandler = function (e) {
            return _this.onClick(e);
        };
        this.element.addEventListener('click', this.clickHandler);

        this.doubleClickHandler = function (e) {
            return _this.onDoubleClick(e);
        };
        this.element.addEventListener('dblclick', this.doubleClickHandler);

        this.start = null;
        this.end = null;
    }

    createClass(SelectManager, [{
        key: 'dispose',
        value: function dispose() {
            if (this.mouseUpHandler) {
                document.removeEventListener('mouseup', this.mouseUpHandler);
                delete this.mouseUpHandler;
            }
            if (this.mouseDownHandler) {
                this.element.removeEventListener('mousedown', this.mouseDownHandler);
                delete this.mouseUpHandler;
            }
            if (this.mouseMoveHandler) {
                this.element.removeEventListener('mousemove', this.mouseMoveHandler);
                delete this.mouseMoveHandler;
            }
            if (this.clickHandler) {
                this.element.removeEventListener('click', this.clickHandler);
                delete this.clickHandler;
            }
            if (this.doubleClickHandler) {
                this.element.removeEventListener('dblclick', this.doubleClickHandler);
                delete this.doubleClickHandler;
            }
        }
    }, {
        key: 'onMouseDown',
        value: function onMouseDown(e) {

            if (!this.calendar.enabled || this.view._selectionPaused) return;

            if (DomUtils.hasCssClass(e.target, 'mfp-cue') || DomUtils.getParent(e.target, 'mfp-cue')) return;

            if (this.calendar.popups.get('ItemsCueForm')) {
                this.calendar.popups.get('ItemsCueForm').closeForm();
            }

            document.addEventListener('mouseup', this.mouseUpHandler);

            this.startSelect(e);
        }
    }, {
        key: 'onMouseMove',
        value: function onMouseMove(e) {
            if (!this.calendar.enabled) return;

            if (this.calendar.currentView == CalendarView.Timetable) {
                if (this.view._dragging) {
                    this.resource = this.calendar.checkResource(e, this.resource);
                }
                if (!this.view._dragging && !this.view._selecting) {
                    this.view.doSelect(e);
                    this.doSelect(this.start, this.end);
                }
                return;
            }

            var fv = this.view.firstVisibleCell;
            var lv = this.view.lastVisibleCell;

            if (this.view._dragging) {
                this.start = this.view.getCellIndexAt(e.clientX, e.clientY, this.resource);

                if (this.start != null) {
                    this.resource = this.calendar.checkResource(e, this.resource);

                    if (this.view.grouped) this.end = this.view.getEndCell(this.start + this.view.itemData.appointment.cellsLength - 1, this.view.cells.items()[this.start].resource);else this.end = this.start + this.view.itemData.appointment.cellsLength - 1;
                    this.doSelect(this.start, this.end, true);
                }
            }
            if (!this.view._dragging && !this.view._selecting) {

                if (this.start != null) {
                    var cell = this.view.getCellIndexAt(e.clientX, e.clientY, this.resource);
                    if (cell != null) {
                        if (!this.calendar.selection.allowMultiple) {
                            this.start = cell;
                        }

                        if (fv && cell < fv) {
                            this.end = fv;
                        } else if (lv && cell > lv) {
                            this.end = lv;
                        } else {
                            this.end = cell;
                        }

                        this.doSelect(this.start, this.end);
                    }
                }
            }
            e.preventDefault();
            return false;
        }
    }, {
        key: 'onMouseUp',
        value: function onMouseUp(e) {
            if (!this.calendar.enabled) return;

            document.removeEventListener('mouseup', this.mouseUpHandler);

            var cursor = DomUtils.getCursorPosition(e, this._element, this._scroller);
            if (this.end == null) {
                var end = this.view.getCellIndexAt(e.clientX, e.clientY, this.resource);
                if (end != null) {
                    this.end = end;
                }
            }

            // if (this.end != null) {
            //     if (this.isInHeader) {
            //         var cellIndex = this.view.getCellAt(e.clientX, e.clientY).index;
            //         this.calendar._raiseEvent('onDateMouseUp', new MindFusion.Scheduling.CellEventArgs({ cell: this.view.headerCells[cellIndex], e: e }));
            //     }
            //     else if (this.isValidCell(this.end)) {
            //         this.calendar._raiseEvent('onDateMouseUp', new MindFusion.Scheduling.CellEventArgs({ cell: this.view.cells[this.end], e: e }));
            //     }
            // }
            this.endSelect(e);
        }
    }, {
        key: 'onClick',
        value: function onClick(e) {
            var cell = this.view.getCellAt(e.clientX, e.clientY);

            if (cell) {
                if (this.view.getCellHeaderAt(cell, e.clientX, e.clientY)) {
                    this.calendar.onHeaderClick(new HeaderEventArgs(HeaderType.Cell));
                } else {
                    this.calendar.onCellClick(new CellEventArgs(cell));
                }
            }
        }
    }, {
        key: 'onDoubleClick',
        value: function onDoubleClick(e) {
            var cell = this.view.getCellAt(e.clientX, e.clientY);

            if (cell) {
                if (this.view.getCellHeaderAt(cell, e.clientX, e.clientY)) {
                    this.calendar.onHeaderDoubleClick(new HeaderEventArgs(HeaderType.Cell));
                } else {
                    this.calendar.onCellDoubleClick(new CellEventArgs(cell));
                }
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            for (var i = 0, l = this.cells.count(); i < l; i++) {
                if (this.cells.items()[i].bgCell) {
                    DomUtils.removeCssClass(this.cells.items()[i].bgCell, "mfp-drag-indicator");
                }
            }
        }
    }, {
        key: 'startSelect',
        value: function startSelect(e) {
            var cursor = DomUtils.getCursorPosition(e, this._element, this._scroller);
            if (this.calendar.currentView == CalendarView.Timetable) {
                var c = this.view.getCellAt(e.clientX, e.clientY);

                if (c) {
                    this.resource = c.resource;

                    if (!this.view._dragging && !this.view._selecting) {
                        if (this.calendar._itemSelection.count() > 0) {
                            this.calendar._itemSelection.clear();
                        }
                        this.view.startSelect(e);
                        if (this.start != null) {
                            //this.calendar._raiseEvent('onDateMouseDown', new MindFusion.Scheduling.CellEventArgs({ cell: this.view.cells[this.start], e: e }));

                            if (this.calendar.selection.enabled) {
                                if (e.button == 0) {
                                    if (this.calendar.onSelectionStart(new SelectionEventArgs(this.view.cells.items()[this.start].startTime, this.view.cells.items()[this.start].endTime, this.resource))) {
                                        this.doSelect(this.start, this.end);
                                    } else {
                                        this.start = null;
                                    }
                                }
                            } else {
                                this.start = null;
                                this.end = null;
                            }
                        } else {
                            this.start = null;
                            this.end = null;
                        }
                    }
                }
                return;
            }
            var c = this.view.getCellIndexAt(e.clientX, e.clientY);
            if (!this.view.isValidCell(c)) {
                return;
            }

            this.resource = this.view.cells.items()[c].resource;

            if (this.view._dragging || this.view._selecting) {
                this.start = this.view.itemData.startCellIndex;
                this.end = this.view.itemData.lastCellIndex;
            }
            if (!this.view._dragging && !this.view._selecting) {
                // clear previous item selections
                if (this.calendar._itemSelection.count() > 0) {
                    this.calendar._itemSelection.clear();
                }

                this.start = this.view.getCellIndexAt(e.clientX, e.clientY, this.resource);

                this.end = this.start;
                if (this.start != null) {
                    // this.calendar._raiseEvent('onDateMouseDown', new MindFusion.Scheduling.CellEventArgs({ cell: this.view.cells[this.start], e: e }));

                    if (this.calendar.selection.enabled) {
                        if (e.button == 0) {
                            if (this.calendar.onSelectionStart(new SelectionEventArgs(this.view.cells.items()[this.start].startTime, this.view.cells.items()[this.start].endTime, this.resource))) {
                                this.doSelect(this.start, this.end);
                            } else {
                                this.start = null;
                            }
                        }
                    } else {
                        this.start = null;
                        this.end = null;
                    }
                } else {
                    this.start = null;
                    this.end = null;
                }
            }
        }
    }, {
        key: 'doSelect',
        value: function doSelect(start, end, drag) {

            if (start == null || end == null) return;
            if (start > end) {
                var p = start;
                start = end;
                end = p;
            }

            var fv = this.view.firstVisibleCell;
            var lv = this.view.lastVisibleCell;

            if (this.calendar._currentView == 0) {
                var fv = this.view.firstVisibleCellOfMonth(start);
                var lv = this.view.lastVisibleCellOfMonth(end);
            }

            if (drag) {
                this.clear();
            } else {
                if (!this.calendar.selection.isEmpty()) {
                    this.calendar.selection.clear(false);
                }
            }

            if (start == -1) start = 0;
            if (end == -1) end = this.cells.length;

            var s = Math.min(start, end);
            var e = Math.max(start, end);
            if (fv && s < fv) {
                s = fv;
            }
            if (lv && e > lv) {
                e = lv;
            }

            if (this.calendar._currentView == 0) {
                if (drag) {
                    s = this.view.getIndexCell(s, s);
                    e = this.view.getIndexCell(s + this.view.itemData.appointment.cellsLength - 1, s);
                }
            } else {
                if (lv && e > lv) {
                    e = lv;
                }
            }

            var items = [];

            for (var i = s; i <= e; i++) {
                if (this.cells.items()[i]) {
                    if (drag) {
                        if (this.cells.items()[i].bgCell.className.indexOf("empty") == -1) DomUtils.addCssClass(this.cells.items()[i].bgCell, "mfp-drag-indicator");
                    } else {
                        if (this.resource && this.view.cells.items()[i].resource != this.resource) continue;

                        items.push(this.view.cells.items()[i]);
                    }
                }
            }

            if (items.length > 0) {
                this.calendar.selection.addItems(items);
            }
        }
    }, {
        key: 'endSelect',
        value: function endSelect(e) {

            var cursor = DomUtils.getCursorPosition(e, this._element, this._scroller);

            if (e.button == 0) {
                if (!this.view._dragging && !this.view._selecting) {
                    if (this.start != null && this.end != null) {
                        var fv = this.view.firstVisibleCell;
                        var lv = this.view.lastVisibleCell;

                        if (this.calendar.currentView == 0) {
                            var realStart = Math.min(this.start, this.end);
                            var realEnd = Math.max(this.start, this.end);
                            if (realStart < 0) realStart = 0;

                            var fv = this.view.firstVisibleCellOfMonth(realStart);
                            var lv = this.view.lastVisibleCellOfMonth(realEnd);
                            var flv = this.view.firstVisibleCellOfMonth(realEnd);

                            if (realEnd < flv) lv = this.view.lastMonthVisibleCell(realEnd);

                            this.start = realStart;
                            this.end = realEnd;
                        }

                        if (fv && this.end < fv) {
                            this.end = fv;
                        }
                        if (lv && this.end > lv) {
                            this.end = lv;
                        }

                        var start = this.view.cells.items()[Math.min(this.start, this.end)].startTime;
                        var end = this.view.cells.items()[Math.max(this.start, this.end)].endTime;
                        // this.calendar.onSelectionEnd(new SelectionEventArgs(start, end, cursor));
                        if (this.calendar.onSelectionEnd(new SelectionEventArgs(start, end, this.resource)))
                            //{ startTime: 
                            //   this.view.cells[Math.min(this.start, this.end)].startTime, endTime: this.view.cells[Math.max(this.start, this.end)].endTime, mouse: cursor })))
                            this.view.endSelection(e, Math.min(this.start, this.end), Math.max(this.start, this.end), this.resource);
                    }
                } else {
                    this.view._selecting = false;
                }
                this.stopSelect();
                return;
            } else {
                this.stopSelect();
            }
        }
    }, {
        key: 'stopSelect',
        value: function stopSelect() {
            this.start = null;
            this.end = null;
            this.resource = null;
            this.clear();
        }
    }]);
    return SelectManager;
}();

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

var Timer = function () {
    function Timer(calendar) {
        classCallCheck(this, Timer);

        this.calendar = calendar;
        this.minDate = new Date(1970, 1, 1, 0, 0, 0);
        this.lastCheckStart = this.minDate;
        this.lastCheckEnd = this.minDate;
        this.checkInterval = 6;
        this.start();
    }

    createClass(Timer, [{
        key: 'getItems',
        value: function getItems(start, end) {
            var result = [];
            for (var i = 0, l = this.calendar.view.items.length; i < l; i++) {
                var item = this.calendar.view.items[i].item;
                var reminder = item.reminder;

                if (reminder == null) continue;

                var reminderTime;

                if (reminder.type === ReminderType.Exact) {
                    // onItemReminderTriggered event is not raised for recurrent items with ReminderType 0 (Exact)
                    if (item.recurrence !== null && item.recurrence !== undefined) {
                        continue;
                    }
                    reminderTime = reminder.time;
                    if (reminderTime.valueOf() >= start.valueOf() && reminderTime.valueOf() < end.valueOf()) result.push(item);
                }

                if (reminder.type === ReminderType.Leading) {
                    reminderTime = item.startTime._date.valueOf() - reminder.timeInterval.milliseconds;
                    if (reminderTime >= start.valueOf() && reminderTime < end.valueOf()) result.push(item);
                }
            }

            return result;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'getTasks',
        value: function getTasks(start, end) {
            var result = [];
            for (var i = 0, l = this.calendar.schedule.tasks.length; i < l; i++) {
                var task = this.calendar.schedule.tasks[i];
                var reminder = task.reminder;

                if (reminder === null) {
                    continue;
                }

                if (reminder.type === ReminderType.Exact) {
                    var reminderTime = reminder.time;
                    if (reminderTime.valueOf() >= start.valueOf() && reminderTime.valueOf() < end.valueOf()) {
                        result.push(task);
                    }
                }
                // onTaskReminderTriggered event is not raised for tasks with ReminderType 1 (Leading)
            }

            return result;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'trigger',
        value: function trigger() {
            var start;
            var end;
            if (this.lastCheckStart.valueOf() === this.minDate.valueOf()) {
                start = new Date(new Date().valueOf() - this.checkInterval);
                end = new Date();
            } else {
                start = this.lastCheckEnd;
                end = new Date();
            }

            var items = this.getItems(start, end);
            if (items.length > 0) {
                for (var i = 0, l = items.length; i < l; i++) {
                    this.calendar.onItemReminderTriggered(new ItemEventArgs(items[i]));
                }
            }
            var tasks = this.getTasks(start, end);
            if (tasks.length > 0) {
                for (var j = 0, m = tasks.length; j < m; j++) {
                    this.calendar.onTaskReminderTriggered(new TaskEventArgs(tasks[j]));
                }
            }

            this.lastCheckStart = start;
            this.lastCheckEnd = end;
        }

        /**
        * For internal use only.
        * @private
        */

    }, {
        key: 'start',
        value: function start() {
            var _this = this;

            this.id = setInterval(function () {
                _this.trigger();
            }, this.checkInterval);
        }
    }]);
    return Timer;
}();

__$styleInject(".mfp-planner\r\n{\r\n    width:100%;\r\n    height:100%;\r\n    -webkit-touch-callout: none;\r\n    -webkit-user-select: none;\r\n    -khtml-user-select: none;\r\n    -moz-user-select: none;\r\n    -ms-user-select: none;\r\n    user-select: none;\r\n}\r\n.mfp-planner div\r\n{\r\n    box-sizing: border-box;\r\n}\r\n.mfp-planner table\r\n{\r\n    border-collapse: collapse; \r\n}\r\n.mfp-planner table td, \r\n.mfp-planner table th\r\n{\r\n    padding: 0; \r\n}\r\n.mfp-cue\r\n{\r\n    cursor: pointer;\r\n    width:20%;\r\n    float: right;\r\n    margin-right: 4px;\r\n    text-align: right;\r\n\r\n}\r\n.mfp-cue > i\r\n{\r\n    border: solid black;\r\n    border-width: 0 1px 1px 0;\r\n    display: inline-block;\r\n    padding: 2px;\r\n    transform: rotate(45deg);\r\n    -webkit-transform: rotate(45deg);\r\n}\r\n.mfp-planner .mfp-selection\r\n{\r\n     background-color: rgba(0, 0, 0, 0.3);\r\n}\r\n\r\nhtml.mfp-cursor-move,\r\nhtml.mfp-cursor-move .mfp-planner *,\r\nhtml.mfp-cursor-move .mfp-planner .mfp-item-container,\r\nhtml.mfp-cursor-move .mfp-planner .mfp-item-container .mfp-resize-start,\r\nhtml.mfp-cursor-move .mfp-planner .mfp-item-container .mfp-resize-end\r\n{\r\n    cursor: move !important;\r\n}\r\n\r\nhtml.mfp-cursor-n-resize,\r\nhtml.mfp-cursor-n-resize .mfp-planner *,\r\nhtml.mfp-cursor-n-resize .mfp-planner .mfp-item-container,\r\nhtml.mfp-cursor-n-resize .mfp-planner .mfp-item-container .mfp-resize-start,\r\nhtml.mfp-cursor-n-resize .mfp-planner .mfp-item-container .mfp-resize-end\r\n{\r\n    cursor: n-resize !important;\r\n}\r\n\r\nhtml.mfp-cursor-w-resize,\r\nhtml.mfp-cursor-w-resize .mfp-planner *,\r\nhtml.mfp-cursor-w-resize .mfp-planner .mfp-item-container,\r\nhtml.mfp-cursor-w-resize .mfp-planner .mfp-item-container .mfp-resize-start,\r\nhtml.mfp-cursor-w-resize .mfp-planner .mfp-item-container .mfp-resize-end\r\n{\r\n    cursor: w-resize !important;\r\n}\r\n\r\nhtml.mfp-cursor-not-allowed,\r\nhtml.mfp-cursor-not-allowed .mfp-planner *,\r\nhtml.mfp-cursor-not-allowed .mfp-planner .mfp-item-container,\r\nhtml.mfp-cursor-not-allowed .mfp-planner .mfp-item-container .mfp-resize-start,\r\nhtml.mfp-cursor-not-allowed .mfp-planner .mfp-item-container .mfp-resize-end\r\n{\r\n    cursor: not-allowed !important;\r\n}", undefined);

__$styleInject(".mfp-month-view,\r\n.mfp-month-range-view \r\n{\r\n    border: 1px solid;\r\n    background-color:#fff;\r\n}\r\n.mfp-month-view .mfp-header-weeknumbers\r\n{\r\n    border-right: 1px solid;\r\n}\r\n.mfp-month-view .mfp-header-weekdays,\r\n.mfp-month-view .mfp-bg-cell-header,\r\n.mfp-month-view .mfp-item-table .mfp-cell-header\r\n{\r\n    border-top: 1px solid;\r\n}\r\n.mfp-month-view .mfp-bg-cell-header,\r\n.mfp-month-view .mfp-item-table .mfp-cell-header\r\n{\r\n     border-bottom: 1px solid;\r\n}\r\n.mfp-month-view .mfp-item-table .mfp-cell-header\r\n{\r\n    border-color: transparent;\r\n}\r\n.mfp-month-view .mfp-bg-cell:not(:last-child)\r\n{\r\n    border-right:1px solid;\r\n}\r\n\r\n.mfp-month-view > div:first-child,\r\n.mfp-month-range-view > div:first-child\r\n{\r\n    position: relative;\r\n    display: flex;\r\n    flex-direction: column;\r\n\theight: 100%;\r\n}\r\n\r\n.mfp-month-view .mfp-header,\r\n.mfp-month-range-view .mfp-header\r\n{\r\n    flex: 0 0 auto;\r\n    flex-direction: column;\r\n}\r\n\r\n.mfp-month-view .mfp-header .mfp-title,\r\n.mfp-month-range-view .mfp-header .mfp-title\r\n{\r\n    text-align: center;\r\n    display: flex;\r\n    justify-content: space-between;\r\n}\r\n\r\n.mfp-month-view .mfp-header .mfp-title .mfp-link,\r\n.mfp-month-range-view .mfp-header .mfp-title .mfp-link\r\n{\r\n    order:0;\r\n    display: inline-block;\r\n    width:100%;\r\n}\r\n\r\n.mfp-month-view .mfp-header .mfp-button,\r\n.mfp-month-range-view .mfp-header .mfp-button\r\n{\r\n    font-size: xx-small;\r\n    padding:4px;\r\n    display: inline-block;\r\n    cursor: pointer;\r\n}\r\n\r\n.mfp-month-view .mfp-header .mfp-title .mfp-button-prev\r\n{\r\n    order:-1;\r\n}\r\n.mfp-month-view .mfp-header .mfp-title .mfp-button-prev-2,\r\n.mfp-month-range-view .mfp-header .mfp-title .mfp-button-prev-2\r\n{\r\n    order:-2;\r\n}\r\n\r\n.mfp-month-view .mfp-header .mfp-title .mfp-button-next\r\n{\r\n    order:2;\r\n}\r\n\r\n.mfp-month-view .mfp-header .mfp-title .mfp-button-next-2,\r\n.mfp-month-range-view .mfp-header .mfp-title .mfp-button-next-2\r\n{\r\n    order:3;\r\n}\r\n\r\n.mfp-month-view .mfp-header .mfp-button-prev > span::before\r\n{\r\n     content: '\\25c4';\r\n}\r\n\r\n.mfp-month-view .mfp-header .mfp-button-next > span::before\r\n{\r\n    content: '\\25ba';\r\n}\r\n\r\n.mfp-month-view .mfp-header .mfp-button-prev-2 > span::before,\r\n.mfp-month-range-view .mfp-header .mfp-button-prev-2 > span::before\r\n{\r\n    content: '\\25c4\\25c4';\r\n}\r\n\r\n.mfp-month-view .mfp-header .mfp-button-next-2 > span::before,\r\n.mfp-month-range-view .mfp-header .mfp-button-next-2 > span::before\r\n{\r\n    content: '\\25ba\\25ba';\r\n}\r\n\r\n\r\n.mfp-month-view .mfp-header .mfp-header-weekdays\r\n{\r\n    position:relative;\r\n    z-index:0;\r\n    width:100%;\r\n  /*  height:100%;*/\r\n    display:flex;\r\n    flex-direction: row;\r\n}\r\n\r\n.mfp-month-view .mfp-header-weeknumbers\r\n{\r\n    flex: 0 0 30px;\r\n}\r\n\r\n.mfp-month-view .mfp-header-weeknumbers .mfp-weeknumbers\r\n{\r\n    width:100%;\r\n    height:100%;\r\n    table-layout: fixed;\r\n}\r\n\r\n.mfp-month-view .mfp-header .mfp-header-weekdays .mfp-weekdays-wrap\r\n{\r\n    width:100%;\r\n  /*  height:100%;*/\r\n    display:flex;\r\n    flex-direction: row;\r\n    justify-content: space-around;\r\n    text-align: center;\r\n}\r\n\r\n.mfp-month-view .mfp-header .mfp-header-weekdays .mfp-weekdays-wrap > div\r\n{\r\n    flex:1 1 0%;\r\n}\r\n\r\n.mfp-month-view .mfp-content,\r\n.mfp-month-range-view .mfp-content\r\n{\r\n    flex: 1 1 100%;\r\n    position: relative;\r\n    display: flex;\r\n}\r\n\r\n.mfp-month-view .mfp-content .mfp-wrap\r\n{\r\n    width:100%;\r\n    /*height:100%;\r\n    display: flex;*/\r\n    flex-direction: column;\r\n    flex: 1 1 100%;\r\n}\r\n.mfp-month-view .mfp-content .mfp-wrap .mfp-week\r\n{\r\n    position:relative;\r\n    flex:1;\r\n}\r\n\r\n.mfp-month-view .mfp-content .mfp-wrap .mfp-bg-row\r\n{\r\n    position:relative;\r\n    z-index:0;\r\n    width:100%;\r\n    height:100%;\r\n    table-layout: fixed;\r\n    display:flex;\r\n    flex-direction: row;\r\n    justify-content: space-around;\r\n    text-align: center;\r\n}\r\n\r\n.mfp-month-view .mfp-content .mfp-wrap .mfp-bg-row .mfp-bg-cell\r\n{\r\n    vertical-align: top;\r\n    flex:1;\r\n    overflow: hidden;\r\n}\r\n\r\n.mfp-month-view .mfp-content .mfp-wrap .mfp-bg-row .mfp-bg-cell .mfp-bg-cell-header\r\n{\r\n    white-space: nowrap;\r\n}\r\n\r\n.mfp-month-view .mfp-content .mfp-wrap .mfp-item-table\r\n{\r\n    left: 0;\r\n    position: absolute;\r\n    table-layout: fixed;\r\n    top: 0;\r\n    width: 100%;\r\n    z-index: 1;\r\n}\r\n\r\n.mfp-month-view .mfp-content .mfp-wrap .mfp-item-table td\r\n{\r\n    vertical-align: top;\r\n}\r\n\r\n/*Month range*/\r\n.mfp-month-range-view .mfp-content-wrap\r\n{\r\n    position:relative;\r\n    overflow-y: auto;\r\n    overflow-x:hidden;\r\n    flex:1 1 100%;\r\n}\r\n.mfp-month-range-view .mfp-content-wrap > .mfp-wrap\r\n{\r\n    position:relative;\r\n    display: flex;\r\n    flex-direction: column;\r\n   /* height:100%;*/\r\n}\r\n.mfp-month-range-view .mfp-content-wrap > .mfp-wrap > div\r\n{\r\n    display: flex;\r\n   /* flex:1 1 100%;*/\r\n}\r\n.mfp-month-range-view .mfp-content-wrap .mfp-month-view\r\n{\r\n    width:100%;\r\n    height:100%;\r\n}", undefined);

__$styleInject(".mfp-timetable-view\r\n{\r\n    border:1px solid;\r\n    background-color:#fff; \r\n}\r\n\r\n.mfp-timetable-view .mfp-cell\r\n{\r\n    border-top:1px solid;\r\n}\r\n\r\n.mfp-timetable-view .mfp-header-timeline,\r\n.mfp-timetable-view .mfp-column\r\n{\r\n    border-right: 1px solid;\r\n}\r\n\r\n.mfp-timetable-view\r\n{\r\n    overflow: visible;\r\n}\r\n\r\n.mfp-timetable-view > div:first-child\r\n{\r\n    position: relative;\r\n    display: flex;\r\n    flex-direction: column;\r\n\theight: 100%;\r\n}\r\n\r\n/*main header*/\r\n.mfp-timetable-view .mfp-header\r\n{\r\n    width: 100%;\r\n    display: flex;\r\n    flex: 1 0 auto;\r\n    justify-content: space-between;\r\n}\r\n\r\n.mfp-timetable-view .mfp-header .mfp-corner\r\n{\r\n    flex: 0 0 40px;\r\n}\r\n.mfp-timetable-view .mfp-header .mfp-title\r\n{\r\n    position: relative;\r\n    width: 100%;\r\n    overflow: hidden;\r\n}\r\n\r\n.mfp-timetable-view .mfp-header .mfp-title .mfp-title-table\r\n{\r\n    position: relative;\r\n    width: 100%;\r\n    height:100%;\r\n    table-layout: fixed;\r\n    text-align: center;\r\n}\r\n\r\n.mfp-timetable-view .mfp-header .mfp-title .mfp-button-wrap\r\n{\r\n    position: absolute;\r\n    width: 100%;\r\n    top: 0;\r\n    z-index: 1;\r\n}\r\n\r\n.mfp-timetable-view .mfp-header .mfp-button\r\n{\r\n    display: inline-block;\r\n    cursor: pointer;\r\n    font-size: xx-small;\r\n    padding:4px;\r\n   /* margin-top:10px;*/\r\n}\r\n\r\n.mfp-timetable-view .mfp-header .mfp-title .mfp-button-wrap a:last-child\r\n{\r\n    float:right;\r\n}\r\n\r\n.mfp-timetable-view .mfp-header .mfp-title .mfp-button-prev\r\n{\r\n    order:-1;\r\n}\r\n\r\n.mfp-timetable-view .mfp-header .mfp-title .mfp-button-next\r\n{\r\n    order:2;\r\n}\r\n\r\n.mfp-timetable-view .mfp-header .mfp-button-prev > span::before\r\n{\r\n     content: '\\25c4';\r\n}\r\n\r\n.mfp-timetable-view .mfp-header .mfp-button-next > span::before\r\n{\r\n    content: '\\25ba';\r\n}\r\n\r\n\r\n.mfp-timetable-view .mfp-header .mfp-title-table tr.mfp-item-row > td\r\n{\r\n    vertical-align: top;\r\n}\r\n\r\n.mfp-timetable-view .mfp-header .mfp-title-table tr.mfp-empty-row > td:empty:after\r\n{\r\n    content: \"\\00a0\";\r\n}\r\n\r\n.mfp-timetable-view .mfp-header .mfp-scrollfix\r\n{\r\n    width:17px;\r\n}\r\n.mfp-timetable-view .mfp-scroll-container\r\n{\r\n   position: relative;\r\n   height:100%; \r\n   overflow-y: scroll;\r\n}\r\n\r\n.mfp-timetable-view .mfp-content-wrap\r\n{\r\n    position: relative;\r\n    display: flex;\r\n}\r\n\r\n.mfp-timetable-view .mfp-content-wrap .mfp-header-timeline\r\n{\r\n    flex: 0 0 40px;\r\n    overflow-x: hidden;\r\n}\r\n\r\n.mfp-timetable-view .mfp-content-wrap .mfp-header-timeline\r\n{\r\n    display:flex;\r\n    flex-direction: column;\r\n}\r\n.mfp-timetable-view .mfp-header-timeline .mfp-group-time\r\n{\r\n    height: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    float: right;\r\n}\r\n.mfp-timetable-view .mfp-header-timeline .mfp-group-time > div\r\n{\r\n    flex: 1 1 0%;\r\n}\r\n.mfp-timetable-view .mfp-header-timeline .mfp-hour,\r\n.mfp-timetable-view .mfp-header-timeline .mfp-time\r\n{\r\n    flex: 1 1 0%;\r\n    float: left;\r\n    text-align: center;\r\n    font-size: small;\r\n    white-space: nowrap;\r\n    overflow: hidden;\r\n}\r\n\r\n.mfp-timetable-view .mfp-header-timeline .mfp-hour span\r\n{\r\n  clear :both;\r\n}\r\n.mfp-timetable-view .mfp-header-timeline .mfp-minute,\r\n.mfp-timetable-view .mfp-header-timeline .mfp-AMPM\r\n{\r\n    text-align: center;\r\n    font-size: x-small;\r\n    white-space: nowrap;\r\n    overflow: hidden;\r\n}\r\n\r\n.mfp-timetable-view .mfp-content\r\n{\r\n    display: flex;\r\n    flex: 1 1 100%;\r\n    position: relative;\r\n}\r\n\r\n.mfp-timetable-view .mfp-content .mfp-column\r\n{\r\n    flex: 1 1 auto;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.mfp-timetable-view .mfp-content .mfp-column .mfp-cell-wrap\r\n{\r\n    position: relative;\r\n    /*flex: 1 1 0;*/\r\n    overflow: visible;\r\n    padding-right:10px;\r\n    box-sizing: border-box;\r\n}\r\n\r\n.mfp-timetable-view .mfp-content .mfp-column .mfp-cell\r\n{\r\n    position: absolute;\r\n    left: 0;\r\n    right: 0;\r\n    top: 0;\r\n    bottom: 0;\r\n    z-index: 0;\r\n}", undefined);

__$styleInject(".mfp-horizontal-timetable-view\r\n{\r\n    border:1px solid;\r\n    background-color:#fff; \r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-cell\r\n{\r\n    border-left:1px solid;\r\n}\r\n\r\n.mfp-horizontal-timetable-view\r\n{\r\n    overflow: visible;\r\n}\r\n\r\n.mfp-horizontal-timetable-view > div:first-child\r\n{\r\n    position: relative;\r\n    display: flex;\r\n\theight: 100%;\r\n}\r\n\r\n/*main header*/\r\n.mfp-horizontal-timetable-view .mfp-header\r\n{\r\n    height: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    flex: 0 0 auto;\r\n    justify-content: space-between;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-header .mfp-corner\r\n{\r\n    flex: 0 0 40px;\r\n}\r\n.mfp-horizontal-timetable-view .mfp-header .mfp-title\r\n{\r\n    position: relative;\r\n    height: 100%;\r\n    overflow: hidden;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-header .mfp-title .mfp-title-table\r\n{\r\n    position: relative;\r\n    height:100%;\r\n    table-layout: fixed;\r\n    text-align: center;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-header .mfp-title .mfp-button-wrap\r\n{\r\n    position: absolute;\r\n    top:0px;\r\n    height: 100%;\r\n    z-index: 1;\r\n    text-align: center;\r\n    margin-left:10px;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-header .mfp-button\r\n{\r\n    display: inline-block;\r\n    cursor: pointer;\r\n    font-size: xx-small;\r\n    padding:4px;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-header .mfp-title .mfp-button-prev\r\n{\r\n    order:-1;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-header .mfp-title .mfp-button-next\r\n{\r\n    order:2;\r\n    position: absolute;\r\n    left:50%;\r\n    bottom:0;\r\n    margin-left:-10px;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-header .mfp-button-prev > span::before\r\n{\r\n    content: '\\25b2';\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-header .mfp-button-next > span::before\r\n{\r\n    content: '\\25bc';\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-header .mfp-title-table td.mfp-item-row .mfp-item-wrap\r\n{\r\n    height:100%;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-header .mfp-title-table td.mfp-item-row table\r\n{\r\n    table-layout: fixed;\r\n    height:100%;\r\n}\r\n.mfp-horizontal-timetable-view .mfp-header .mfp-title-table td.mfp-item-cell\r\n{\r\n   display:flex;\r\n   height:100%;\r\n}\r\n.mfp-horizontal-timetable-view .mfp-scroll-container\r\n{\r\n   position: relative;\r\n   width:100%; \r\n   height: 100%;\r\n   overflow-x: scroll;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-content-wrap\r\n{\r\n    position: relative;\r\n    display: flex;\r\n    flex-direction: column;\r\n    width:100%;\r\n    height:100%;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-content-wrap .mfp-header-timeline\r\n{\r\n    flex: 0 0 40px;\r\n    overflow-x: hidden;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-content-wrap .mfp-header-timeline\r\n{\r\n    display:flex;\r\n}\r\n.mfp-horizontal-timetable-view .mfp-header-timeline .mfp-group-time\r\n{\r\n    display: flex;\r\n    flex: 1 1 100%;\r\n}\r\n.mfp-horizontal-timetable-view .mfp-header-timeline .mfp-group-time > div\r\n{\r\n    flex: 1 1 0%;\r\n}\r\n.mfp-horizontal-timetable-view .mfp-header-timeline .mfp-hour,\r\n.mfp-horizontal-timetable-view .mfp-header-timeline .mfp-time\r\n{\r\n    flex: 1 1 0%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    text-align: center;\r\n    font-size: small;\r\n    white-space: nowrap;\r\n    overflow: hidden;\r\n}\r\n.mfp-horizontal-timetable-view .mfp-header-timeline .mfp-minute,\r\n.mfp-horizontal-timetable-view .mfp-header-timeline .mfp-AMPM\r\n{\r\n    text-align: center;\r\n    font-size: x-small;\r\n    white-space: nowrap;\r\n    overflow: hidden;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-content\r\n{\r\n    display: flex;\r\n    flex-direction: column;\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-content .mfp-column\r\n{\r\n    position:relative;\r\n    z-index:0;\r\n    height:100%;\r\n    display:flex;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-content .mfp-column .mfp-cell-wrap\r\n{\r\n    position: relative;\r\n    flex: 1 1 0;\r\n    overflow: visible;\r\n    box-sizing: border-box;\r\n}\r\n.mfp-horizontal-timetable-view .mfp-content .mfp-column .mfp-item-wrap\r\n{\r\n    padding-bottom:10px; \r\n    width:0;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-content .mfp-column .mfp-cell\r\n{\r\n    position: absolute;\r\n    left: 0;\r\n    right: 0;\r\n    top: 0;\r\n    bottom: 0;\r\n    z-index: 0;\r\n}\r\n\r\n.mfp-horizontal-timetable-view .mfp-content .mfp-column .mfp-item-cell\r\n{\r\n    position: relative;\r\n    height:100%;\r\n}\r\n.mfp-horizontal-timetable-view .mfp-cue > i\r\n{\r\n    transform: rotate(-45deg);\r\n    -webkit-transform: rotate(-45deg);\r\n}", undefined);

__$styleInject(".mfp-vertical-list-view \r\n{\r\n    border:1px solid; \r\n    background-color:#fff; \r\n}\r\n\r\n.mfp-vertical-list-view .mfp-bg-cell-header\r\n{\r\n    border-top:1px solid;\r\n    border-bottom:1px solid;\r\n}\r\n.mfp-vertical-list-view .mfp-header,\r\n.mfp-vertical-list-view .mfp-bg-cell:not(:last-child)\r\n{\r\n    border-right:1px solid;\r\n}\r\n.mfp-vertical-list-view > div:first-child\r\n{\r\n    position: relative;\r\n    display: flex;\r\n    flex-direction: column;\r\n\theight: 100%;\r\n}\r\n\r\n.mfp-vertical-list-view .mfp-scroller\r\n{\r\n    position: relative;\r\n    height: 100%;\r\n    width: 100%;\r\n    overflow-x: hidden;\r\n    overflow-y: auto;\r\n}\r\n.mfp-vertical-list-view .mfp-header-group\r\n{\r\n\twidth: 100%;\r\n    position: relative;\r\n    display: flex;\r\n    flex: 0 0 50px;\r\n}\r\n\r\n.mfp-vertical-list-view .mfp-header-group > div\r\n{\r\n    flex: 1 1 50%;\r\n    display: flex;\r\n    align-self: center;\r\n    justify-content: center;\r\n}\r\n\r\n.mfp-vertical-list-view .mfp-header-group > div:first-child{\r\n    flex: 0 0 50px;\r\n}\r\n\r\n.mfp-vertical-list-view .mfp-header-group > div:last-child{\r\n    flex: 0 0 17px;\r\n}\r\n.mfp-vertical-list-view .mfp-wrapper\r\n{\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n    display:flex;\r\n}\r\n/*main header*/\r\n.mfp-vertical-list-view .mfp-wrapper .mfp-header\r\n{\r\n    flex: 0 0 50px;\r\n    display: flex;\r\n    flex-direction: column;\r\n    position: relative;\r\n}\r\n.mfp-vertical-list-view .mfp-wrapper .mfp-header > div:not(.mfp-button-wrap)\r\n{\r\n    flex: 1 1 50%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: center;\r\n   /* writing-mode: vertical-rl; */\r\n    overflow: hidden;\r\n    white-space: nowrap;\r\n}\r\n.mfp-vertical-list-view .mfp-header .mfp-button-wrap\r\n{\r\n    position: absolute;\r\n    top:0px;\r\n    width:100%;\r\n    height: 100%;\r\n    z-index: 1;\r\n    text-align: center;\r\n}\r\n\r\n.mfp-vertical-list-view .mfp-header .mfp-button\r\n{\r\n    display: inline-block;\r\n    cursor: pointer;\r\n    font-size: xx-small;\r\n    padding:4px;\r\n}\r\n.mfp-vertical-list-view .mfp-header .mfp-button-prev\r\n{\r\n    order:-1; \r\n}\r\n.mfp-vertical-list-view  .mfp-header .mfp-button-prev > span::before\r\n{\r\n     content: '\\25b2';\r\n}\r\n.mfp-vertical-list-view .mfp-header .mfp-button-next\r\n{\r\n    order:2;\r\n    position: absolute;\r\n    left:50%;\r\n    bottom:0;\r\n    margin-left:-10px;\r\n}\r\n.mfp-vertical-list-view  .mfp-header .mfp-button-next > span::before\r\n{\r\n    content: '\\25bc';\r\n}\r\n/*content*/\r\n.mfp-vertical-list-view .mfp-wrapper .mfp-content\r\n{\r\n    width: 100%;\r\n    height: 100%;\r\n    overflow: hidden;\r\n    position: relative;\r\n}\r\n.mfp-vertical-list-view .mfp-wrapper .mfp-content .mfp-wrap\r\n{\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n.mfp-vertical-list-view .mfp-wrapper .mfp-content .mfp-wrap .mfp-bg-table\r\n{\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n    z-index: 0;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n.mfp-vertical-list-view .mfp-scroller .mfp-wrapper .mfp-content .mfp-wrap .mfp-bg-table .mfp-bg-row\r\n{\r\n    display:flex;\r\n    flex:1 1 0%;\r\n}\r\n\r\n.mfp-vertical-list-view .mfp-scroller .mfp-wrapper .mfp-content .mfp-wrap .mfp-bg-table .mfp-bg-cell\r\n{\r\n    flex:1 1 100%;\r\n    vertical-align: top;\r\n    text-align: center;\r\n}\r\n.mfp-vertical-list-view .mfp-scroller .mfp-wrapper .mfp-content .mfp-wrap .mfp-bg-table .mfp-bg-cell .mfp-bg-cell-header\r\n{\r\n    height:20px;\r\n}\r\n.mfp-vertical-list-view .mfp-wrapper .mfp-content .mfp-wrap .mfp-item-table\r\n{\r\n    left: 0;\r\n    position: absolute;\r\n    table-layout: fixed;\r\n    top: 0;\r\n    width: 100%;\r\n    z-index: 1;\r\n    height:100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n.mfp-vertical-list-view .mfp-scroller .mfp-wrapper .mfp-content .mfp-wrap .mfp-item-table .mfp-item-row\r\n{\r\n    flex:1 1 0%;\r\n\tposition: relative;\r\n}\r\n.mfp-vertical-list-view .mfp-scroller .mfp-wrapper .mfp-content .mfp-wrap .mfp-item-table .mfp-item-row .mfp-header-wrap\r\n{\r\n    height:20px;\r\n    display:flex;\r\n}\r\n.mfp-vertical-list-view .mfp-scroller .mfp-wrapper .mfp-content .mfp-wrap .mfp-item-table .mfp-item-row .mfp-cell-wrap\r\n{\r\n    display:flex;\r\n}\r\n.mfp-vertical-list-view .mfp-scroller .mfp-wrapper .mfp-content .mfp-wrap .mfp-item-table .mfp-item-row .mfp-header-wrap > div,\r\n.mfp-vertical-list-view .mfp-scroller .mfp-wrapper .mfp-content .mfp-wrap .mfp-item-table .mfp-item-row .mfp-cell-wrap > div\r\n{\r\n    flex: 1 1 100%;\r\n}\r\n.mfp-vertical-list-view .mfp-cue\r\n{\r\n    float:right;\r\n    margin-right:4px;\r\n}\r\n", undefined);

__$styleInject(".mfp-list-view \r\n{\r\n    border:1px solid;\r\n    background-color:#fff; \r\n}\r\n.mfp-list-view .mfp-bg-cell-header\r\n{\r\n    border-top:1px solid;\r\n    border-bottom:1px solid;\r\n}\r\n.mfp-list-view .mfp-header-group,\r\n.mfp-list-view .mfp-bg-cell:not(:last-child)\r\n{\r\n    border-right:1px solid;\r\n}\r\n\r\n.mfp-list-view > div:first-child\r\n{\r\n    position: relative;\r\n    display: flex;\r\n\theight: 100%;\r\n}\r\n\r\n.mfp-list-view .mfp-scroller\r\n{\r\n    position: relative;\r\n    height: 100%;\r\n    width: 100%;\r\n    overflow-x: auto;\r\n    overflow-y: hidden;\r\n    flex: 1 1 100%;\r\n}\r\n.mfp-list-view .mfp-header-group\r\n{\r\n\twidth: 100%;\r\n    position: relative;\r\n    display: flex;\r\n    flex-direction: column;\r\n    flex: 0 0 50px;\r\n}\r\n\r\n.mfp-list-view .mfp-header-group > div\r\n{\r\n    flex: 1 1 50%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: center;\r\n    /*writing-mode: vertical-rl;*/\r\n    overflow: hidden;\r\n    white-space: nowrap;\r\n}\r\n\r\n.mfp-list-view .mfp-header-group > div:first-child{\r\n    flex: 0 0 50px;\r\n}\r\n\r\n.mfp-list-view .mfp-header-group > div:last-child{\r\n    flex: 0 0 17px;\r\n}\r\n\r\n.mfp-list-view .mfp-wrapper\r\n{\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n    display:flex;\r\n    flex-direction: column;\r\n}\r\n/*main header*/\r\n.mfp-list-view .mfp-wrapper .mfp-header\r\n{\r\n    position: relative;\r\n    flex: 0 0 50px;\r\n    display: flex;\r\n}\r\n\r\n.mfp-list-view .mfp-wrapper .mfp-header > div:not(.mfp-button-wrap)\r\n{\r\n    flex: 1 1 50%;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n.mfp-list-view .mfp-header .mfp-button-wrap\r\n{\r\n    position: absolute;\r\n    left:0px;\r\n    width:100%;\r\n    height: 100%;\r\n    z-index: 1;\r\n    text-align: center;\r\n}\r\n\r\n.mfp-list-view .mfp-header .mfp-button\r\n{\r\n    position: absolute;\r\n    display: inline-block;\r\n    cursor: pointer;\r\n    font-size: xx-small;\r\n    top:50%;\r\n    margin-top:-10px;\r\n    padding:4px;\r\n}\r\n.mfp-list-view .mfp-header .mfp-button-prev\r\n{\r\n    order:-1;\r\n    left:10px;\r\n}\r\n\r\n.mfp-list-view .mfp-header .mfp-button-next\r\n{\r\n    order:2;\r\n    right:10px;\r\n}\r\n.mfp-list-view .mfp-header .mfp-button-prev > span::before\r\n{\r\n     content: '\\25c4';\r\n}\r\n\r\n.mfp-list-view .mfp-header .mfp-button-next > span::before\r\n{\r\n    content: '\\25ba';\r\n}\r\n\r\n\r\n/*content*/\r\n.mfp-list-view .mfp-wrapper .mfp-content\r\n{\r\n    width: 100%;\r\n    height: 100%;\r\n    overflow: hidden;\r\n    position: relative;\r\n}\r\n.mfp-list-view .mfp-wrapper .mfp-content .mfp-wrap\r\n{\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n\r\n.mfp-list-view .mfp-content .mfp-wrap .mfp-bg-row\r\n{\r\n    position:relative;\r\n    z-index:0;\r\n    width:100%;\r\n    height:100%;\r\n    display:flex;\r\n    flex-direction: row;\r\n    justify-content: space-around;\r\n    text-align: center;\r\n}\r\n\r\n.mfp-list-view .mfp-content .mfp-wrap .mfp-bg-row .mfp-bg-cell\r\n{\r\n    vertical-align: top;\r\n    flex:1;\r\n    overflow: hidden;\r\n}\r\n\r\n.mfp-list-view .mfp-content .mfp-wrap .mfp-bg-row .mfp-bg-cell .mfp-bg-cell-header\r\n{\r\n    white-space: nowrap;\r\n    height:20px;\r\n}\r\n.mfp-list-view .mfp-wrapper .mfp-content .mfp-wrap .mfp-item-table\r\n{\r\n    left: 0;\r\n    position: absolute;\r\n    table-layout: fixed;\r\n    top: 0;\r\n    width: 100%;\r\n    z-index: 1;\r\n}\r\n.mfp-list-view .mfp-wrapper .mfp-content .mfp-wrap .mfp-item-table .mfp-cell-header\r\n{\r\n    height:20px;\r\n}", undefined);

__$styleInject(".mfp-week-view \r\n{\r\n    border: 1px solid;\r\n    background-color: #fff;\r\n}\r\n.mfp-week-view .mfp-header-weekdays\r\n{\r\n    border-top:1px solid;\r\n}\r\n.mfp-week-view .mfp-bg-cell-header,\r\n.mfp-week-view .mfp-item-table .mfp-cell-header\r\n{\r\n    border-top:1px solid;\r\n    border-bottom:1px solid;\r\n}\r\n.mfp-week-view .mfp-item-table .mfp-cell-header\r\n{\r\n    border-color: transparent;\r\n}\r\n.mfp-week-view .mfp-bg-cell:not(:last-child)\r\n{\r\n    border-right:1px solid;\r\n}\r\n.mfp-week-view > div:first-child\r\n{\r\n    position: relative;\r\n    display: flex;\r\n    flex-direction: column;\r\n\theight: 100%;\r\n}\r\n\r\n.mfp-week-view .mfp-header\r\n{\r\n    flex: 0 0 auto;\r\n    flex-direction: column;\r\n}\r\n\r\n.mfp-week-view .mfp-header .mfp-title\r\n{\r\n    text-align: center;\r\n    display: flex;\r\n    justify-content: space-between;\r\n}\r\n\r\n.mfp-week-view .mfp-header .mfp-title .mfp-link\r\n{\r\n    order:0;\r\n    display: inline-block;\r\n    width:100%;\r\n}\r\n\r\n.mfp-week-view .mfp-header .mfp-title .mfp-button-prev\r\n{\r\n    order:-1;\r\n    display: inline-block;\r\n}\r\n\r\n.mfp-week-view .mfp-header .mfp-title .mfp-button-next\r\n{\r\n    order:2;\r\n    display: inline-block;\r\n}\r\n\r\n.mfp-week-view .mfp-header .mfp-header-weekdays\r\n{\r\n    position:relative;\r\n    z-index:0;\r\n    width:100%;\r\n  /*  height:100%;*/\r\n    display:flex;\r\n    flex-direction: row;\r\n}\r\n.mfp-week-view .mfp-header-weeknumbers\r\n{\r\n    flex: 0 0 30px;\r\n}\r\n.mfp-week-view .mfp-header-weeknumbers .mfp-weeknumbers\r\n{\r\n    width:100%;\r\n    height:100%;\r\n    table-layout: fixed;\r\n}\r\n.mfp-week-view .mfp-header .mfp-header-weekdays .mfp-weekdays-wrap\r\n{\r\n    width:100%;\r\n    display:flex;\r\n    flex-direction: row;\r\n    text-align: center;\r\n}\r\n.mfp-week-view .mfp-header .mfp-header-weekdays .mfp-weekdays-wrap > div\r\n{\r\n    flex:1 1 0%;\r\n}\r\n.mfp-week-view  .mfp-header .mfp-scrollfix\r\n{\r\n    width: 17px;\r\n}\r\n\r\n/*content*/\r\n\r\n.mfp-week-view .mfp-content\r\n{\r\n    width: 100%;\r\n    height: 100%;\r\n    overflow: hidden;\r\n    position: relative;\r\n}\r\n.mfp-week-view .mfp-content .mfp-wrap\r\n{\r\n    left: 0;\r\n    position: absolute;\r\n    top: 0;\r\n    width: 100%;\r\n    z-index: 1;\r\n    height:100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n.mfp-week-view .mfp-content .mfp-wrap .mfp-week\r\n{\r\n    flex:1;\r\n\tposition:relative;\r\n}\r\n.mfp-week-view .mfp-content .mfp-wrap .mfp-bg-row\r\n{\r\n    position:relative;\r\n    z-index:0;\r\n    width:100%;\r\n    height:100%;\r\n    display:flex;\r\n    flex-direction: row;\r\n    text-align: center;\r\n}\r\n.mfp-week-view .mfp-content .mfp-wrap .mfp-bg-row .mfp-bg-cell\r\n{\r\n    vertical-align: top;\r\n    flex:1;\r\n    overflow: hidden;\r\n}\r\n.mfp-week-view .mfp-content .mfp-wrap .mfp-bg-row .mfp-bg-cell .mfp-bg-cell-header\r\n{\r\n    white-space: nowrap;\r\n}\r\n\r\n\r\n.mfp-week-view .mfp-content .mfp-wrap .mfp-item-table\r\n{\r\n    left: 0;\r\n    position: absolute;\r\n    table-layout: fixed;\r\n    top: 0;\r\n    width: 100%;\r\n    z-index: 1;\r\n}\r\n\r\n.mfp-week-view .mfp-content .mfp-wrap .mfp-item-table td\r\n{\r\n    vertical-align: top;\r\n}", undefined);

__$styleInject(".mfp-resource-view\r\n{\r\n    border:1px solid;\r\n    background-color:#fff;\r\n}\r\n.mfp-resource-view .mfp-header,\r\n.mfp-resource-view .mfp-lane-row\r\n{\r\n    border-bottom:1px solid;\r\n}\r\n.mfp-resource-view .mfp-header-group\r\n{\r\n    border-right:1px solid;\r\n}\r\n\r\n.mfp-resource-view > div:first-child\r\n{\r\n    position: relative;\r\n    height: 100%;\r\n    width: 100%;\r\n    overflow: hidden;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n.mfp-resource-view .mfp-header\r\n{\r\n\twidth: 100%;\r\n    position: relative;\r\n    display: flex;\r\n    flex: 0 0 auto;\r\n}\r\n.mfp-resource-view .mfp-header > div:first-child\r\n{\r\n     flex: 0 0 50px;\r\n     background: inherit;\r\n     z-index: 3;\r\n}\r\n.mfp-resource-view .mfp-header .mfp-header-timeline\r\n{\r\n    position: relative;\r\n    z-index: 1;\r\n}\r\n\r\n.mfp-resource-view .mfp-header .mfp-timeline\r\n{\r\n    width:100%;\r\n    display: table;\r\n}\r\n\r\n.mfp-resource-view .mfp-header .mfp-timeline > div \r\n{\r\n    overflow: hidden;\r\n    display: table-cell;\r\n}\r\n\r\n.mfp-resource-view .mfp-header .mfp-timeline > div > span\r\n{\r\n    position: relative;\r\n    white-space: nowrap;\r\n}\r\n\r\n.mfp-resource-view .mfp-header-group\r\n{\r\n    flex: 0 0 50px;\r\n    white-space: nowrap;\r\n    overflow: hidden;\r\n}\r\n\r\n.mfp-resource-view .mfp-header-group-wrap\r\n{\r\n    position: relative;\r\n}\r\n\r\n.mfp-resource-view .mfp-header-group-wrap > div\r\n{\r\n    display: flex;\r\n    align-items: center;\r\n}\r\n\r\n.mfp-resource-view .mfp-wrapper\r\n{\r\n    display: flex;\r\n    flex: 1 1 100%;\r\n    overflow: hidden;\r\n}\r\n\r\n.mfp-resource-view .mfp-content\r\n{\r\n    overflow:auto;\r\n    position: relative;\r\n    flex: 1 1 100%;\r\n}\r\n\r\n.mfp-resource-view .mfp-wrapper .mfp-content-wrap\r\n{\r\n    overflow:hidden;\r\n    position: relative;\r\n    flex: 1 1 100%;\r\n   /* display:flex;\r\n    flex-direction: column;*/\r\n}\r\n\r\n.mfp-resource-view .mfp-wrapper .mfp-content .mfp-wrap\r\n{\r\n    position: relative;\r\n}\r\n.mfp-resource-view .mfp-content .mfp-wrap .mfp-bg-row\r\n{\r\n    position:absolute;\r\n\tleft: 0;\r\n\ttop: 0;\r\n    z-index:0;\r\n    width:100%;\r\n    height:100%;\r\n    display:flex;\r\n    justify-content: space-around;\r\n    text-align: center;\r\n}\r\n\r\n.mfp-resource-view .mfp-content .mfp-wrap .mfp-bg-row .mfp-bg-cell\r\n{\r\n    vertical-align: top;\r\n    flex:1;\r\n    overflow: hidden;\r\n}\r\n\r\n.mfp-resource-view .mfp-wrapper .mfp-content .mfp-wrap .mfp-item-table\r\n{\r\n    left: 0;\r\n\ttop: 0;\r\n    width: 100%;\r\n    table-layout: fixed;\r\n    position: absolute;\r\n    z-index: 2;\r\n}\r\n.mfp-resource-view .mfp-wrapper .mfp-content .mfp-wrap .mfp-lane-table\r\n{\r\n    width: 100%;\r\n    table-layout: fixed;\r\n    position: relative;\r\n    z-index: 1;\r\n}", undefined);

__$styleInject(".mfp-item-container\r\n{\r\n    overflow: hidden;\r\n    cursor: pointer;\r\n    z-index: 5;\r\n    box-sizing: border-box;\r\n}\r\n.mfp-item-vertical\r\n{\r\n    position: relative;\r\n    height:100%;\r\n}\r\n.mfp-item-vertical-detail\r\n{\r\n    position: absolute;\r\n}\r\n.mfp-item\r\n{\r\n    display:flex;\r\n    height:100%;\r\n    /*override*/ border:1px solid; \r\n    /*override*/ background-color:#fff;\r\n    /*override*/ font-size: small;\r\n}\r\n.mfp-item-vertical .mfp-item\r\n{\r\n    position: relative;\r\n    flex-direction: column;\r\n}\r\n.mfp-item .mfp-subject\r\n{\r\n    flex: 1 1 100%;\r\n    order:0;\r\n    overflow:hidden;\r\n}\r\n\r\n.mfp-item .mfp-arrow\r\n{\r\n    flex: 0 0 10px;\r\n}\r\n\r\n.mfp-item .mfp-arrow.mfp-prev\r\n{\r\n    order: -1;\r\n}\r\n\r\n.mfp-item .mfp-arrow.mfp-next\r\n{\r\n    order: 1;\r\n}\r\n\r\n.mfp-item .mfp-resize-start\r\n{\r\n    order: -10;\r\n    cursor: w-resize;\r\n    flex: 0 1 auto;   \r\n}\r\n\r\n.mfp-item .mfp-resize-end\r\n{\r\n    order: 10;\r\n    cursor: w-resize;\r\n    flex: 0 1 auto;\r\n}\r\n\r\n.mfp-item-vertical .mfp-subject \r\n{\r\n\ttext-orientation: mixed;\r\n    writing-mode: vertical-rl;\r\n}\r\n\r\n.mfp-item-vertical-detail .mfp-item-outwrap\r\n{\r\n    display: flex;\r\n    width:100%;\r\n}\r\n\r\n.mfp-item-vertical-detail .mfp-time-indicator-wrapper,\r\n.mfp-item-horizontal-detail .mfp-time-indicator-wrapper\r\n{\r\n    flex: 0 0 4px;  \r\n    position: relative;\r\n}\r\n\r\n.mfp-item-vertical-detail .mfp-time-indicator,\r\n.mfp-item-horizontal-detail .mfp-time-indicator\r\n{\r\n    position: absolute;\r\n    left:0;\r\n    background-color: #000;\r\n}\r\n.mfp-item-vertical-detail .mfp-time-indicator\r\n{\r\n    width:100%;\r\n}\r\n.mfp-item-horizontal-detail .mfp-time-indicator\r\n{\r\n    height:100%;\r\n}\r\n.mfp-item-vertical-detail .mfp-item-inwrap\r\n{\r\n    flex: 1 1 auto;\r\n    display: flex;\r\n    flex-direction: column;\r\n    overflow:hidden;\r\n}\r\n\r\n.mfp-item-vertical-detail .mfp-subject \r\n{\r\n    flex: 0 1 auto;\r\n    overflow: hidden;\r\n}\r\n\r\n.mfp-item-vertical-detail .mfp-details\r\n{\r\n    flex: 1 1 auto;\r\n    overflow: hidden;\r\n}\r\n\r\n\r\n/**/\r\n.mfp-item-horizontal-detail\r\n{\r\n    position: relative;\r\n}\r\n.mfp-item-horizontal-detail .mfp-item\r\n{\r\n    flex-direction: column;\r\n}\r\n.mfp-item-horizontal-detail .mfp-item-outwrap\r\n{\r\n    display: flex;\r\n    width:100%;\r\n}\r\n.mfp-item-horizontal-detail .mfp-item-inwrap\r\n{\r\n    flex: 1 1 auto;\r\n    display: flex;\r\n    overflow:hidden;\r\n}\r\n\r\n.mfp-item-horizontal-detail .mfp-subject \r\n{\r\n    flex: 0 1 auto;\r\n    overflow: hidden;\r\n}\r\n\r\n.mfp-item-horizontal-detail .mfp-details\r\n{\r\n    flex: 1 1 auto;\r\n    overflow: hidden;\r\n}\r\n\r\n/**/\r\n/* .mfp-item .mfp-resize-start,\r\n.mfp-item .mfp-resize-end\r\n{\r\n    flex: 0 1 auto;\r\n} */\r\n\r\n.mfp-item-horizontal .mfp-resize-start,\r\n.mfp-item-horizontal .mfp-resize-end,\r\n.mfp-item-horizontal-detail .mfp-resize-start,\r\n.mfp-item-horizontal-detail .mfp-resize-end\r\n{\r\n    width:8px;\r\n    cursor: w-resize;\r\n}\r\n\r\n.mfp-item-horizontal .mfp-resize-start,\r\n.mfp-item-horizontal-detail .mfp-resize-start\r\n{\r\n    border-right: 4px double black;\r\n    margin-right:2px;\r\n}\r\n\r\n.mfp-item-horizontal .mfp-resize-end,\r\n.mfp-item-horizontal-detail .mfp-resize-end\r\n{\r\n    border-left: 4px double black;\r\n    margin-left:2px;\r\n}\r\n\r\n.mfp-item-vertical .mfp-resize-start,\r\n.mfp-item-vertical .mfp-resize-end,\r\n.mfp-item-vertical-detail .mfp-resize-start,\r\n.mfp-item-vertical-detail .mfp-resize-end\r\n{\r\n    height:8px;\r\n    cursor: n-resize;\r\n}\r\n\r\n.mfp-item-vertical .mfp-resize-start,\r\n.mfp-item-vertical-detail .mfp-resize-start\r\n{\r\n    border-bottom: 4px double black;\r\n}\r\n\r\n.mfp-item-vertical .mfp-resize-end,\r\n.mfp-item-vertical-detail .mfp-resize-end\r\n{\r\n    border-top: 4px double black;\r\n}\r\n\r\n.mfp-item .mfp-arrow\r\n{\r\n    font-size:xx-small;\r\n    text-align: center;\r\n    margin:1px;\r\n}\r\n.mfp-item .mfp-arrow.mfp-prev > span::before\r\n{\r\n     content: '\\25c4';\r\n}\r\n\r\n.mfp-item-vertical .mfp-arrow.mfp-prev > span::before\r\n{\r\n    content: '\\25b2';  \r\n}\r\n\r\n.mfp-item .mfp-arrow.mfp-next > span::before\r\n{\r\n    content: '\\25ba';\r\n}\r\n\r\n.mfp-item-vertical .mfp-arrow.mfp-next > span::before\r\n{\r\n    content: '\\25bc';\r\n}\r\n\r\n.mfp-item .mfp-icons\r\n{\r\n    font-size: xx-small;\r\n}\r\n.mfp-inplace\r\n{\r\n    color: initial;\r\n    width: 98%;\r\n    position: relative;\r\n    z-index: 1;\r\n    vertical-align: top;\r\n    font-size: smaller;\r\n}\r\n.mfp-item-vertical .mfp-inplace,\r\n.mfp-item-vertical-detail .mfp-inplace\r\n{\r\n    height:100%;\r\n}\r\n", undefined);

__$styleInject(".mfp-popup\r\n{\r\n    position: absolute;\r\n    z-index: 8000;\r\n    left: 0;\r\n    top: 0;\r\n    overflow: visible;\r\n    cursor: default;\r\n    user-select: none;\r\n}\r\n\r\n.mfp-popup a\r\n{\r\n    cursor:pointer;\r\n}\r\n\r\n.mfp-popup .mfp-popup-header a.mfp-close-button\r\n{\r\n    z-index: 10;\r\n    cursor: pointer;\r\n    float: right;\r\n    margin-right:4px;\r\n}\r\n\r\n.mfp-popup-row\r\n{\r\n    display: flex;\r\n    align-items: center;\r\n    margin-top:5px;\r\n}\r\n\r\n.mfp-popup-column\r\n{\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n.mfp-popup .mfp-buttons-row\r\n{\r\n    justify-content: center;\r\n}\r\n\r\n.mfp-popup .mfp-popup-content .mfp-buttons-row a.mfp-button\r\n{\r\n    display: inline-block;\r\n    position: relative;\r\n    text-align: center;\r\n    width: 92px;\r\n    height: 24px;\r\n    line-height: 24px;\r\n    margin: 0 5px;\r\n}\r\n\r\n.mfp-popup .mfp-popup-content .mfp-text-area\r\n{\r\n    overflow: auto;\r\n    vertical-align: top;\r\n    user-select: all;\r\n    resize: none;\r\n}\r\n.mfp-popup .mfp-popup-content label\r\n{\r\n    vertical-align: middle;\r\n    margin-left: 3px;\r\n    margin-right: 6px;\r\n}\r\n.mfp-popup .mfp-popup-content .mfp-checkbox-list\r\n{\r\n    display: inline-block;\r\n    width: 200px;\r\n    height: 100px;\r\n    overflow: auto;\r\n}\r\n\r\n.mfp-popup .mfp-popup-content .mfp-text-area, \r\n.mfp-popup .mfp-popup-content .mfp-text-box, \r\n.mfp-popup .mfp-popup-content .mfp-dropDown-list,\r\n.mfp-popup .mfp-popup-content .mfp-checkbox-list\r\n{\r\n    box-sizing: border-box;\r\n}\r\n\r\n.mfp-popup .mfp-popup-content .mfp-edit-box\r\n{\r\n    display: inline;\r\n    margin-right: 8px;\r\n}\r\n\r\n.mfp-popup .mfp-popup-content .mfp-numeric-box\r\n{\r\n    display: inline-block;\r\n    vertical-align: middle;\r\n}\r\n.mfp-popup .mfp-popup-content .mfp-numeric-box a\r\n{\r\n    display: block;\r\n    width: 7px;\r\n    height: 9px;\r\n    line-height:9px;\r\n    margin-left: 3px;\r\n}\r\n.mfp-popup-content .mfp-text-label\r\n{\r\n    display: inline-block;\r\n    padding-right: 5px;\r\n}\r\n\r\n.mfp-popup-content .mfp-text-label-fixed\r\n{\r\n    width: 64px;\r\n    display: inline-block;\r\n    padding-left: 2px;\r\n}\r\n\r\n.mfp-popup .mfp-popup-content .mfp-dropdown-button > i\r\n{\r\n    border: solid black;\r\n    border-width: 0 1px 1px 0;\r\n    display: inline-block;\r\n    padding: 2px;\r\n    transform: rotate(-45deg);\r\n    -webkit-transform: rotate(-45deg);\r\n}\r\n\r\n.mfp-popup .mfp-popup-content .mfp-buttonup > i\r\n{\r\n    border: solid black;\r\n    border-width: 0 1px 1px 0;\r\n    display: inline-block;\r\n    padding: 2px;\r\n    transform: rotate(-135deg);\r\n    -webkit-transform: rotate(-135deg);\r\n}\r\n\r\n.mfp-popup .mfp-popup-content .mfp-buttondown > i\r\n{\r\n    border: solid black;\r\n    border-width: 0 1px 1px 0;\r\n    display: inline-block;\r\n    padding: 2px;\r\n    transform: rotate(45deg);\r\n    -webkit-transform: rotate(45deg);\r\n}\r\n\r\n.mfp-popup .mfp-dtpicker\r\n{\r\n    position: absolute;\r\n    text-align: center;\r\n    z-index: 5000;\r\n    top: 0;\r\n    left: 0;\r\n}\r\n\r\n.mfp-popup .mfp-dtpicker .mfp-dtpicker-header,\r\n.mfp-popup .mfp-dtpicker .mfp-dtpicker-footer\r\n{\r\n    white-space: nowrap;\r\n    display: flex;\r\n    justify-content: space-around;\r\n    padding:5px;\r\n}\r\n\r\n.mfp-popup .mfp-dtpicker .mfp-dtpicker-content\r\n{\r\n    width:100%;\r\n    table-layout: fixed;\r\n    white-space: nowrap;\r\n}\r\n\r\n.mfp-popup .mfp-dtpicker .mfp-button\r\n{\r\n    cursor: pointer;\r\n}\r\n\r\n/*overrides*/\r\n.mfp-popup\r\n{\r\n    background: #fff;\r\n    border:1px solid;\r\n}\r\n\r\n.mfp-popup .mfp-popup-header\r\n{\r\n    padding:4px;\r\n    border-bottom:1px solid;\r\n}\r\n\r\n.mfp-popup .mfp-popup-header a.mfp-close-button:before\r\n{\r\n    content: 'x';\r\n}\r\n\r\n.mfp-popup:not(.mfp-cue-popup) .mfp-popup-content\r\n{\r\n   margin:10px;\r\n}\r\n\r\n.mfp-popup a.mfp-button\r\n{\r\n    margin: 0 5px;\r\n}\r\n.mfp-popup .mfp-popup-content .mfp-text-area, \r\n.mfp-popup .mfp-popup-content .mfp-text-box, \r\n.mfp-popup .mfp-popup-content .mfp-dropDown-list,\r\n.mfp-popup .mfp-popup-content .mfp-checkbox-list\r\n{\r\n    font-family: inherit;\r\n}\r\n.mfp-popup .mfp-popup-content .mfp-check-box\r\n{\r\n    vertical-align: middle;\r\n}\r\n.mfp-popup .mfp-popup-content label\r\n{\r\n    vertical-align: middle;\r\n    margin-left: 3px;\r\n    margin-right: 6px;\r\n}\r\n.mfp-popup .mfp-popup-content .mfp-hr-line\r\n{\r\n    border-bottom: 1px solid;\r\n    margin: 0 0 8px 0;\r\n    padding: 0 0 8px 0;\r\n}\r\n.mfp-popup .mfp-popup-content .mfp-checkbox-list\r\n{\r\n    display: inline-block;\r\n    width: 200px;\r\n    height: 100px;\r\n    overflow: auto;\r\n}\r\n.mfp-popup .mfp-popup-content .mfp-checkbox-list .mfp-checkbox-item\r\n{\r\n    padding: 0 2px;\r\n}\r\n.mfp-popup .mfp-popup-content .mfp-edit-box\r\n{\r\n    display: inline;\r\n    margin-right: 8px;\r\n}\r\n.mfp-popup .mfp-popup-content .mfp-numeric-box a\r\n{\r\n    display: block;\r\n    margin-left: 3px;\r\n}\r\n.mfp-popup .mfp-dtpicker\r\n{\r\n    background-color: #fff;\r\n    border:1px solid;\r\n}\r\n.mfp-popup .mfp-dtpicker .mfp-dtpicker-content td\r\n{\r\n    padding: 3px;\r\n}\r\n.mfp-popup .mfp-dtpicker .mfp-dtpicker-content td.mfp-dtp-selected\r\n{\r\n    border: solid 1px;\r\n}\r\n.mfp-popup .mfp-dtpicker .mfp-dtpicker-content td:hover\r\n{\r\n    background-color: #ddd;\r\n}\r\n", undefined);

/** 
* @namespace MindFusion.Scheduling
*/

/**
 * Copyright (c) 2017-2018, MindFusion LLC - Bulgaria.
 *
 * This source code is provided to you as part of the MindFusion software components
 * package you have purchased. You may use the source code to trace and/or fix
 * problems or customize the library as needed for your application. To get permission
 * to use the source code in any other way, please contact us at support@mindfusion.eu.
 */

/**
* @class The Calendar control serves as a view in document-view
* architecture, where the document is implemented by the
* Schedule class. The Calendar provides several schedule
* related views, such as Month, List, Timetable, that
* present the scheduled events in different styles and layouts.
* @property {DomElement} element Gets a reference to the calendar DOM element.
* @property {DomElement} header Gets a reference to the DOM element of the calendar main header.
* @property {ObservableCollection} cells Gets the collection of cells in the calendar view.
* @property {DateTime} date Gets or sets the date of the calendar.
* @property {DateTime} endDate Gets or sets the end date of the calendar.
* @property {DateTime} startTime Gets the start time of the first visible cell of the calendar.
* @property {DateTime} endTime Gets the end time of the last visible cell of the calendar.
* @property {DateTime} itemsStartTime Gets the start time of the first cell of the calendar, which can contain items.
* @property {DateTime} itemsEndTime Gets the end time of the last cell of the calendar, which can contain items.
* @property {ObservableCollection} tasks Gets the tasks whose schedule to display when the GroupType property is set to GroupByTasks or FilterByTasks.
* @property {ObservableCollection} contacts Gets the contacts whose schedule to display when the GroupType property is set to GroupByContacts or FilterByContacts.
* @property {ObservableCollection} resources Gets the resources whose schedule to display when the GroupType property is set to GroupByResources or FilterByResources.
* @property {ObservableCollection} locations Gets the locations whose schedule to display when the GroupType property is set to GroupByLocations or FilterByLocations.
* @property {String} cssClass Gets or sets the css class of the calendar.
* @property {Boolean} enabled Gets or sets a value indicating whether user interactions are allowed in the calendar.
* @property {CalendarView} currentView Gets or sets the type of the current view of the calendar.
* @property {String} theme  Gets or sets the current theme of the calendar.
* @property {GroupType} groupType Gets or sets the grouping or filtering criteria for the calendar.
* @property {Boolean} allowInplaceEdit Gets or sets a value indicating whether calendar's items can be inplace-edited.
* @property {Boolean} useForms Gets or sets a value indicating whether the built-in forms for item editing will be used.
* @property {Boolean} showTooltips Gets or sets a value indicating whether to show tooltips.
* @property {String} contactNameFormat Gets or sets a value indicating how to format and display contact names in view headers.
* @property {Schedule} schedule Gets or sets the schedule to be displayed inside the calendar.
* @property {Selection} selection Gets the current calendar selection.
* @property {ObservableCollection} itemSelection Gets the list of currently selected items.
* @property {MonthSettings} monthSettings Gets the MonthSettings object used to customize the appearance of the SingleMonth view.
* @property {TimetableSettings} timetableSettings Gets the TimetableSettings object used to customize the appearance of the Timetable view.
* @property {ListSettings} listSettings Gets the ListSettings object used to customize the appearance of the List view.
* @property {WeekRangeSettings} weekRangeSettings Gets the WeekRangeSettings object used to customize the appearance of the WeekRange view.
* @property {ResourceViewSettings} resourceViewSettings Gets the ResourceViewSettings object used to customize the appearance of the Resource view.
* @property {MonthRangeSettings} monthRangeSettings Gets the MonthRangeSettings object used to customize the appearance of the MonthRange view.
* @property {ItemSettings} itemSettings Gets the ItemSettings object used to customize the appearance of calendar items.
* @property {Object} locale Gets or sets the locale object used to format and display localizable information in the calendar.
* @property {Object} formatInfo Gets the locale object used to format and display date and time information in the calendar.
* @property {Object} localInfo Gets the locale object used to format and display localizable strings in the calendar.
* @property {String} licenseLocation Gets or sets the URL of the calendar's license file.
*/
var Calendar = function () {

	/**
  * Initializes a new instance of the Calendar class.
  * @constructor
  * @param {DomElement} element The element this Calendar is associated with.
  */
	function Calendar(element) {
		var _this = this;

		classCallCheck(this, Calendar);


		if (element) this._element = element;else {
			this._element = document.createElement("div");
			this._element.id = "MFP" + IdGenerator.generate("");
		}

		this._view = null;
		this._date = DateTime.today();

		this._contacts = new ObservableCollection();
		this._contacts.collectionChanged.addEventListener(function () {
			_this.onCollectionChanged();
		});
		this._locations = new ObservableCollection();
		this._locations.collectionChanged.addEventListener(function () {
			_this.onCollectionChanged();
		});
		this._tasks = new ObservableCollection();
		this._tasks.collectionChanged.addEventListener(function () {
			_this.onCollectionChanged();
		});
		this._resources = new ObservableCollection();
		this._resources.collectionChanged.addEventListener(function () {
			_this.onCollectionChanged();
		});

		this._enabled = true;
		this._currentView = CalendarView.SingleMonth;
		this._allowInplaceEdit = true;
		this._useForms = true;
		this._showTooltips = true;
		this._itemCloneKey = Keys.Shift;
		this._itemChangeResourceKey = Keys.Control;
		this._licenseLocation = "";
		this._contactNameFormat = "F M L";

		this._scheduleChangedHandler = function (e) {
			_this.onScheduleChanged(e);
		};
		this.schedule = new Schedule();

		this._selection = new Selection(this);

		this._itemSelection = new ObservableCollection();
		this._itemSelection.collectionChanged.addEventListener(function (sender, args) {
			_this.onItemSelectionChanged(sender, args);
		});

		this._popups = new Dictionary();

		// Events
		this._calendarLoad = new EventDispatcher();
		this._visibleDateChanged = new EventDispatcher();

		this._itemCreating = new EventDispatcher();
		this._itemCreated = new EventDispatcher();
		this._itemModifying = new EventDispatcher();
		this._itemModified = new EventDispatcher();
		this._itemDeleting = new EventDispatcher();
		this._itemDeleted = new EventDispatcher();
		this._recurringItemDeleting = new EventDispatcher();
		this._itemInplaceEditStart = new EventDispatcher();
		this._itemInplaceEditEnd = new EventDispatcher();

		this._itemReminderTriggered = new EventDispatcher();
		this._taskReminderTriggered = new EventDispatcher();

		this._itemDragStart = new EventDispatcher();
		this._itemDragEnd = new EventDispatcher();
		this._itemResizeStart = new EventDispatcher();
		this._itemResizeEnd = new EventDispatcher();

		this._itemClick = new EventDispatcher();
		this._itemDoubleClick = new EventDispatcher();

		this._selectionStart = new EventDispatcher();
		this._selectionChanged = new EventDispatcher();
		this._selectionEnd = new EventDispatcher();

		this._itemSelectionChanged = new EventDispatcher();

		this._cellClick = new EventDispatcher();
		this._cellDoubleClick = new EventDispatcher();
		this._headerClick = new EventDispatcher();
		this._headerDoubleClick = new EventDispatcher();

		this._cueClick = new EventDispatcher();
		this._buttonClick = new EventDispatcher();

		this._formShow = new EventDispatcher();
		this._formClose = new EventDispatcher();

		this._propertyChanged = new EventDispatcher();

		var Messenger = function () {
			var licenseKey = null;
			var start, startXhr;
			var d = null,
			    dm = null,
			    ns;
			var rd = new Date(2017, 11, 20); // year, month, day
			var f,
			    dt,
			    checked = false,
			    nowait = false;
			var dec = String.fromCharCode;

			if (!start) start = new Date().getTime();

			function drawMessage(calendar) {
				if (!d && new Date().getTime() - start > 8000) {
					d = Calendar;
				}
				if (!d) return;

				if (req(calendar)) return;

				dm = dec.apply(undefined, Item.tm);
				ns = dm == 0 ? "" : d.ns;

				var h = calendar.view.getHeader();
				if (h) {
					h.innerHTML = ns + dm;
					calendar.timetableSettings._showDayHeader = false;
					calendar.view.getDimensions();
				}
			}

			function logMeInConsole() {
				return String.fromCharCode.apply(undefined, [77, 105, 110, 100, 70, 117, 115, 105, 111, 110, 46, 83, 99, 104, 101, 100, 117, 108, 105, 110, 103, 32, 108, 105, 99, 101, 110, 115, 101, 100, 32, 116, 111, 32]);
			}
			function ab2str(buf) {
				return String.fromCharCode.apply(null, new Uint16Array(buf));
			}
			function str2ab(str) {
				var buf = new ArrayBuffer(str.length * 2);
				var bufView = new Uint16Array(buf);
				for (var i = 0, strLen = str.length; i < strLen; i++) {
					bufView[i] = str.charCodeAt(i);
				}
				return buf;
			}
			function req(calendar) {
				var lc = function lc(content) {
					var cb = new Uint16Array(str2ab(decodeURIComponent(atob(content)))),
					    cc_1 = new Uint16Array(cb.length);
					for (var i = 0; i < cb.length; i++) {
						var v = cb[i];
						cc_1[i] = ~(v ^ ~"73") ^ 42;
					}
					var strl = ab2str(cc_1.buffer);
					var flag1 = false,
					    flag2 = false;
					var a1 = "",
					    a2 = "";
					for (var strli = 0; strli < strl.length; strli++) {
						if (!flag1) {
							if (strl[strli] == '.') {
								flag1 = true;
								continue;
							}
							a1 += strl[strli];
							continue;
						}
						if (!flag2) {
							if (strl[strli] == '.') {
								flag2 = true;
								continue;
							}
							a2 += strl[strli];
							continue;
						}
						break;
					}
					var c1 = "",
					    c2 = "";
					strl = strl.substr(a1.length + a2.length + 2);
					a1 = parseInt(a1);
					a2 = parseInt(a2);
					for (var arg = 0; arg < a1; ++arg) {
						if (arg <= a2) c1 += strl[arg * 2];else c1 += strl[a2 * 2 + (arg - a2)];
					}
					for (var arg = 0; arg < a2; ++arg) {
						if (arg < a1) c2 += strl[1 + arg * 2];else c2 += strl[a1 * 2 + (arg - a1)];
					}
					var cj_1 = [c1, c2];
					var expDate = cj_1[0].substr(2, 4) + "-" + cj_1[0].substr(6, 2) + "-" + cj_1[0].substr(8, 2);
					f = cj_1[0].substr(17) == "jsplanner" && rd.getTime() <= new Date(expDate).getTime() || "jspack" && rd.getTime() <= new Date(expDate).getTime();
					if (f) console.log("" + logMeInConsole() + cj_1[1] + ".");
				};
				if (!checked) {
					checked = true;
					if (licenseKey == null) {
						startXhr = new Date().getTime();
						var fn = "planner_lic.txt";
						var licloc = calendar.licenseLocation;
						var xhr_1 = new XMLHttpRequest();
						try {
							var url = encodeURI(licloc != "" ? licloc : fn);
							xhr_1["url"] = url;
							xhr_1.open('GET', url);
						} catch (e) {
							//console.log('Request failed: ' + e.toStirng());
							return;
						}
						if (xhr_1.overrideMimeType) xhr_1.overrideMimeType("text/ plain");
						xhr_1.onload = function (e) {
							if (xhr_1.status === 200) {
								var content = xhr_1.responseText;
								if (content.length == 0) return;
								try {
									if (content.indexOf(' ') >= 0) return;
									lc(content);
								} catch (e) {}
							} else if (xhr_1.status === 404 && licloc == "" && xhr_1.url) {
								if (xhr_1.url != "pack_lic.txt") {
									var url = encodeURI("pack_lic.txt");
									xhr_1.open('GET', url);
									xhr_1["url"] = url;
									xhr_1.send();
									return;
								}
							} else {
								//console.log('Request failed status: ' + xhr_1.status);
							}
						};
						xhr_1.onerror = function (e) {
							//console.log('Request failed error: ' + xhr_1.status + ';' + e.toString());
						};
						xhr_1.send();
					} else {
						nowait = true;
						try {
							lc(licenseKey);
						} catch (e) {}
					}
				}

				if (nowait || !dt && new Date().getTime() - startXhr > 8000) dt = true;
				if (!dt) return true;
				if (f) return true;
				return false;
			}

			return function () {
				function Messenger() {
					classCallCheck(this, Messenger);
				}

				createClass(Messenger, [{
					key: 'message',
					value: function message(calendar) {
						drawMessage(calendar);
					}
				}, {
					key: 'setKey',
					value: function setKey(value) {
						licenseKey = value;
					}
				}]);
				return Messenger;
			}();
		}();

		this._messenger = new Messenger(null);

		this._loaded = false;

		this.repaintDelegate = function () {
			_this.repaint();
		};
		this.repaintItemsDelegate = function () {
			_this.repaint(true);
		};
		this.rebuildDelegate = function () {
			_this.render();
		};
	}

	createClass(Calendar, [{
		key: 'setLicenseKey',
		value: function setLicenseKey(value) {
			this._messenger.setKey(value);
		}
	}, {
		key: 'changeCursor',
		value: function changeCursor(value) {
			var d = document.documentElement;

			if (value) {
				if (d.className.indexOf('mfp-cursor-' + value) === -1) d.className += 'mfp-cursor-' + value;
			} else {
				var cursors = ['mfp-cursor-move', 'mfp-cursor-n-resize', 'mfp-cursor-w-resize', 'mfp-cursor-not-allowed'];

				for (var i = 0; i < cursors.length; i++) {
					if (d.className.indexOf(cursors[i]) > -1) d.className = d.className.replace(cursors[i], '');
				}
			}
		}
	}, {
		key: 'copyFrom',


		/**
     * Copies property values from another object.
     * @param {Object} settings An object containing property values.
     */
		value: function copyFrom(settings) {
			if (!settings) return;

			if (settings.schedule !== undefined) this.schedule.copyFrom(settings.schedule);

			if (settings.monthSettings !== undefined) this.monthSettings.copyFrom(settings.monthSettings);
			if (settings.monthRangeSettings !== undefined) this.monthRangeSettings.copyFrom(settings.monthRangeSettings);
			if (settings.timetableSettings !== undefined) this.timetableSettings.copyFrom(settings.timetableSettings);
			if (settings.listSettings !== undefined) this.listSettings.copyFrom(settings.listSettings);
			if (settings.weekRangeSettings !== undefined) this.weekRangeSettings.copyFrom(settings.weekRangeSettings);
			if (settings.resourceViewSettings !== undefined) this.resourceViewSettings.copyFrom(settings.resourceViewSettings);
			if (settings.itemSettings !== undefined) this.itemSettings.copyFrom(settings.itemSettings);

			if (settings.contacts !== undefined) this._contacts = settings.contacts;
			if (settings.locations !== undefined) this._locations = settings.locations;
			if (settings.tasks !== undefined) this._tasks = settings.tasks;
			if (settings.resources !== undefined) this._resources = settings.resources;

			if (settings.date !== undefined) this.date = settings.date;
			if (settings.endDate !== undefined) this.endDate = settings.endDate;
			if (settings.cssClass !== undefined) this.cssClass = settings.cssClass;
			if (settings.enabled !== undefined) this.enabled = settings.enabled;
			if (settings.currentView !== undefined) this.currentView = settings.currentView;
			if (settings.theme !== undefined) this.theme = settings.theme;
			if (settings.groupType !== undefined) this.groupType = settings.groupType;

			if (settings.allowInplaceEdit !== undefined) this.allowInplaceEdit = settings.allowInplaceEdit;
			if (settings.useForms !== undefined) this.useForms = settings.useForms;
			if (settings.showTooltips !== undefined) this.showTooltips = settings.showTooltips;
			if (settings.contactNameFormat !== undefined) this.contactNameFormat = settings.contactNameFormat;
			if (settings.locale !== undefined) this.locale = settings.locale;
			if (settings.licenseLocation !== undefined) this.licenseLocation = settings.licenseLocation;
		}
	}, {
		key: 'getElement',
		value: function getElement() {
			return document.querySelector("#" + this._element.id);
		}

		/**
  * Returns a reference to the calendar DOM element.
  */

	}, {
		key: 'attach',


		/**
  * Prepares the calendar for user interaction.
  */
		value: function attach() {
			var _this2 = this;

			this.detach();

			this.view.attach();
			this.selectManager = new SelectManager(this);

			this.keyUpHandler = function (e) {
				return _this2.onKeyUp(e);
			};
			document.addEventListener('keyup', this.keyUpHandler);

			this.resizeHandler = function (e) {
				return _this2.onResize(e);
			};
			window.addEventListener('resize', this.resizeHandler);

			this.setTimer();
			this.onCalendarLoad();

			this._loaded = true;
		}

		/**
  * Detaches calendar event handlers.
  */

	}, {
		key: 'detach',
		value: function detach() {
			if (this.selectManager) this.selectManager.dispose();

			if (this.view) this.view.detach();

			if (this.keyUpHandler) document.removeEventListener('keyup', this.keyUpHandler);
			if (this.resizeHandler) window.removeEventListener('resize', this.resizeHandler);
		}

		/**
  * Item cloned with itemcCloneKey.
  * For internal use only.
  * @private
  */

	}, {
		key: 'cloneItem',
		value: function cloneItem(item) {
			var clone = item.clone();

			if (this.onItemCreating(new ItemEventArgs(clone))) {
				this.schedule.items.add(clone);

				this.onItemCreated(new ItemEventArgs(clone));
			}
		}

		/**
  * Item created through popup form.
  * For internal use only.
  * @private
  */

	}, {
		key: 'createItem',
		value: function createItem(args) {

			var item = new Item();
			item.extend(args);

			if (args.recurrence) {
				// created
				item.recurrence = args.recurrence;
				args.recurrence.associateWith(item);
			}

			if (this.onItemCreating(new ItemEventArgs(item))) {
				this.schedule.items.add(item);

				this.onItemCreated(new ItemEventArgs(item));
			}
		}

		/**
  * Item modified through popup form or inplace edit
  * For internal use only.
  * @private
  */

	}, {
		key: 'editItem',
		value: function editItem(item, args, inplace) {

			var oldItem = item.clone();

			var action = inplace ? ItemModifyAction.InplaceEdit : ItemModifyAction.Edit;

			if (this.onItemModifying(new ItemModifyingEventArgs(item, args, action))) {

				if (args.recurrence) {
					// modified
					if (args.recurrenceChanged) {
						item.recurrence.extend(args.recurrence);
					}
					// created
					else {
							item.recurrence = args.recurrence;
							args.recurrence.associateWith(item);
						}
				}

				item.extend(args);

				if (item.recurrence != null && args.recurrenceChanged != true) item.recurrence.markException(item, false);

				// recurrence deleted
				if (item.recurrence != null && args.recurrence === null) {
					var master = this.schedule.getMasterById(item.id);
					oldItem = master.clone();
					master.extend(item);
					item = master;

					item.recurrenceState = 0;
					item.recurrence = null;
				}

				args.item = item;

				this.onItemModified(new ItemModifiedEventArgs(item, oldItem, action));

				var appointments = this.view.getItemElements(item);
				for (var i = 0, l = appointments.length; i < l; i++) {
					this.view.removeAppointment(appointments[i]);
				}

				this.invalidate(RepaintType.ViewContent);
			}
		}

		/**
  * Item modified by drag or resize.
  * For internal use only.
  * @private
  */

	}, {
		key: 'modifyItem',
		value: function modifyItem(item, data, action) {
			var args = {
				startTime: data.startTime,
				endTime: data.endTime,
				allDayEvent: item.allDayEvent
			};

			if (this.onItemModifying(new ItemModifyingEventArgs(item, args, action))) {
				var oldItem = item.clone();

				if (data.resource) {
					if (data.resource instanceof Location) {
						args.location = data.resource;
					} else if (data.resource instanceof Contact) {
						args.contacts = [];
						args.contacts.push(data.resource);
					} else if (data.resource instanceof Task) {
						args.task = data.resource;
					} else if (data.resource instanceof Resource) {
						args.resources = [];
						args.resources.push(data.resource);
					}
				}

				item.extend(args);

				if (item.recurrence != null) item.recurrence.markException(item, false);

				args.item = item;

				this.onItemModified(new ItemModifiedEventArgs(item, oldItem, action));
			}

			var appointments = this.view.getItemElements(item);
			for (var i = 0, l = appointments.length; i < l; i++) {
				this.view.items.splice(this.view.items.indexOf(appointments[i]), 1);
				//this.view.removeAppointment(appointments[i]);
			}

			this.invalidate(RepaintType.ViewContent);
		}

		/**
  * Deletes the specified item.
  * For internal use only.
  * @private
  */

	}, {
		key: 'deleteItem',
		value: function deleteItem(item) {
			var confirmed = false;

			if (this.onItemDeleting(new ItemEventArgs(item))) {
				if (item.recurrence) {
					if (this.onRecurringItemDeleting(new ItemEventArgs(item))) {
						confirmed = true;
					}
				} else confirmed = true;
			}

			if (confirmed) {

				if (item.recurrence != null) item.recurrence.markException(item, true);

				var appointments = this.view.getItemElements(item);
				for (var i = 0, l = appointments.length; i < l; i++) {
					this.view.removeAppointment(appointments[i]);
				}

				this.schedule.items.remove(item);

				this.onItemDeleted(new ItemEventArgs(item));
			}
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'onItemSelectionChanged',
		value: function onItemSelectionChanged(sender, args) {
			switch (args.action) {
				case NotifyCollectionChangedAction.Reset:
					for (var i = 0, l = this.view.items.length; i < l; i++) {
						DomUtils.removeCssClass(this.view.items[i].element, "mfp-selected");
					}
					break;
				case NotifyCollectionChangedAction.Remove:
					for (var i = 0, l = args.oldItems.length; i < l; i++) {
						var item = args.oldItems[i];
						{
							var appointments = this.view.getItemElements(item);
							for (var k = 0, m = appointments.length; k < m; k++) {
								DomUtils.removeCssClass(appointments[k].element, "mfp-selected");
							}
						}
					}
					break;
				case NotifyCollectionChangedAction.Add:
				default:
					for (var i = 0, l = args.newItems.length; i < l; i++) {
						var item = args.newItems[i];
						{
							var appointments = this.view.getItemElements(item);
							for (var k = 0, m = appointments.length; k < m; k++) {
								DomUtils.addCssClass(appointments[k].element, "mfp-selected");
							}
						}
					}
					break;
			}

			this._itemSelectionChanged.raiseEvent(sender, args);
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'getAppointmentById',
		value: function getAppointmentById(id, occurrenceIndex) {
			for (var i = 0, l = this.view.items.length; i < l; i++) {
				if (this.view.items[i].item.id == id && this.view.items[i].item.occurrenceIndex == occurrenceIndex) {
					return this.view.items[i];
				}
			}
			return null;
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'checkResource',
		value: function checkResource(e, resource) {
			var groupable = this.currentView === CalendarView.Timetable || this.currentView === CalendarView.List || this.currentView === CalendarView.ResourceView;
			if (!groupable) return null;

			if (this.view.grouped === true) {
				if (this._itemChangeResourceKey === Keys.None || this._itemChangeResourceKey === Keys.Shift && e.shiftKey || this._itemChangeResourceKey === Keys.Control && e.ctrlKey || this._itemChangeResourceKey === Keys.Alt && e.altKey) {
					return null;
				} else return resource;
			}
			return null;
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'applyFilter',
		value: function applyFilter(items) {
			if (this._groupType >= 1) {
				var toRemove = [];
				var groupable = this._currentView === CalendarView.Timetable || this._currentView === CalendarView.List || this._currentView === CalendarView.ResourceView;
				var visibleItems = items;
				for (var i = 0, l = visibleItems.length; i < l; i++) {
					var item = visibleItems[i];
					var visible = true;
					switch (this._groupType) {
						case 1:
						case 5:
							if (this._groupType === GroupType.GroupByContacts && !groupable) break;
							if (this._contacts.count() > 0) {
								visible = false;
								if (item.contacts === undefined) {
									break;
								}
								for (var j = 0, m = item.contacts.count(); j < m; j++) {
									var index = this._contacts.indexOfItem(item.contacts.items()[j]);
									if (index > -1) {
										visible = true;break;
									}
								}
							}
							break;
						case 3:
						case 6:
							if (this._groupType === GroupType.GroupByLocations && !groupable) break;
							if (this._locations.count() > 0) {
								visible = false;
								var index = this._locations.indexOfItem(item.location);
								if (index > -1) {
									visible = true;break;
								}
							}
							break;
						case 4:
						case 7:
							if (this._groupType === GroupType.GroupByTasks && !groupable) break;
							if (this._tasks.count() > 0) {
								visible = false;
								if (item.task === undefined) {
									break;
								}
								var index = this._tasks.indexOfItem(item.task);
								if (index > -1) {
									visible = true;break;
								}
							}
							break;
						case 2:
						case 8:
							if (this._groupType === GroupType.GroupByResources && !groupable) break;
							if (this._resources.count() > 0) {
								visible = false;
								if (item.resources === undefined) {
									break;
								}
								for (var j = 0, m = item.resources.count(); j < m; j++) {
									var index = this._resources.indexOfItem(item.resources.items()[j]);
									if (index > -1) {
										visible = true;break;
									}
								}
							}
							break;
						default:
							break;
					}
					if (visible === false) {
						toRemove.push(visibleItems[i]);
					}
					visible = false;
				}
				if (toRemove.length > 0) {
					var j2;
					for (var i2 = 0, l2 = toRemove.length; i2 < l2; i2++) {
						j2 = 0;
						while (j2 < visibleItems.length) {
							if (visibleItems[j2] === toRemove[i2]) {
								visibleItems.splice(j2, 1);
							} else {
								j2++;
							}
						}
					}
				}
			}
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'draw',


		/**
  * Draws the calendar control.
  * @returns {DomElement} the calendar element.
  */
		value: function draw() {
			if (this.view) DomUtils.removeCssClass(this._element, this.view.cssClass);
			if (this.theme) DomUtils.removeCssClass(this._element, this.theme);
			if (this.cssClass) DomUtils.removeCssClass(this._element, this.cssClass);

			this.updateView();

			DomUtils.addCssClass(this._element, "mfp-planner");
			DomUtils.addCssClass(this._element, this.view.cssClass);
			if (this.theme) DomUtils.addCssClass(this._element, this.theme);
			if (this.cssClass) DomUtils.addCssClass(this._element, this.cssClass);

			this._element.innerHTML = "";
			this._element.appendChild(this.view.draw());

			return this._element;
			//return { __html: this.element.outerHTML };
		}

		/**
  * Draws the calendar control and prepares it for user interaction.
  */

	}, {
		key: 'render',
		value: function render() {
			this.draw();
			this.attach();
			if (this.rebuildId) {
				clearTimeout(this.rebuildId);
				this.rebuildId = null;
			}
		}

		/**
  * Repaints the calendar contents.
  * @param {Boolean} full True to recreate calendar items, otherwise false.
  */

	}, {
		key: 'repaint',
		value: function repaint(full) {
			if (!this._loaded) return;

			if (full) this.view.clearAppointments();
			this.view.clear();
			this.view.init();
			this._messenger.message(this);
			if (this.repaintId) {
				clearTimeout(this.repaintId);
				this.repaintId = null;
			}
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'invalidate',
		value: function invalidate(type) {
			switch (type) {
				case RepaintType.Full:
				default:
					if (!this.rebuildId) {
						if (this.repaintId) {
							clearTimeout(this.repaintId);
							this.repaintId = null;
						}
						this.rebuildId = setTimeout(this.rebuildDelegate, 20);
					}
					break;
				case RepaintType.ViewItems:
					if (!this.repaintId) this.repaintId = setTimeout(this.repaintItemsDelegate, 10);
					break;
				case RepaintType.ViewContent:
					if (!this.repaintId) this.repaintId = setTimeout(this.repaintDelegate, 10);
					break;
			}
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'updateView',
		value: function updateView() {
			//if (this._view) this._view.detach();

			switch (this.currentView) {
				default:
				case CalendarView.MonthRange:
					this._view = new MonthRangeCell(this);
					break;

				case CalendarView.SingleMonth:
					this._view = new MonthCell(this);
					break;

				case CalendarView.WeekRange:
					this._view = new WeekRangeCell(this);
					break;

				case CalendarView.List:
					{
						if (this.listSettings.orientation == Orientation.Vertical) this._view = new VerticalList(this);else this._view = new HorizontalList(this);
					}
					break;

				case CalendarView.Timetable:
					{
						if (this.timetableSettings.orientation == Orientation.Vertical) this._view = new Timetable(this);else this._view = new HorizontalTimetable(this);
					}
					break;

				case CalendarView.ResourceView:
					this._view = new ResourceViewCell(this, null, this.date);
					break;
			}
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'processButtonClick',


		/**
  * For internal use only.
  * @private
  */
		value: function processButtonClick(buttonType) {
			var args = new ButtonEventArgs(buttonType);
			this.onButtonClick(args);
			if (args.cancel) return;

			var t = buttonType;
			var prevDate = this._date.clone();

			if (Math.abs(t) === 1) {
				switch (this.currentView) {
					case CalendarView.Timetable:

						var scrollStep = this.timetableSettings.scrollStep;
						for (var i = 0; i < this.timetableSettings.dates.count(); i++) {
							prevDate = this.timetableSettings.dates.items()[i].clone();
							this.timetableSettings.dates.items()[i] = DateTime.addDays(prevDate, scrollStep * t);
						}
						this.raiseVisibleDateChanged(prevDate, this.timetableSettings.dates.items()[0]);
						return;

					case CalendarView.SingleMonth:
						//this._date = DateTime.addMonths(this._date, t);
						this._date = this.advance(this.getMonthFirstDate(this._date), t, TimeUnit.Month);
						break;

					case CalendarView.List:
						this._date = this.advance(this._date, t, this.listSettings.cellUnits);
						break;
				}
			} else {
				if (this.currentView === CalendarView.SingleMonth) {
					//this._date = DateTime.addYears(this._date, t / 2);
					this._date = this.advance(this.getMonthFirstDate(this._date), t / 2, TimeUnit.Year);
				} else if (this.currentView === CalendarView.MonthRange) {
					//this._date = this.advance(this._date, this.monthRangeSettings.numberOfMonths * (t / 2), TimeUnit.Month);
					this._date = this.advance(this.getMonthFirstDate(this._date), this.monthRangeSettings.numberOfMonths * (t / 2), TimeUnit.Month);
				}
			}

			this.raiseVisibleDateChanged(prevDate, this._date);
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'raiseVisibleDateChanged',
		value: function raiseVisibleDateChanged(prevDate, newDate) {
			if (Calendar.autoRepaint && this._loaded) {
				this.invalidate(RepaintType.Full);
			}
			this.onVisibleDateChanged(new DateChangedEventArgs(newDate, prevDate));
		}
	}, {
		key: 'onScheduleChanged',
		value: function onScheduleChanged(e) {
			if (this._loaded) {
				this.invalidate(RepaintType.ViewItems);
			}
		}
	}, {
		key: 'onCollectionChanged',
		value: function onCollectionChanged() {
			if (Calendar.autoRepaint && this._loaded) {
				this.invalidate(RepaintType.Full);
			}
		}
	}, {
		key: 'onPropertyChanged',
		value: function onPropertyChanged(name, oldValue, newValue) {
			if (name === "theme") {
				DomUtils.removeCssClass(this._element, oldValue);
				DomUtils.addCssClass(this._element, newValue);

				if (this.view) this.view.onThemeChanged(oldValue, newValue);
				return;
			}
			if (Calendar.autoRepaint && this._loaded) {
				this.invalidate(RepaintType.Full);
			}
		}
	}, {
		key: 'onViewSettingsChanged',
		value: function onViewSettingsChanged(args) {
			if (Calendar.autoRepaint && this._loaded) {
				this.invalidate(RepaintType.Full);
			}
		}
	}, {
		key: 'onItemSettingsChanged',
		value: function onItemSettingsChanged(args) {
			if (Calendar.autoRepaint && this._loaded) {
				this.invalidate(RepaintType.Full);
			}
		}

		/* Events */
		/**
  * Raises the calendarLoad event.
  */

	}, {
		key: 'onCalendarLoad',
		value: function onCalendarLoad() {
			this._calendarLoad.raiseEvent(this, new EmptyEventArgs());
		}
		/**
   * Raised when the control is loaded.
   */

	}, {
		key: 'onVisibleDateChanged',


		/**
  * Raises the visibleDateChanged event.
  * @param {DateChangedEventArgs} args An instance of the DateChangedEventArgs class.
  */
		value: function onVisibleDateChanged(args) {
			this._visibleDateChanged.raiseEvent(this, args);
		}
		/**
   * Raised when the calendar date is changed.
   */

	}, {
		key: 'onSelectionStart',


		/**
  * Raises the selectionStart event.
  */
		value: function onSelectionStart(args) {
			this._selectionStart.raiseEvent(this, args);
			return !args.cancel;
		}
		/**
   * Raised when a selection is started.
   */

	}, {
		key: 'onSelectionChanged',


		/**
  * Raises the selectionChanged event.
  */
		value: function onSelectionChanged(args) {
			this._selectionChanged.raiseEvent(this, args);
			return !args.cancel;
		}

		/**
   * Raised when a selection changes.
   */

	}, {
		key: 'onSelectionEnd',


		/**
  * Raises the selectionEnd event.
  */
		value: function onSelectionEnd(args) {
			this._selectionEnd.raiseEvent(this, args);
			return !args.cancel;
		}

		/**
   * Raised when a selection has ended.
   */

	}, {
		key: 'onItemCreating',


		/**
  * Raises the itemCreating event.
  */
		value: function onItemCreating(args) {
			this._itemCreating.raiseEvent(this, args);
			return !args.cancel;
		}

		/**
   * Raised while an item is being created.
   */

	}, {
		key: 'onItemCreated',


		/**
  * Raises the itemCreated event.
  */
		value: function onItemCreated(args) {
			this._itemCreated.raiseEvent(this, args);
		}

		/**
   * Raised when an item is created.
   */

	}, {
		key: 'onItemModifying',


		/**
  * Raises the itemModifying event.
  */
		value: function onItemModifying(args) {
			this._itemModifying.raiseEvent(this, args);
			return !args.cancel;
		}

		/**
   * Raised while an item is being modified.
   */

	}, {
		key: 'onItemModified',


		/**
  * Raises the itemModified event.
  */
		value: function onItemModified(args) {
			this._itemModified.raiseEvent(this, args);
		}

		/**
   * Raised when an item is modified.
   */

	}, {
		key: 'onItemDeleting',


		/**
  * Raises the itemDeleting event.
  */
		value: function onItemDeleting(args) {
			this._itemDeleting.raiseEvent(this, args);
			return !args.cancel;
		}

		/**
   * Raised while an item is being deleted.
   */

	}, {
		key: 'onItemDeleted',


		/**
  * Raises the itemDeleted event.
  */
		value: function onItemDeleted(args) {
			this._itemDeleted.raiseEvent(this, args);
		}

		/**
   * Raised when an item is deleted.
   */

	}, {
		key: 'onRecurringItemDeleting',


		/**
  * Raises the recurringItemDeleting event.
  */
		value: function onRecurringItemDeleting(args) {
			this._recurringItemDeleting.raiseEvent(this, args);
			return !args.cancel;
		}

		/**
   * Raised while a recurring item is being deleted.
   */

	}, {
		key: 'onItemInplaceEditStart',


		/**
  * Raises the itemInplaceEditStart event.
  */
		value: function onItemInplaceEditStart(args) {
			this._itemInplaceEditStart.raiseEvent(this, args);
			return !args.cancel;
		}

		/**
   * Raised when an inplace edit operation is started.
   */

	}, {
		key: 'onItemInplaceEditEnd',


		/**
  * Raises the itemInplaceEditEnd event.
  */
		value: function onItemInplaceEditEnd(args) {
			this._itemInplaceEditEnd.raiseEvent(this, args);
			return !args.cancel;
		}

		/**
   * Raised when an inplace edit operation has ended.
   */

	}, {
		key: 'onItemReminderTriggered',


		/**
  * Raises the itemReminderTriggered event.
  */
		value: function onItemReminderTriggered(args) {
			this._itemReminderTriggered.raiseEvent(this, args);
			return !args.cancel;
		}

		/**
   * Raised when an item remider is triggered.
   */

	}, {
		key: 'onTaskReminderTriggered',


		/**
  * Raises the taskReminderTriggered event.
  */
		value: function onTaskReminderTriggered(args) {
			this._taskReminderTriggered.raiseEvent(this, args);
			return !args.cancel;
		}
		/**
   * Raised when an task remider is triggered.
   */

	}, {
		key: 'onItemDragStart',


		/**
  * Raises the itemDragStart event.
  */
		value: function onItemDragStart(args) {
			this._itemDragStart.raiseEvent(this, args);
			return !args.cancel;
		}
		/**
   * Raised when a drag operation is started.
   */

	}, {
		key: 'onItemDragEnd',


		/**
  * Raises the itemDragEnd event.
  */
		value: function onItemDragEnd(args) {
			this._itemDragEnd.raiseEvent(this, args);
			return !args.cancel;
		}
		/**
   * Raised when a drag operation has ended.
   */

	}, {
		key: 'onItemResizeStart',


		/**
  * Raises the itemResizeStart event.
  */
		value: function onItemResizeStart(args) {
			this._itemResizeStart.raiseEvent(this, args);
			return !args.cancel;
		}
		/**
   * Raised when a resize operation is started.
   */

	}, {
		key: 'onItemResizeEnd',


		/**
  * Raises the itemResizeEnd event.
  */
		value: function onItemResizeEnd(args) {
			this._itemResizeEnd.raiseEvent(this, args);
			return !args.cancel;
		}
		/**
   * Raised when a resize operation has ended.
   */

	}, {
		key: 'onItemClick',


		/**
  * Raises the itemClick event.
  */
		value: function onItemClick(args) {
			this._itemClick.raiseEvent(this, args);
			return !args.cancel;
		}
		/**
   * Raised when an item is clicked.
   */

	}, {
		key: 'onItemDoubleClick',


		/**
  * Raises the itemDoubleClick event.
  */
		value: function onItemDoubleClick(args) {
			this._itemDoubleClick.raiseEvent(this, args);
			return !args.cancel;
		}
		/**
   * Raised when an item is double-clicked.
   */

	}, {
		key: 'onFormShow',


		/**
  * Raises the formShow event.
  */
		value: function onFormShow(args) {
			this._formShow.raiseEvent(this, args);
			return !args.cancel;
		}
		/**
   * Raised when a popup form is shown.
   */

	}, {
		key: 'onFormClose',


		/**
  * Raises the formClose event.
  */
		value: function onFormClose(args) {
			this._formClose.raiseEvent(this, args);
			return !args.cancel;
		}
		/**
   * Raised when a popup form is closed.
   */

	}, {
		key: 'onButtonClick',


		/**
  * Raises the buttonClick event.
  */
		value: function onButtonClick(args) {
			this._buttonClick.raiseEvent(this, args);
			return !args.cancel;
		}
		/**
   * Raised when a navigation button is clicked
   */

	}, {
		key: 'onCellClick',


		/**
  * Raises the cellClick event.
  */
		value: function onCellClick(args) {
			this._cellClick.raiseEvent(this, args);
		}
		/**
   * Raised when a calendar time cell is clicked.
   */

	}, {
		key: 'onCellDoubleClick',


		/**
  * Raises the cellDoubleClick event.
  */
		value: function onCellDoubleClick(args) {
			this._cellDoubleClick.raiseEvent(this, args);
		}
		/**
   * Raised when a calendar time cell is double-clicked.
   */

	}, {
		key: 'onHeaderClick',


		/**
  * Raises the headerClick event.
  */
		value: function onHeaderClick(args) {
			this._headerClick.raiseEvent(this, args);
		}
		/**
   * Raised when a calendar header is clicked.
   */

	}, {
		key: 'onHeaderDoubleClick',


		/**
  * Raises the headerDoubleClick event.
  */
		value: function onHeaderDoubleClick(args) {
			this._headerDoubleClick.raiseEvent(this, args);
		}
		/**
   * Raised when a calendar header is double-clicked.
   */

	}, {
		key: 'onCueClick',


		/**
  * Raises the cueClick event.
  */
		value: function onCueClick(args) {
			this._cueClick.raiseEvent(this, args);
		}
		/**
   * Raised when an item cue is clicked.
   */

	}, {
		key: 'advance',


		/*Date Utils */
		/**
  * For internal use.
  * @private
  */
		value: function advance(time, steps, unit) {
			switch (unit) {
				case TimeUnit.Second:
					time = time.addSeconds(steps);
					break;
				case TimeUnit.Minute:
					time = time.addMinutes(steps);
					break;
				case TimeUnit.Hour:
					time = time.addHours(steps);
					break;
				case TimeUnit.Day:
					time = time.addDays(steps);
					break;
				case TimeUnit.Week:
					time = time.addWeeks(steps);
					break;
				case TimeUnit.Month:
					time = time.addMonths(steps);
					break;
				case TimeUnit.Year:
					time = time.addYears(steps);
					break;
				default:
					break;
			}

			return time;
		}

		/**
  * For internal use.
  * @private
  */

	}, {
		key: 'getMonthFirstVisibleDate',
		value: function getMonthFirstVisibleDate(time) {
			var t = time.clone();
			t = this.getMonthFirstDate(time);
			while (t.dayOfWeek !== +this.formatInfo.firstDayOfWeek) {
				t = t.addDays(-1);
			}return t;
		}

		/**
  * For internal use.
  * @private
  */

	}, {
		key: 'getMonthFirstDate',
		value: function getMonthFirstDate(time) {
			// TODO: remove this once we make DateTime immutable
			var t = time.clone();
			var day = t.day;
			return t.addDays(-day + 1);
		}
		/**
  * For internal use.
  * @private
  */

	}, {
		key: 'getWeekFirstDate',
		value: function getWeekFirstDate(time) {
			// TODO: remove this when we make DateTime immutable
			var t = time.clone();
			while (t.dayOfWeek !== +this.formatInfo.firstDayOfWeek) {
				t = t.addDays(-1);
			}return t;
		}

		/**
  * For internal use.
  * @private
  */

	}, {
		key: 'getWeekOfYear',
		value: function getWeekOfYear(time) {
			var t = time.clone();
			var d = t._date;
			d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
			var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
			return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
		}

		/**
  * For internal use.
  * @private
  */

	}, {
		key: 'getDayName',
		value: function getDayName(day, dayNameFormat) {
			var wrap = day % 7;

			switch (dayNameFormat) {
				case DayOfWeekFormat.SingleLetter:
					return this.formatInfo.days.narrow[wrap];

				case DayOfWeekFormat.Abbreviated:
					return this.formatInfo.days.short[wrap];

				case DayOfWeekFormat.Full:
					return this.formatInfo.days.long[wrap];

				default:
					break;
			}

			return "";
		}

		/* Reminders */
		/**
  * For internal use.
  * @private
  */

	}, {
		key: 'setTimer',
		value: function setTimer() {
			if (this.timer) {
				if (!this.hasItemsToRemind() && !this.hasTasksToRemind()) {
					clearInterval(this.timer.id);
					this.timer = null;
				}
			} else {
				if (this.hasItemsToRemind() || this.hasTasksToRemind()) {
					this.timer = new Timer(this);
				}
			}
		}

		/**
  * Checks if there are items which reminder has not come yet.
  * @returns {Boolean} true if there are items with a future reminder; otherwise false.
  */

	}, {
		key: 'hasItemsToRemind',
		value: function hasItemsToRemind() {
			for (var i = 0, l = this.view.items.length; i < l; i++) {
				var item = this.view.items[i].item;
				if (item.reminder != null && !this.isReminderOutdated(item.reminder, item.startTime._date.valueOf())) {
					return true;
				}
			}
			return false;
		}

		/**
  * Checks if there are tasks which reminder has not come yet.
  * @returns {Boolean} true if there are tasks with a future reminder; otherwise false.
  */

	}, {
		key: 'hasTasksToRemind',
		value: function hasTasksToRemind() {
			for (var i = 0, l = this.schedule.tasks.items().length; i < l; i++) {
				var t = this._schedule.tasks.items()[i];
				if (t.reminder != null && !this.isReminderOutdated(t.reminder)) {
					return true;
				}
			}
			return false;
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'isReminderOutdated',
		value: function isReminderOutdated(reminder, itemStart) {
			if (reminder.type === undefined) {
				throw new Error('reminder is not valid');
			}
			var now = new DateTime(new Date());
			switch (reminder.type) {
				// Exact                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
				case 0:
					if (reminder.time.valueOf() < now._date.valueOf()) {
						return true;
					}
					return false;
				// Leading
				case 1:
					if (itemStart === undefined) {
						return true;
					}
					if (itemStart - reminder.timeInterval < now._date.valueOf()) {
						return true;
					}
					return false;
			}
		}

		/**
  * Gets the calendar view cell that corresponds to the specified DateTime and resource.
  * @param {DateTime} time The time to search for.
  * *@param {Boolean} [isEndTime] true if the index of the first interval is returned when the time is the boundary between two consecutive intervals;
  * false if the index of the second interval is contained. The default is false.
  * @param {Resource} [resource] The resource to search for.
  * @returns {ViewCell} The cell that corresponds the specified DateTime and resource.
  */

	}, {
		key: 'getTimeCell',
		value: function getTimeCell(time, isEndTime, resource) {
			if (resource == null && this.view.grouped) {
				return null;
			}

			var resources = this.view.resources;
			var colIndex = 0;
			if (resource != null) {
				colIndex = resources.indexOf(resource);
				if (colIndex == -1 && !this.view.grouped) colIndex = 0;
			}
			if (colIndex == -1) return null;

			return this.view.getTimeCell(time, isEndTime, colIndex);
		}

		/**
  * Gets the calendar view cells that corresponds to the specified DateTime range and the specified resource.
  * @param {DateTime} startTime The start time of the range.
  * @param {DateTime} [endTime] The end time of the range.
  * @param {Boolean} [isEndTime] true if the index of the first interval is returned when the time is the boundary between two consecutive intervals;
  false if the index of the second interval is contained. The default is false.
  * @param {Resource} [resource] The resource to search for.
  * @returns {Array} An array of ViewCell objects that correspond to the specified DateTime range and resource.
  */

	}, {
		key: 'getTimeCells',
		value: function getTimeCells(startTime, endTime, isEndTime, resource) {
			if (startTime === null || typeof startTime === "undefined" || typeof startTime._date === "undefined") {
				return [];
			}
			if (resource == null && this.view.grouped) {
				return [];
			}

			var resources = this.view.resources;
			var colIndex = 0;
			if (resource != null) {
				colIndex = resources.indexOf(resource);
				if (colIndex == -1 && !this.view.grouped) colIndex = 0;
			}
			if (colIndex == -1) return null;

			return this.view.getTimeCells(startTime, endTime, isEndTime, colIndex);
		}

		/**
  * Gets the calendar view cell that contains the specified coordinates.
  * @param {Number} x The X-coordinate of the point.
  * @param {Number} y The Y-coordinate of the point.
  * @returns {ViewCell} The calendar view cell that contains the specified coordinates or null if there is no cell at point.
  */

	}, {
		key: 'getCellAt',
		value: function getCellAt(x, y) {
			if (this.view) return this.view.getCellAt(x, y);
			return null;
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'getResourceName',
		value: function getResourceName(resource) {
			var resourceName = "";
			switch (this.realGroupType) {
				case GroupType.GroupByContacts:
					{
						if (resource instanceof Contact) {
							resourceName = this.formatName(resource, this.contactNameFormat);
						}
					}
					break;

				case GroupType.GroupByResources:
					{
						if (resource) resourceName = resource.name;
					}
					break;

				case GroupType.GroupByLocations:
					{
						if (resource instanceof Location) resourceName = resource.name;
					}
					break;

				case GroupType.GroupByTasks:
					{
						if (resource instanceof Task) resourceName = resource.subject;
					}
					break;
			}
			return resourceName;
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'formatName',
		value: function formatName(contact, format) {
			var s = "";

			for (var c in format) {
				switch (format[c]) {

					case 'F':
						s += contact.firstName;
						break;

					case 'M':
						s += contact.middleName;
						break;

					case 'L':
						s += contact.lastName;
						break;

					default:
						s += format[c];
						break;

				}
			}

			return s.replace(/^[\s\uFEFF\xA0,.]+|[\s\uFEFF\xA0,.]+$/g, '');
			//return s.replace([' ', '\t', '\n', '\r', ',', '.']);
		}

		/** 
     * For internal use only.
     * @private
      */

	}, {
		key: 'formatTooltip',
		value: function formatTooltip(item, format) {
			var builder = [];
			var isFormatter = false;
			var isStartDate = false;
			var isEndDate = false;
			var isDateFormat = false;
			var dateFormat = "";

			for (var i = 0, l = format.length; i < l; i++) {
				var c = format[i];
				if (isStartDate || isEndDate) {
					// We have read either '%s' or '%e'
					if (isDateFormat) {
						// We have also read '['
						if (c === ']') {
							if (isStartDate) {
								// Format the start date according to the string accumulated in dateFormat
								builder.push(item.startTime.toString(dateFormat, this.formatInfo));
							} else if (isEndDate) {
								// Format the end date according to the string accumulated in dateFormat
								builder.push(item.endTime.toString(dateFormat, this.formatInfo));
							}
							isStartDate = false;
							isEndDate = false;
							isDateFormat = false;
							dateFormat = "";
							continue;
						}
						// Append the character 'c' to the formatting
						dateFormat += c;
						continue;
					}
					// We expect '[', everything else is getting ignored
					if (c === '[') {
						isDateFormat = true;
						dateFormat = "";
						continue;
					}
					continue;
				}
				if (c === '%') {
					if (isFormatter) {
						// %% results in a single '%' in the output string
						builder.push('%');
						isFormatter = false;
						continue;
					}
					isFormatter = true;
					continue;
				}
				if (isFormatter) {
					switch (c) {
						case 'h':
							// Header text
							builder.push(item.subject);
							break;
						case 'd':
							// Description text
							builder.push(item.details);
							break;
						case 's':
							// Start date
							isStartDate = true;
							break;
						case 'e':
							isEndDate = true;
							break;
						default:
							break;
					}
					isFormatter = false;
					continue;
				}
				builder.push(c);
			}
			var result = builder.join('').trim();
			return result;
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'sortAppointments',
		value: function sortAppointments(a, b) {
			if (a.item.priority != b.item.priority) {
				return b.item.priority - a.item.priority;
			}

			if (a.item.startTime._date.getTime() != b.item.startTime._date.getTime()) {
				return a.item.startTime._date.getTime() - b.item.startTime._date.getTime();
			}

			if (a.length != b.length) {
				return b.length - a.length;
			}

			if (a.isPartial && !b.isPartial) {
				return -1;
			}

			if (b.isPartial && !a.isPartial) {
				return 1;
			}

			if (a.item.headerText != '' && b.item.headerText === '') {
				return -1;
			}
			if (a.item.headerText === '' && b.item.headerText != '') {
				return 1;
			}
			if (a.item.headerText != '' && b.item.headerText != '' && a.item.headerText != b.item.headerText) {
				return a.item.headerText.charCodeAt(0) - b.item.headerText.charCodeAt(0);
			}
			return 0;
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'itemCloneKeyPressed',
		value: function itemCloneKeyPressed(e) {
			if (this._itemCloneKey === 0) {
				return false;
			}
			if (this._itemCloneKey === Keys.Shift && e.shiftKey) {
				return true;
			}
			if (this._itemCloneKey === Keys.Control && e.ctrlKey) {
				return true;
			}
			if (this._itemCloneKey === Keys.Alt && e.altKey) {
				return true;
			}
			return false;
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'allowDelete',
		value: function allowDelete() {
			if (this.popups.get('ItemsCueForm')) return false;

			if (this.view.inplaceEditing === true || this.view._dragging === true || this.view._resizing === true) {
				return false;
			}
			if (this._itemSelection.count() === 0) {
				return false;
			}

			return true;
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'onKeyUp',
		value: function onKeyUp(e) {
			// handle Delete (delete selected item/s)
			if (e.keyCode === 46 || e.keyCode === 127) {
				if (this.allowDelete()) {
					// todo: close cue form if deleted item(s) left it empty
					var itemsToDelete = this._itemSelection.items();

					var args = new ItemEventArgs(item);

					for (var i = 0, l = itemsToDelete.length; i < l; i++) {
						var item = itemsToDelete[i];
						if (item.recurrence) {
							if (this.onItemDeleting(args)) {
								if (this.onRecurringItemDeleting(args)) {
									this.deleteItem(item);
								}
							}
						} else {
							if (this.onItemDeleting(args)) {
								this.deleteItem(item);
							}
						}
					}
				}
			}
			var key = this.popups._keys.items()[this.popups.count - 1];
			var popup = this.popups.get(key);
			if (popup) popup.onKeyUp(e);
		}

		/**
  * For internal use only.
  * @private
  */

	}, {
		key: 'onResize',
		value: function onResize(e) {
			if (this.view) {
				this.view.getDimensions();
				this.invalidate(RepaintType.ViewContent);
			}
		}
	}, {
		key: 'element',
		get: function get$$1() {
			return this.getElement();
		}

		/**
  * Returns a reference to the DOM element of the calendar main header.
  */

	}, {
		key: 'header',
		get: function get$$1() {
			if (this.view) return this.view.getHeader();
			return null;
		}

		/**
  * Gets the collection of cells in the calendar view.
  */

	}, {
		key: 'cells',
		get: function get$$1() {
			if (this.view) return this.view.cells;
			return null;
		}
	}, {
		key: 'view',
		get: function get$$1() {
			return this._view;
		}
	}, {
		key: 'groupResources',
		get: function get$$1() {
			switch (this.realGroupType) {
				case GroupType.GroupByContacts:
					return this.contacts;

				case GroupType.GroupByResources:
					return this.resources;

				case GroupType.GroupByLocations:
					return this.locations;

				case GroupType.GroupByTasks:
					return this.tasks;
			}
			return new ObservableCollection();
		}

		/**
  * Gets the actual group type. This is the same as GroupType unless
  * the corresponding resource collection is empty, in which case it
  * returns GroupType.None.
  * @returns {GroupType} the actual group type.
  */

	}, {
		key: 'realGroupType',
		get: function get$$1() {
			switch (this.groupType) {
				case GroupType.GroupByContacts:
					if (this.contacts.count() === 0) return GroupType.None;
					break;

				case GroupType.GroupByResources:
					if (this.resources.count() === 0) return GroupType.None;
					break;

				case GroupType.GroupByLocations:
					if (this.locations.count() === 0) return GroupType.None;
					break;

				case GroupType.GroupByTasks:
					if (this.tasks.count() === 0) return GroupType.None;
					break;
				default:
					return GroupType.None;
			}
			return this.groupType;
		}
	}, {
		key: 'calendarLoad',
		get: function get$$1() {
			return this._calendarLoad;
		}
	}, {
		key: 'visibleDateChanged',
		get: function get$$1() {
			return this._visibleDateChanged;
		}
	}, {
		key: 'selectionStart',
		get: function get$$1() {
			return this._selectionStart;
		}
	}, {
		key: 'selectionChanged',
		get: function get$$1() {
			return this._selectionChanged;
		}
	}, {
		key: 'selectionEnd',
		get: function get$$1() {
			return this._selectionEnd;
		}

		/**
   * Raised when a selection of items changes.
   */

	}, {
		key: 'itemSelectionChanged',
		get: function get$$1() {
			return this._itemSelectionChanged;
		}
	}, {
		key: 'itemCreating',
		get: function get$$1() {
			return this._itemCreating;
		}
	}, {
		key: 'itemCreated',
		get: function get$$1() {
			return this._itemCreated;
		}
	}, {
		key: 'itemModifying',
		get: function get$$1() {
			return this._itemModifying;
		}
	}, {
		key: 'itemModified',
		get: function get$$1() {
			return this._itemModified;
		}
	}, {
		key: 'itemDeleting',
		get: function get$$1() {
			return this._itemDeleting;
		}
	}, {
		key: 'itemDeleted',
		get: function get$$1() {
			return this._itemDeleted;
		}
	}, {
		key: 'recurringItemDeleting',
		get: function get$$1() {
			return this._recurringItemDeleting;
		}
	}, {
		key: 'itemInplaceEditStart',
		get: function get$$1() {
			return this._itemInplaceEditStart;
		}
	}, {
		key: 'itemInplaceEditEnd',
		get: function get$$1() {
			return this._itemInplaceEditEnd;
		}
	}, {
		key: 'itemReminderTriggered',
		get: function get$$1() {
			return this._itemReminderTriggered;
		}
	}, {
		key: 'taskReminderTriggered',
		get: function get$$1() {
			return this._taskReminderTriggered;
		}
	}, {
		key: 'itemDragStart',
		get: function get$$1() {
			return this._itemDragStart;
		}
	}, {
		key: 'itemDragEnd',
		get: function get$$1() {
			return this._itemDragEnd;
		}
	}, {
		key: 'itemResizeStart',
		get: function get$$1() {
			return this._itemResizeStart;
		}
	}, {
		key: 'itemResizeEnd',
		get: function get$$1() {
			return this._itemResizeEnd;
		}
	}, {
		key: 'itemClick',
		get: function get$$1() {
			return this._itemClick;
		}
	}, {
		key: 'itemDoubleClick',
		get: function get$$1() {
			return this._itemDoubleClick;
		}
	}, {
		key: 'formShow',
		get: function get$$1() {
			return this._formShow;
		}
	}, {
		key: 'formClose',
		get: function get$$1() {
			return this._formClose;
		}
	}, {
		key: 'buttonClick',
		get: function get$$1() {
			return this._buttonClick;
		}
	}, {
		key: 'cellClick',
		get: function get$$1() {
			return this._cellClick;
		}
	}, {
		key: 'cellDoubleClick',
		get: function get$$1() {
			return this._cellDoubleClick;
		}
	}, {
		key: 'headerClick',
		get: function get$$1() {
			return this._headerClick;
		}
	}, {
		key: 'headerDoubleClick',
		get: function get$$1() {
			return this._headerDoubleClick;
		}
	}, {
		key: 'cueClick',
		get: function get$$1() {
			return this._cueClick;
		}
		/*End Events */

		/*Properties */
		/**
  * Gets the date of the calendar.
  * @returns {DateTime} The date of the calendar.
  */

	}, {
		key: 'date',
		get: function get$$1() {
			return this._date;
		}

		/**
  * Sets the date of the calendar.
  * @param {DateTime} value The date of the calendar.
  */
		,
		set: function set$$1(value) {
			var oldValue = this._date;
			this._date = value;
			this.onPropertyChanged('date', oldValue, value);
		}

		/**
  * Gets the end date of the calendar.
  * @returns {DateTime} The end date of the calendar.
  */

	}, {
		key: 'endDate',
		get: function get$$1() {
			return this._endDate ? this._endDate : DateTime.addDays(this._date, DateTime.getDaysInMonth(this._date));
		}

		/**
  * Sets the end date of the calendar.
  * @param {DateTime} value The end date of the calendar.
  */
		,
		set: function set$$1(value) {
			var oldValue = this._endDate;
			this._endDate = value;
			this.onPropertyChanged('endDate', oldValue, value);
		}
	}, {
		key: 'startTime',
		get: function get$$1() {
			return this.view.startTime;
		}
	}, {
		key: 'endTime',
		get: function get$$1() {
			return this.view.endTime;
		}
	}, {
		key: 'itemsStartTime',
		get: function get$$1() {
			return this.view.itemsStartTime;
		}
	}, {
		key: 'itemsEndTime',
		get: function get$$1() {
			return this.view.itemsEndTime;
		}
		/**
  * Gets the tasks whose schedule to display when the GroupType property is set to GroupByTasks or FilterByTasks.
  * @returns {ObservableCollection} The tasks.
  */

	}, {
		key: 'tasks',
		get: function get$$1() {
			return this._tasks;
		}

		/**
  * Gets the contacts whose schedule to display when the GroupType property is set to GroupByContacts or FilterByContacts.
  * @returns {ObservableCollection} The contacts.
  */

	}, {
		key: 'contacts',
		get: function get$$1() {
			return this._contacts;
		}

		/**
  * Gets the resources whose schedule to display when the GroupType property is set to GroupByResources or FilterByResources.
  * @returns {ObservableCollection} The resources.
  */

	}, {
		key: 'resources',
		get: function get$$1() {
			return this._resources;
		}

		/**
  * Gets the locations whose schedule to display when the GroupType property is set to GroupByLocations or FilterByLocations.
  * @returns {ObservableCollection} The locations.
  */

	}, {
		key: 'locations',
		get: function get$$1() {
			return this._locations;
		}

		/**
  * Gets the css class of the calendar.
  * @returns {String} The name of the css class of the calendar.
  */

	}, {
		key: 'cssClass',
		get: function get$$1() {
			return this._cssClass;
		}

		/**
  * Sets the css class of the calendar.
  * @param {String} value The name of the css class of the calendar.
  */
		,
		set: function set$$1(value) {
			var oldValue = this._cssClass;
			this._cssClass = value;

			if (this._element) {
				DomUtils.removeCssClass(this._element, oldValue);
				DomUtils.addCssClass(this._element, value);
			}
		}

		/**
  * Gets a value indicating whether user interactions are allowed in the calendar.
  * @returns {Boolean} True if user interactions are allowed, otherwise false.
  */

	}, {
		key: 'enabled',
		get: function get$$1() {
			return this._enabled;
		}

		/**
  * Sets a value indicating whether user interactions are allowed in the calendar.
  * @param {Boolean} value True if user interactions are allowed, otherwise false.
  */
		,
		set: function set$$1(value) {
			this._enabled = value;
		}

		/**
  * Gets the type of the current view of the calendar.
  * @returns {CalendarView} The type of the current view.
  */

	}, {
		key: 'currentView',
		get: function get$$1() {
			return this._currentView;
		}

		/**
  * Sets the type of the current view of the calendar.
  * @param {CalendarView} value The type of the current view.
  */
		,
		set: function set$$1(value) {
			this.detach();
			var oldValue = this._currentView;
			this._currentView = value;
			this.onPropertyChanged('currentView', oldValue, value);
		}

		/**
  * Gets the current theme of the calendar.
  * @returns {String} The current theme. 
  */

	}, {
		key: 'theme',
		get: function get$$1() {
			return this._theme;
		}

		/**
  * Gets the current theme of the calendar.
  * @param {String} value The current theme. 
  */
		,
		set: function set$$1(value) {
			var oldValue = this._theme;
			this._theme = value;
			this.onPropertyChanged('theme', oldValue, value);
		}

		/**
  * Gets the grouping or filtering criteria for the calendar.
  * @returns {GroupType} The grouping criteria.
  */

	}, {
		key: 'groupType',
		get: function get$$1() {
			return this._groupType;
		}

		/**
  * Sets the grouping or filtering criteria for the calendar.
  * @param {GroupType} value The grouping criteria.
  */
		,
		set: function set$$1(value) {
			var oldValue = this._groupType;
			this._groupType = value;
			this.onPropertyChanged('groupType', oldValue, value);
		}

		/**
  * Gets a value indicating whether calendar's items can be inplace-edited.
  * @returns {Boolean} True if the calendar's items can be inplace-edited, otherwise false.
  */

	}, {
		key: 'allowInplaceEdit',
		get: function get$$1() {
			return this._allowInplaceEdit;
		}

		/**
  * Sets a value indicating whether calendar's items can be inplace-edited.
  * @param {Boolean} value True if the calendar's items can be inplace-edited, otherwise false.
  */
		,
		set: function set$$1(value) {
			this._allowInplaceEdit = value;
		}

		/**
  * Gets a value indicating whether the built-in forms for item editing will be used.
  * @returns {Boolean} True if the built-in forms will be used, otherwise false.
  */

	}, {
		key: 'useForms',
		get: function get$$1() {
			return this._useForms;
		}

		/**
  * Sets a value indicating whether the built-in forms for item editing will be used.
  * @param {Boolean} value True if the built-in forms will be used, otherwise false.
  */
		,
		set: function set$$1(value) {
			this._useForms = value;
		}

		/**
  * Gets a value indicating whether to show tooltips.
  * @returns {Boolean} True to show tooltips, otherwise false.
  */

	}, {
		key: 'showTooltips',
		get: function get$$1() {
			return this._showTooltips;
		}

		/**
  * Sets a value indicating whether to show tooltips.
  * @param {Boolean} value True to show tooltips, otherwise false.
  */
		,
		set: function set$$1(value) {
			this._showTooltips = value;
		}

		/**
  * Gets a value indicating how to format and display contact names in view headers.
  * @returns {String} The format string.
  * @remarks Capital letters F, M and L are used as placeholders for the
  * First, Middle and Last names. Any other character are displayed unchanged.
  */

	}, {
		key: 'contactNameFormat',
		get: function get$$1() {
			return this._contactNameFormat;
		}

		/**
  * Sets a value indicating how to format and display contact names in view headers.
  * @param {String} value The format string.
  * @remarks Use the capital letters F, M and L as placeholders for the
  * First, Middle and Last names. Any other character will be displayed unchanged.
  */
		,
		set: function set$$1(value) {
			this._contactNameFormat = value;
		}

		/**
  * Gets the schedule to be displayed inside the calendar.
  * @returns {Schedule} The schedule.
  */

	}, {
		key: 'schedule',
		get: function get$$1() {
			return this._schedule;
		}
		/**
  * Sets the schedule to be displayed inside the calendar.
  * @param {Schedule} value The schedule.
  */
		,
		set: function set$$1(value) {
			if (this._schedule) {
				this._schedule.changed.removeEventListener(this._scheduleChangedHandler);
			}
			this._schedule = value;

			this._schedule.changed.addEventListener(this._scheduleChangedHandler);
		}

		/**
  * Gets the current calendar date-time selection.
  * @returns {Selection} An instance of the Selection class.
  */

	}, {
		key: 'selection',
		get: function get$$1() {
			return this._selection;
		}

		/**
  * Gets the current item selection.
  * @returns {ObservableCollection} The list of currently selected items.
  */

	}, {
		key: 'itemSelection',
		get: function get$$1() {
			return this._itemSelection;
		}
	}, {
		key: 'popups',
		get: function get$$1() {
			return this._popups;
		}

		/**
  * Gets the MonthSettings object used to customize the appearance of the SingleMonth view.
  * @returns {MonthSettings} The settings.
  */

	}, {
		key: 'monthSettings',
		get: function get$$1() {
			var _this3 = this;

			if (!this._monthSettings) {
				this._monthSettings = new MonthSettings(this);
				this._monthSettings._propertyChanged.addEventListener(function (sender, args) {
					_this3.onViewSettingsChanged(sender, args);
				});
			}
			return this._monthSettings;
		}

		/**
  * Gets the TimetableSettings object used to customize the appearance of the Timetable view.
  * @returns {TimetableSettings} The settings.
  */

	}, {
		key: 'timetableSettings',
		get: function get$$1() {
			var _this4 = this;

			if (!this._timetableSettings) {
				this._timetableSettings = new TimetableSettings(this);
				this._timetableSettings._propertyChanged.addEventListener(function (sender, args) {
					_this4.onViewSettingsChanged(sender, args);
				});
			}
			return this._timetableSettings;
		}

		/**
  * Gets the ListSettings object used to customize the appearance of the List view.
  * @returns {ListSettings} The settings.
  */

	}, {
		key: 'listSettings',
		get: function get$$1() {
			var _this5 = this;

			if (!this._listSettings) {
				this._listSettings = new ListSettings(this);
				this._listSettings._propertyChanged.addEventListener(function (sender, args) {
					_this5.onViewSettingsChanged(sender, args);
				});
			}
			return this._listSettings;
		}

		/**
  * Gets the WeekRangeSettings object used to customize the appearance of the WeekRange view
  * @returns {WeekRangeSettings} The settings.
  */

	}, {
		key: 'weekRangeSettings',
		get: function get$$1() {
			var _this6 = this;

			if (!this._weekRangeSettings) {
				this._weekRangeSettings = new WeekRangeSettings(this);
				this._weekRangeSettings._propertyChanged.addEventListener(function (sender, args) {
					_this6.onViewSettingsChanged(sender, args);
				});
			}
			return this._weekRangeSettings;
		}

		/**
  * Gets the ResourceViewSettings object used to customize the appearance of the Resource view
  * @returns {ResourceViewSettings} The settings.
  */

	}, {
		key: 'resourceViewSettings',
		get: function get$$1() {
			var _this7 = this;

			if (!this._resourceViewSettings) {
				this._resourceViewSettings = new ResourceViewSettings(this);
				this._resourceViewSettings._propertyChanged.addEventListener(function (sender, args) {
					_this7.onViewSettingsChanged(sender, args);
				});
			}
			return this._resourceViewSettings;
		}

		/**
  * Gets the MonthRangeSettings object used to customize the appearance of the MonthRange view
  * @returns {MonthRangeSettings} The settings.
  */

	}, {
		key: 'monthRangeSettings',
		get: function get$$1() {
			var _this8 = this;

			if (!this._monthRangeSettings) {
				this._monthRangeSettings = new MonthRangeSettings(this);
				this._monthRangeSettings._propertyChanged.addEventListener(function (sender, args) {
					_this8.onViewSettingsChanged(sender, args);
				});
			}
			return this._monthRangeSettings;
		}

		/**
  * Gets the ItemSettings object used to customize the appearance of calendar items.
  * @returns {ItemSettings} The settings.
  */

	}, {
		key: 'itemSettings',
		get: function get$$1() {
			var _this9 = this;

			if (!this._itemSettings) {
				this._itemSettings = new ItemSettings(this);
				this._itemSettings._propertyChanged.addEventListener(function (args) {
					_this9.onItemSettingsChanged(args);
				});
			}
			return this._itemSettings;
		}

		/**
  * Gets the locale object used to format and display localizable information in the calendar.
  * @returns {Object} The locale.
  */

	}, {
		key: 'locale',
		get: function get$$1() {
			if (!this._locale) this._locale = locale;
			return this._locale;
		}

		/**
  * Sets the locale object used to format and display localizable information in the calendar.
  * @param {Object} value The locale.
  */
		,
		set: function set$$1(value) {
			this._locale = value;
		}

		/**
  * Gets the locale object used to format and display date and time information in the calendar.
  * @returns {Object} The format info object.
  */

	}, {
		key: 'formatInfo',
		get: function get$$1() {
			if (!this._formatInfo) {
				this._formatInfo = this.locale.date;
			}

			return this._formatInfo;
		}

		/**
  * Gets the locale object used to format and display localizable strings in the calendar.
  * @returns {Object} The local info object.
  */

	}, {
		key: 'localInfo',
		get: function get$$1() {
			if (!this._localInfo) {
				this._localInfo = this.locale.strings;

				if (!this._localInfo) {
					this._localInfo = locale.strings;
				}
			}

			return this._localInfo;
		}

		/**
    * Gets the URL of the calendar's license file.
    * @returns {String} A valid URL string that specifies the location of the license key.
    */

	}, {
		key: 'licenseLocation',
		get: function get$$1() {
			return this._licenseLocation;
		}

		/**
  * Sets the URL of the calendar's license file.
  * @param {String} value A valid URL string that specifies the location of the license key.
  */
		,
		set: function set$$1(value) {
			if (this._licenseLocation != value) {
				this._licenseLocation = value;
			}
		}
	}], [{
		key: 'ns',
		get: function get$$1() {
			return "MindFusion.Scheduling";
		}
	}, {
		key: 'autoRepaint',
		get: function get$$1() {
			return this._autoRepaint != false;
		},
		set: function set$$1(value) {
			this._autoRepaint = value;
		}
	}]);
	return Calendar;
}();

exports.Calendar = Calendar;
exports.Contact = Contact;
exports.DateTime = DateTime;
exports.CalendarView = CalendarView;
exports.ResourceViewTimeline = ResourceViewTimeline;
exports.TimeUnit = TimeUnit;
exports.DayOfWeekFormat = DayOfWeekFormat;
exports.MainHeaderStyle = MainHeaderStyle;
exports.VerticalHeaderStyle = VerticalHeaderStyle;
exports.HorizontalHeaderStyle = HorizontalHeaderStyle;
exports.Orientation = Orientation;
exports.TaskPriority = TaskPriority;
exports.TaskStatus = TaskStatus;
exports.ReminderType = ReminderType;
exports.RecurrenceState = RecurrenceState;
exports.RecurrencePattern = RecurrencePattern;
exports.DailyRecurrence = DailyRecurrence;
exports.MonthlyRecurrence = MonthlyRecurrence;
exports.YearlyRecurrence = YearlyRecurrence;
exports.Occurrence = Occurrence;
exports.DayOfWeekType = DayOfWeekType;
exports.RecurrenceEnd = RecurrenceEnd;
exports.DayOfWeek = DayOfWeek;
exports.DaysOfWeek = DaysOfWeek;
exports.ItemModifyAction = ItemModifyAction;
exports.GroupType = GroupType;
exports.WeekRangeViewStyle = WeekRangeViewStyle;
exports.Keys = Keys;
exports.HeaderType = HeaderType;
exports.RepaintType = RepaintType;
exports.FormEventArgs = FormEventArgs;
exports.ButtonEventArgs = ButtonEventArgs;
exports.CellEventArgs = CellEventArgs;
exports.HeaderEventArgs = HeaderEventArgs;
exports.SelectionEventArgs = SelectionEventArgs;
exports.ItemEventArgs = ItemEventArgs;
exports.ItemModifyingEventArgs = ItemModifyingEventArgs;
exports.ItemModifiedEventArgs = ItemModifiedEventArgs;
exports.TaskEventArgs = TaskEventArgs;
exports.DateChangedEventArgs = DateChangedEventArgs;
exports.Item = Item;
exports.ItemSettings = ItemSettings;
exports.ListSettings = ListSettings;
exports.Location = Location;
exports.MonthRangeSettings = MonthRangeSettings;
exports.MonthSettings = MonthSettings;
exports.Recurrence = Recurrence;
exports.Reminder = Reminder;
exports.Resource = Resource;
exports.ResourceViewSettings = ResourceViewSettings;
exports.Schedule = Schedule;
exports.Selection = Selection;
exports.Task = Task;
exports.TimelineSettings = TimelineSettings;
exports.TimeRange = TimeRange;
exports.TimeSpan = TimeSpan;
exports.TimetableSettings = TimetableSettings;
exports.ViewCell = ViewCell;
exports.WeekRangeSettings = WeekRangeSettings;
exports.Dictionary = Dictionary;
exports.IEnumerable = IEnumerable;
exports.List = List;
exports.ObservableCollection = ObservableCollection;
exports.BaseForm = BaseForm;
exports.BaseControl = BaseControl;
exports.EditBox = EditBox;
exports.CheckBoxList = CheckBoxList;

Object.defineProperty(exports, '__esModule', { value: true });

})));
